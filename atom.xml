<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Smiecj的小窝</title>
  <icon>https://www.gravatar.com/avatar/8b59dee7e59ad63ca309edd9effc2618</icon>
  <subtitle>tech make life better</subtitle>
  <link href="http://smiecj.github.io/atom.xml" rel="self"/>
  
  <link href="http://smiecj.github.io/"/>
  <updated>2022-12-27T16:00:00.000Z</updated>
  <id>http://smiecj.github.io/</id>
  
  <author>
    <name>smiecj</name>
    <email>xxx@gmail.com</email>
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Docker 常用指令</title>
    <link href="http://smiecj.github.io/2022/12/28/docker-command/"/>
    <id>http://smiecj.github.io/2022/12/28/docker-command/</id>
    <published>2022-12-27T16:00:00.000Z</published>
    <updated>2022-12-27T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://t.csdn.cn/2g21n">本文csdn地址</a></p><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>对于 Docker 这一个“庞然大物” 来说，想用好它其实没有这么难，掌握好基本几个指令就可以了，这里将平时自己用得多的整理一下</p><h2 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h2><table><thead><tr><th>指令类型</th><th>指令</th><th>功能</th></tr></thead><tbody><tr><td><strong>基本</strong></td><td>docker login</td><td>登录镜像仓库</td></tr><tr><td><strong>镜像操作</strong></td><td><a href="https://docs.docker.com/engine/reference/commandline/images/">docker images</a></td><td>查看本地镜像信息</td></tr><tr><td></td><td><a href="https://docs.docker.com/engine/reference/commandline/pull/">docker pull</a></td><td>拉取镜像</td></tr><tr><td></td><td><a href="https://docs.docker.com/engine/reference/commandline/tag/">docker tag</a></td><td>给一个镜像添加另一个tag</td></tr><tr><td></td><td><a href="https://docs.docker.com/engine/reference/commandline/rmi/">docker rmi</a> <image_id></td><td>删除镜像</td></tr><tr><td></td><td><a href="https://docs.docker.com/engine/reference/commandline/commit/">docker commit</a> -m <msg> -a <tag> <container_id> <image_name></td><td>容器打包成镜像</td></tr><tr><td></td><td><a href="https://docs.docker.com/engine/reference/commandline/push/">docker push</a></td><td>提交镜像到远端仓库</td></tr><tr><td></td><td><a href="https://docs.docker.com/engine/reference/commandline/inspect/">docker inspect</a></td><td>查看本地/远端镜像信息</td></tr><tr><td></td><td><a href="https://docs.docker.com/engine/reference/commandline/image_prune/">docker image prune</a></td><td>清理无用镜像(<strong>小心执行</strong>)</td></tr><tr><td></td><td><a href="https://docs.docker.com/engine/reference/commandline/save/">docker save</a> <image_name> &gt; image.tar</td><td>保存镜像到 tar</td></tr><tr><td></td><td><a href="https://docs.docker.com/engine/reference/commandline/load/">docker load</a> image.tar</td><td>从tar 包中还原镜像</td></tr><tr><td><strong>容器操作</strong></td><td>docker ps</td><td>查看容器列表</td></tr><tr><td></td><td><a href="https://docs.docker.com/engine/reference/run/">docker run</a></td><td>启动容器<br>docker run -p 3306:3306 –name mysql -e MYSQL_ROOT_PASSWORD=123456 -d mysql:5.7</td></tr><tr><td></td><td><a href="https://docs.docker.com/engine/reference/commandline/rm/">docker rm</a> <container_id></td><td>删除容器</td></tr><tr><td></td><td><a href="https://docs.docker.com/engine/reference/commandline/exec/">docker exec</a> -it <container_id> /bin/bash</td><td>进入容器</td></tr><tr><td></td><td><a href="https://docs.docker.com/engine/reference/commandline/container_prune/">docker container prune</a></td><td>清理未运行的容器</td></tr><tr><td></td><td><a href="https://docs.docker.com/engine/reference/commandline/logs/">docker logs</a> <container_id></td><td>查看容器/服务日志</td></tr><tr><td><strong>volume</strong></td><td><a href="https://docs.docker.com/engine/reference/commandline/volume_ls/">docker volume ls</a></td><td>查看所有 volume</td></tr><tr><td><strong>network</strong></td><td><a href="https://docs.docker.com/engine/reference/commandline/network_ls/">docker network ls</a></td><td>查看当前所有网络</td></tr><tr><td></td><td><a href="https://docs.docker.com/engine/reference/commandline/network_create/">docker network create</a></td><td>创建网络</td></tr><tr><td><strong>服务状态</strong></td><td><a href="https://docs.docker.com/engine/reference/commandline/stats/">docker stats</a></td><td>查看服务实时状态，每个容器的资源使用情况</td></tr><tr><td></td><td><a href="https://docs.docker.com/engine/reference/commandline/info/">docker info</a></td><td>查看 docker 安装版本信息、基本配置等</td></tr><tr><td></td><td><a href="https://docs.docker.com/engine/reference/commandline/system_df/">docker system df</a></td><td>拉取镜像<br>-v: 查看具体信息，比如每个容器的磁盘占用</td></tr></tbody></table>]]></content>
    
    
    <summary type="html">Docker 常用指令整理</summary>
    
    
    
    <category term="开发工具" scheme="http://smiecj.github.io/categories/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"/>
    
    <category term="Docker" scheme="http://smiecj.github.io/categories/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/Docker/"/>
    
    
    <category term="Linux" scheme="http://smiecj.github.io/tags/Linux/"/>
    
    <category term="Docker" scheme="http://smiecj.github.io/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>【翻译】mabataki 歌曲鉴赏</title>
    <link href="http://smiecj.github.io/2022/11/12/vaundy-mabataki/"/>
    <id>http://smiecj.github.io/2022/11/12/vaundy-mabataki/</id>
    <published>2022-11-11T16:00:00.000Z</published>
    <updated>2022-11-11T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="译者序言"><a href="#译者序言" class="headerlink" title="译者序言"></a>译者序言</h2><p>译者: Vaundy 作为日本乐坛强大的新生代力量之一，每首歌都有自己独特的曲风，今年同样有非常值得欣赏的几首音乐<br>这里特别是想评一下 mabataki 这首音乐，特别是在今年，在疫情，战争，世界经济下行等大背景下，这首确实有属于它独特的意义<br>这里将一篇日语的浅析文章翻译一下。日语能力有限，还请多多包涵~</p><p><a href="https://media.framu.world/columns/lyrics_consideration/mabataki-3">原文地址</a><br>原文标题: mabataki【Vaundy】歌詞の意味を考察！もし〇〇な世界だったら人は、優しくなれるのだろうか？<br>mabataki 歌词的意味考察！如果世界是〇〇样子的，生活在其中的人们能彼此温柔以待吗？</p><p><a href="https://twitter.com/Vaundy_AWS/status/1568254768111550464">新歌发布信息</a></p><p><a href="https://music.163.com/#/song?id=1980109662">歌词翻译参考-网易云</a></p><h2 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h2><p>这首是 9月9日 Vaundy 在武道馆举办的 one man live tour 演唱会中，在最后演奏的新曲<br>在演唱会中间，Vaundy 还宣布了将于 2023年11月 在5个城市举办10场大型公演的计划<br>大家对 「mabataki」 的歌词有什么样的感想呢？让我们一起看看吧</p><p><a href="https://www.youtube.com/watch?v=6h6AQbdTkaE">歌曲MV地址(油管)</a><br><a href="https://www.bilibili.com/video/BV1UP411J7wE">歌曲MV地址(B站)</a></p><h2 id="副歌部分（开头）"><a href="#副歌部分（开头）" class="headerlink" title="副歌部分（开头）"></a>副歌部分（开头）</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">もし何も</span><br><span class="line">忘れられない世界で</span><br><span class="line">出会い会ってしまったら</span><br><span class="line">憎み合うのはやめるだろうか</span><br><span class="line">もし何も</span><br><span class="line">覚えられない世界で</span><br><span class="line">すれ違ってしまったら</span><br><span class="line">振り向き合うようになるだろうか</span><br><span class="line">なんて</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">如果我们在无法忘却任何事情的世界中相遇</span><br><span class="line">也许我们都会放下彼此的憎恨吧</span><br><span class="line">如果我们在无法记起任何事情的世界中擦肩而过</span><br><span class="line">也许会为了彼此，互相奔赴转身的吧</span><br></pre></td></tr></table></figure><p>开头以主人公向自身发起提问的场景开始<br>如果这个世界能记住所有发生过的事情，我们能够放下那些和他人之间不愉快的回忆，抛弃对彼此的憎恨吗？<br>反过来，如果这个世界不再记得发生过的任何事情，我们能忘记来自过去的怨恨，让彼此的关系破镜重圆吗？<br>我仿佛听见了（歌曲）作者对世界是否能变得更加安稳和平的祈祷</p><p>当然在实际的世界中，我们还是会忘记一些事情，也会有一些一直记得的事情<br>但如果这个世界发生了极端的变化，（世界和我们自己）会变成什么样呢？<br>也许作者正是带着这种哲学性的疑问，才想着唱出了这首歌吧</p><p><img src="/2022/11/12/vaundy-mabataki/mabataki09.png" alt="MV画面"><sup><font color='#dfa0ee'><center>MV 开头场景</center></font></sup></p><h2 id="副歌部分1"><a href="#副歌部分1" class="headerlink" title="副歌部分1"></a>副歌部分1</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">どこにも見えない敵を今</span><br><span class="line">そこにあてがい</span><br><span class="line">人々は考えることをやめていた。</span><br><span class="line">薄れてく希望は</span><br><span class="line">徐々に蝕み</span><br><span class="line">弾倉の中に願いを込め始めた人々は</span><br><span class="line">また泣き出してしまう</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">一直以来看不见的敌人，如今也出现在了那里</span><br><span class="line">人们逐渐失去了思考，原本就微薄的希望，也慢慢地被侵蚀</span><br><span class="line">开始往弹夹中装入愿望的人们，不禁再次潸然泪下</span><br></pre></td></tr></table></figure><p>如果 什么事都会记得的世界，争端逐渐消失的话<br>如果 什么事都会被忘记的世界，温柔逐渐被孕育出来的话<br>我们当下生活在的现实世界，会变成什么样呢？是否会有所不同？</p><p>“どこにも見えない敵を今 そこにあてがい 人々は考えることをやめていた。”<br>这部分我感觉，作者是针对 当今社会中 一群在网络上 对别人随意恶语中伤、对世界形势冷漠不关心的社会现象，而提出的感想<br>本来这个世界应该是朝着争端更少、充满和平的方向发展的，但人们在面对真正最大的问题：那些看不见的“敌人”的时候，反而逃避了<br>渐渐变得淡薄的希望，渐渐被侵蚀和变得冷漠的人心，由此逐渐衍生出的各种争端、憎恨甚至战争。当我们回想到这些，可能会在某一时刻流下伤感的泪水吧<br>Vaundy 将那些试图通过战争解决争端的人们，形容成“开始在弹夹中寄托希望的人们”，真的是很厉害</p><p><img src="/2022/11/12/vaundy-mabataki/mabataki04.png" alt="MV画面"></p><h2 id="主歌部分2"><a href="#主歌部分2" class="headerlink" title="主歌部分2"></a>主歌部分2</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">足並みを揃え始めた</span><br><span class="line">疑いは罵倒となり</span><br><span class="line">人を食べた。</span><br><span class="line">薄れてく心は</span><br><span class="line">徐々に蝕み</span><br><span class="line">透明な刃に嫉みを込め始めた人々は</span><br><span class="line">まだ泣き止まずにいる</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">我们终于开始变得步伐一致</span><br><span class="line">但彼此的怀疑依然变成了谩骂，吞没了人们</span><br><span class="line">逐渐变得淡薄的内心，也慢慢被侵蚀</span><br><span class="line">开始把嫉妒化作透明的刀刃的人们，无法停下失声哭泣</span><br></pre></td></tr></table></figure><p>终于开始收拢相同步伐的我们，内心还是无法放下微小的猜忌，任由它发酵，最后变成了在现实中的争端</p><p>从古代就在不断发生的人类之间的冲突，在21世纪的当下依然在继续，有一种让人失望和悲伤的感觉</p><p>“<strong>人を食べた</strong>”这句歌词，（通过夸张）表现出了一种战争的失败方被胜方吸收掉的假想，很好地表现出了当今的世界形势（规则）</p><p>“<strong>薄れてく心は 徐々に蝕み 透明な刃に嫉みを込め始めた人々は まだ泣き止まずにいる</strong>”</p><p>透明的刀刃，也许说的是人们（无意中）伤害他人的话语<br>现代社会，谁都可以在网上发表评论，因为看不到他人的面孔（不知道别人听到你的话到底会怎么样），很多人都没有带着平静的心情，就开始在网络上表现情绪，随意宣泄自己的不满<br>不管是在现实还是在虚拟世界中的冲突，都是由于人类空虚的内心产生的，不禁让人感到一丝丝伤感</p><p><img src="/2022/11/12/vaundy-mabataki/mabataki06.png" alt="MV画面"></p><h2 id="过渡部分"><a href="#过渡部分" class="headerlink" title="过渡部分"></a>过渡部分</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">纏う悲しみが今</span><br><span class="line">また人を傷つけてしまう</span><br><span class="line">もう僕が先に銃を捨てよう</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">缠绕在人们内心的悲伤</span><br><span class="line">如今再次对大家造成痛楚</span><br><span class="line">那么我就先把手上的枪先丢在地上吧</span><br></pre></td></tr></table></figure><p>之前缠绕在人们内心的伤感、承受失败的感情，继续传染给了周围的人们，所有人都笼罩在一种消极的气氛中</p><p>我们应该怎么走出这种地狱般的负面情绪的循环呢？</p><p>在重复的合唱副歌部分，<strong>作者通过不断的自问自答的方式</strong>，逐渐在内心下定觉悟: 首先把自己心中的枪放下</p><p>把枪放下后，也许会被无声的语言攻击，会被看不见的刀刃弄伤</p><p>但如果不放下我们心中那把为了自卫装上的枪，也许也不能够把内心真正的想法 传达出来，作者想得到的结论也许正是这个吧</p><p>这几句歌词，读出了主人公内心坚定的决意</p><p><img src="/2022/11/12/vaundy-mabataki/mabataki10.jpeg" alt="MV画面"></p><h2 id="副歌部分2"><a href="#副歌部分2" class="headerlink" title="副歌部分2"></a>副歌部分2</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">もし誰も</span><br><span class="line">見つめ合えない世界で</span><br><span class="line">出会い会ってしまったら</span><br><span class="line">手を握って話すだろうか</span><br><span class="line">もし僕ら</span><br><span class="line">明日が最後としたら</span><br><span class="line">憎み合うのはやめるだろうか</span><br><span class="line">思い合うようになるだろうか</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">如果我们在一个无法好好对视的世界相遇的话</span><br><span class="line">也许会握紧彼此的手好好说话的吧</span><br><span class="line">如果明天是世界终焉之日的话</span><br><span class="line">也许我们都会放下心中憎恨的吧</span><br><span class="line">会开始想念彼此的吧</span><br></pre></td></tr></table></figure><p>这也许是一种讽刺的表现吧？<br>在一个无法认真对视的世界中相遇的话，我们能好好握住彼此的手交谈吗？不，也许根本不能<br>但我们实际生活着的世界中，是可以好好和别人面对面交谈的。因此好好坐下来，真诚地握住对方的手，注视对方认真交谈的话，也许就不会产生这么多无谓的争执了</p><p>如果明天就是世界终焉之日，我们彼此之间的憎恨也会消失的吧？<br>正因为谁都无法知道，什么时候会走到人生结束那一天，对我们来说，不如停止憎恨，互相体谅对方，以这种方式生活下去，也许也是可以的吧？</p><p>感觉到了作者对向着<strong>构建和平世界</strong>（或未来）而一起努力的呼吁</p><p><img src="/2022/11/12/vaundy-mabataki/mabataki07.png" alt="MV画面"></p><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>大家感觉怎么样？<br>感觉这真的是 Vaundy 对和平愿望表达深切，非常棒的曲子了<br>明年在 演唱会 tour 中他会以怎样的姿态在我们面前展示呢？就让我们一起期待吧～</p><p><img src="/2022/11/12/vaundy-mabataki/mabataki11.png" alt="开头"></p><h2 id="部分生词"><a href="#部分生词" class="headerlink" title="部分生词"></a>部分生词</h2><p><a href="https://www.weblio.jp/">词语解析来源: weblio 辞書</a></p><p><strong>弾倉</strong><br>連発銃で、補充用の弾丸をこめる部分。</p><p><strong>足並み</strong><br>1 複数の人や馬の足の運びのそろいぐあい。歩調。<br>2 考え方や行動のそろいぐあい。<br>3（「に」を伴って副詞的に）一歩進むごとに。</p><p><strong>嫉み</strong><br>自分と他人を比べ、他人の優れた部分を羨み、憎く思うこと。似たような意味の「妬み」が、相手に対しての憎しみが強いのに対し、相手が優れていることに対して劣等感を抱くという意味合いが強い。</p><p><strong>仮定</strong><br>1 未定のこと、不確かなことを仮にこうと定めること。また、仮に定めた事柄。<br>2 論理学などで、ある命題を導き出す推論の出発点におかれる前提条件。仮設。</p><p><strong>伝染</strong><br>1 病原体が他の生物体に入り、増殖して病気になること。感染。「はしかが―する」<br>2 物事の状態・傾向などが他に移って同じような状態が起こること。「あくびが―する」</p><h2 id="一点点感受"><a href="#一点点感受" class="headerlink" title="一点点感受"></a>一点点感受</h2><p>最后想说说翻译之后的感想:<br>翻译文章最难的部分真的不是去查询、记住生词，而是在<strong>外语和母语之间表达模式的切换</strong>。就这篇文章来说，我觉得我并没有很好地把作者的语气表达出来，可能是日语的<strong>语境</strong>和中文之间差别还是比较大</p><p>举个例子：日语经常在一句话结尾带上疑问语气，但更多地想表达的意思其实是肯定。带上疑问只是语言习惯而已，比如这句：<br>“<strong>これは、反語的な表現なのではないでしょうか？</strong>”<br>其实已经肯定形势: “这是讽刺的表现形式” 的意思了，<strong>でしょう</strong> 只是希望引起读者的共鸣，并不表示疑问</p><p>而这种东西，翻译软件是不会教你的，只能后面翻译更多的文章，多去理解</p>]]></content>
    
    
    <summary type="html">向往平和的世界</summary>
    
    
    
    <category term="听歌" scheme="http://smiecj.github.io/categories/%E5%90%AC%E6%AD%8C/"/>
    
    <category term="Vaundy" scheme="http://smiecj.github.io/categories/%E5%90%AC%E6%AD%8C/Vaundy/"/>
    
    
    <category term="听歌" scheme="http://smiecj.github.io/tags/%E5%90%AC%E6%AD%8C/"/>
    
    <category term="日语" scheme="http://smiecj.github.io/tags/%E6%97%A5%E8%AF%AD/"/>
    
  </entry>
  
  <entry>
    <title>【翻译】软件工程师的通用技巧</title>
    <link href="http://smiecj.github.io/2022/10/31/software-soft-parts/"/>
    <id>http://smiecj.github.io/2022/10/31/software-soft-parts/</id>
    <published>2022-10-30T16:00:00.000Z</published>
    <updated>2022-10-30T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://addyosmani.com/blog/software-engineering-soft-parts">原文地址</a><br><a href="https://blog.csdn.net/xiaoliizi/article/details/127677921">本文csdn地址</a><br><a href="https://mp.weixin.qq.com/s/jfpXGMENp_kjhBycmRayew">本文公众号地址</a></p><h2 id="关于本文"><a href="#关于本文" class="headerlink" title="关于本文"></a>关于本文</h2><p>作者以10年在谷歌的开发经验，总结出了一套通用的方法论。译者这里对文章进行粗略的翻译，希望能对从事软件行业的同学有一定帮助，引起大家对平时所做、所看和所学的思考</p><ul><li>注1: 本文保留原文的章节架构，为易于理解，再对内容做适当的筛减和补充，偶尔扩展译者从自身经验角度的理解</li><li>注2: 原文很长，章节也比较多。建议大家分批次阅读，每次读两三个点，偶尔记下自己的思考，这样读起来不会这么枯燥</li><li>注3: 翻译和技术水平都有限，不一定能把作者的原意传达非常到位。因此建议有余力的同学去品一品原文，当然如果你读了我的翻译能有点共鸣，那也算是我的荣幸</li></ul><h2 id="作者介绍"><a href="#作者介绍" class="headerlink" title="作者介绍"></a>作者介绍</h2><p><strong>Addy Osmani</strong><sup><font color='#49E844'>[1]</font></sup> 是一位 爱尔兰籍 软件工程师和领导，目前在谷歌浏览器团队工作。他已经在谷歌工作10年，致力于让网页（访问速度）更快。他还曾在 AOL（America Online，美国在线） 和 Fortune 500（500强） 站点工作。 Addy 还是 《Learning JavaScript Design Patterns》、《Learning Patterns》和 《Image Optimization》等书籍的作者</p><p>作者博客首页<sup><font color='#49E844'>[2]</font></sup></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>今天我将会介绍软件工程中，关于 <strong>通用技巧</strong><sup><font color='#49E844'>[3]</font></sup>（soft skills）的部分。这些技巧是我在谷歌浏览器的前10年学到的，在这里我还成为了高级工程师。在工作10周年纪念之际，我想回忆一些一直伴随自己的课程，也希望这些技巧对读者的职业发展有所帮助</p><p>成为一名优秀工程师的过程是不断积累经验的过程。每个项目，不管多大多小，都是你学习技术、丰富自己工具箱的好机会。随着不断积累，当你能够把 从一个项目中学到的技能包，应用在另一个项目 去解决问题的时候，将会有事半功倍的效果</p><p>还需要说明：我说的话可能都不重要，一切以你的理解为准（YMMV）:)</p><h2 id="所有章节一览"><a href="#所有章节一览" class="headerlink" title="所有章节一览"></a>所有章节一览</h2><ul><li>精通</li><li>批判性思考，提出关键因素</li><li>巩固基础知识</li><li>通用知识点</li><li>效率</li><li>做出更好的选择</li><li>专注于用户（需求），其他事情会跟着走</li><li>提升自己的能力</li><li>利用参与新项目的优势，学习新技术</li><li>保持好奇心，保持学习</li><li>经常做笔记</li><li>Leader承认自己不知道的方面，将会很有感染力</li><li>Leader 也需要承认自己犯的错误</li><li>做开源项目的caretaker（管理者），而不是owner（所有人）</li><li>技术的广度和宽度</li><li>从实践中学习</li><li>通用代码 vs 专用代码</li><li>Deep module (模块化) 思想</li><li>学会管理一个项目</li><li>从新项目（green-field）中学习</li><li>定义完成事项</li><li>分阶段发布</li><li>系统性调试</li><li>设计文档的重要性</li><li>文档审查</li><li>定义你的沟通方式</li><li>耐心、深思熟虑</li><li>学会说“不”</li><li>接受与尊重</li><li>信息分享</li><li>灵活性</li><li>保持记录</li><li>真诚</li><li>资历和战略思维</li><li>以身作则</li><li>提升你的影响力</li><li>“不能胜任”综合症</li><li>指导他人</li><li>面向领域层面进行指导</li><li>组织层面的指导</li><li>学员的职责</li><li>构建信任</li><li>理解业务模型</li><li>提升你的影响力</li><li>时间管理</li><li>过度工作并不是好的工作素养</li><li>不断尝试超越自己的标准是不现实的</li><li>你不需要知道每一件时事</li><li>通过学会说不、了解什么时候该停下来、以及规划好自己的时间（包括工作间隙的休息），主动把自己从焦虑中解放出来</li><li>鼓励你和你的团队成员进行休息、旅游和调休</li><li>随着对问题的了解深入，更新（排期）评估</li><li>有时取消项目是正确的选择（即便是让人感到不舒服）</li><li>关于技术债：预防远远 &gt; 补救</li><li>如果没有充足的休息，和 work-life balance（的习惯），你的团队将会产生职业倦怠</li><li>大型组织/公司中流程会比较缓慢</li><li>专注于 问题 VS 专注于 项目</li></ul><h2 id="学习新知识"><a href="#学习新知识" class="headerlink" title="学习新知识"></a>学习新知识</h2><p>这部分内容能帮助大部分初级和中级工程师 成长，结合软件行业的基本流程和业界的最佳实践，构建复杂系统。尽量跟随业界的<strong>第一原则</strong><sup><font color='#49E844'>[4]</font></sup>。比如将大问题拆解成一个个小问题，就是你职业生涯中非常重要的技能之一</p><h3 id="精通"><a href="#精通" class="headerlink" title="精通"></a>精通</h3><p>对技术的精通，能帮你在工作时间产生更多的价值</p><p>你可以发现产生价值的工作点，并帮助你的团队将精力放到这件事情上来。同时，也能避免时间花在产出低效的事情上，<strong>优秀的工程师甚至可以带领团队从低效事情中解放出来</strong>，把工作放在最有价值的事情上</p><p>作者经常被（请教）问到：“如何知道我在充分使用自己的时间？”。你可能总是会有 能让自己变忙的各种任务，但真正的诀窍是确保你所做的是“对的事情”。如果你想移动整座山，那么你应该关注如何移动土堆，即使移动很小（即：愚公移山）</p><p>一些你可以经常问自己的问题:</p><ul><li>我的目标是什么？我所做的事情是否都是为了目标服务？</li><li>是否有其他途径 能更快地实现目标？ </li></ul><p>即使是自己对自己问这些问题，也能够很有作用</p><h3 id="批判性思考，提出关键因素"><a href="#批判性思考，提出关键因素" class="headerlink" title="批判性思考，提出关键因素"></a>批判性思考，提出关键因素</h3><blockquote><p>批判性思考是利用足够的认知，进行独立思考，并做出成熟决策的一种技能</p></blockquote><p>有时为了快速响应用户，我们可能会急于用一些快捷方案去解决用户问题。这样看起来会进展很快，但如果对结果和问题原因欠考虑，可能会引起后续出现问题的风险<br>与之相对，批判性思考就是带着强目的性去思考，发现问题的本质，规避风险<br>这种带着目的思考的方式，能帮助你更关注到问题的本质，规避那些 因为没仔细分析 根因和结果 而在未来会导致的问题</p><p>概括来说，以批判性角度，我会给自己提的问题有：</p><ul><li>我们是否在解决真正的问题？（问题是什么）</li><li>我们是否在用正确的方式解决问题？（可以从平衡严谨性和效率出发，比如时间不太够的时候，是否可以用更快的方式解决，一般适用于故障解决）</li><li>如果暂时找不到问题根源所在，如何找到定位根因的主要思路？（排除法是个不错的选择）</li><li>如何把核心问题拆解成一个个可以快速分析的问题？</li><li>如果我们有多种解决问题的假设，如何组织工作评估他们？</li><li>如果分析问题的时间有限，但是又不宜影响分析问题的严谨性，可以用什么捷径？（参考社区经验）</li><li>得到的结论，是否有充分的证据和现象能够支撑？（需要过程）</li><li>怎么知道把事情做完了？解决方案足够好吗？（适当回顾，确保不会有新的问题出现）</li><li>怎么把解决方案解释给故障影响方？（一般用于故障回顾，将故障具体原因、具体解决方式提炼出概括性的技术说明，保证对方能理解，并认可方案）</li></ul><p>这些问题经常能起到帮助作用。有时我们还会遇到这种情况：定位一个问题，结果从表象深入后发现了更多问题；采用一些可以快速解决问题的方案，但是在系统运行一段时间后，发现又因此产生了新的问题<br>通过进行一段时间的批判性思考，我们不断挑战假设，对收益和风险看得更细致，找到现象之间的矛盾点，评估（现象的）可信度，收集更多的数据，以确保我们现在做的是对的事</p><p>举个例子，很多程序员常犯的错误是，误将一个关联关系当成是因果关系（两个事情关联，但并不是说其中一件事发生，就一定会导致另一件事）。一个具备批判思维的人能将思路放回到假设中，并抛出问题：为什么我们会认定这个假设是对的？<br>这种（带批判性思考的）人还会做的事情有：</p><ul><li>提出更具体的问题（比如解析一个大需求：优化接口查询性能，可以拆解成，参数怎么优化，数据层过滤条件怎么优化等）</li><li>查询更多资料，寻找和问题之间的关联性（很适合初学者，资料总是不嫌多）</li><li>得到合理的结论和解决方式后，按照相关标准和规范进行测试（突出复现和测试）</li><li>通过不同的思维方式进行思考，对假设、影响和结果再次评估（形成适用于其他问题解决的方法论）</li><li>面对复杂问题，高效交流，找到最终解决方式（面对有复杂上下游的服务）</li></ul><p>扩展阅读: 批判性思考是通用技能吗？ <sup><font color='#49E844'>[5]</font></sup></p><h3 id="巩固基础知识"><a href="#巩固基础知识" class="headerlink" title="巩固基础知识"></a>巩固基础知识</h3><blockquote><p>牢固你的基础知识，并通过不断（在工作中）使用它们，来掌握新技能</p></blockquote><p>从长远角度来看，基础知识长期不变，学到了就能用很久，而且很通用，你在一个领域学到的基础知识在其他领域也用得上</p><p>短期来看，基础知识能让你面对问题时，提出更好的解决方案，并让自己的代码更加高效</p><h3 id="通用知识点"><a href="#通用知识点" class="headerlink" title="通用知识点"></a>通用知识点</h3><blockquote><p>通用知识是那些可以在不同项目之间都能使用的知识点。让我们从它们和基础知识之间的关系开始说起</p></blockquote><p>基础知识是贯穿整个软件工程师职业生涯的基础。它可以分为两层：宏观和微观。宏观层面是软件工程师的核心（<strong>基础知识</strong>），微观层面是实现（如：<strong>技术栈、库、框架</strong>等）</p><p>在宏观层面，你能够学到编程相关，高度抽象、和语言无关的概念。它们在各个领域的描述可能不同，但背后的核心思想都是一致的。包括：<strong>数据结构</strong>（数组、对象、模块、hash）、<strong>算法</strong>（排序、查询）、<strong>架构</strong>（设计模式、状态机）、<strong>性能调优</strong>（及早求值和惰性求值、内存、缓存、懒加载）等。这些概念你会在工作中经常用到，了解它们背后的原理将很有意义</p><p>在微观层面，你能够学到宏观概念的具体实现。包括：<strong>编程语言</strong>（JS、python、ruby）、<strong>前端框架</strong>（react、angular、vue）、<strong>后端框架</strong>（django、rails）和<strong>应用技术栈</strong>（谷歌 app engine、谷歌云平台）等。它们会涉及到很多能帮助你学到专业知识的细节，能让你变得高效， 但并不总是那么通用</p><blockquote><p>通过学习基础知识，你能够收获技能包和工具包，让你（在之后）可以忽略技术实现细节并成长</p></blockquote><p>务实地说，没有人可以在职业初期就学到所有东西。由此再延伸出一个观点：你不应该过多关注基础知识，反而应该学习在现实中搭建项目时需要用到的知识/技能。这也是“<strong>在实践中学习</strong>”理念的来源</p><p>译者：宏观知识帮助你了解技术原理，微观知识帮你把技术具体实现出来。不管是哪一种知识，都需要我们 learning by  doing 边做边学，都是需要过程的<br>不能太过神化宏观知识的重要性（比如各种面试八股文），它容易让你陷入底层，脱离工程<br>实际情况中，工程相关技能（即微观知识）更重要，毕竟这些才是能在当下帮你赚钱，帮公司赚钱的技能<br>​不管怎样，两种技术最终还是相互依存的。谁都很重要，谁也离不开谁</p><h3 id="效率"><a href="#效率" class="headerlink" title="效率"></a>效率</h3><p>理解服务的架构，能帮助你写出更高效的代码，这包括 <strong>时间复杂度</strong>（运行代码的时间）、<strong>内存使用率</strong>、以及<strong>性能和可维护性之间的平衡</strong><br>这些考虑点能让你在构建稳定的大型应用的时候，做出有用的权衡。另外对现代应用程序来说，<strong>速度</strong>非常关键，通常能特别显著地影响用户体验</p><h3 id="做出更好的选择"><a href="#做出更好的选择" class="headerlink" title="做出更好的选择"></a>做出更好的选择</h3><blockquote><p>对宏观和微观基本知识有更好的认识，能帮助你做出更优的决定</p></blockquote><p>基于项目的目标和约束，以及你所学的知识，你能够在选择<strong>应该用什么技术、不应该用什么技术</strong>这两个问题上做出更好的决策，避免在工作中因为选择了错误的技术方向或工具，导致陷入陷阱中</p><p>“You haven’t mastered a tool until you understand when it should not be used.” -<br>“<strong>你永远没有真正掌握一个工具，直到你知道什么时候不应该用它</strong>”<br>@kelseyhightower（谷歌云平台部门谷歌的首席工程师和首席员工倡导者）</p><p>软件工程师思考问题时需要考虑很多方面：<strong>核心语言、实现、架构、工具和人</strong>。只有在你带着<strong>敬畏之心</strong>，去认真学习这些方面的知识，才能让你更快成长。真正了解基础知识（包括 O(n) 时间复杂度（的算法））能帮助你走得更远，特别是在语言和框架（的具体实现）随着时间不断变化的背景下</p><p>扩展阅读:<br>The value of fundamentals in Software Engineering<sup><font color='#49E844'>[6]</font></sup></p><p>Why learning the fundamentals matters<sup><font color='#49E844'>[7]</font></sup></p><p>Learn the fundamentals of a good developer mindset in 15 minutes<sup><font color='#49E844'>[8]</font></sup></p><h3 id="专注于用户（需求），其他事情会跟着走"><a href="#专注于用户（需求），其他事情会跟着走" class="headerlink" title="专注于用户（需求），其他事情会跟着走"></a>专注于用户（需求），其他事情会跟着走</h3><blockquote><p>从用户体验开始，实现时回归你需要用到的技术</p></blockquote><p>乔布斯说过：”you’ve got to start with the customer experience and work backward to the technology. You can’t start with the technology then try to figure out where to sell it.”<br>“你需要从用户体验开始，再回归到技术中。你不能先基于（选择）技术，再尝试去找到哪里可以卖出你的产品”</p><p>这句话深深地触动了我：作为工程师，我们很容易就会有这种思维：先找方案，不管是社区流行的技术、其他开发者的经验，还是个人喜好，找到方案之后再去找哪里用得上<br>相反，我们其实更应该专注于我们所服务的对象、需要解决什么样的问题，以及当前的方案有什么不足之处<br>好的用户体验来自 <strong>用户和技术</strong> 两个角度的结合。和用户沟通，表达你的观点，你认为他们有什么需求，并认真分析他们说的需求。在用户需求实现上，会有很多细节能导致巨大差别，比如选择什么样的服务架构，能在用户手机端有比较好的体验；以及什么因素会影响工程开发、规模扩展、招聘等的效率？<br>总结来说，坚持不懈地关注用户需求，在工作条件限制下，<strong>坚持以实现用户需求为导向</strong>，能够让我们长期受益</p><blockquote><p>最优秀的软件，是由 带着用户同理心的工程师开发出来的</p></blockquote><p>软件能成功，取决于用户满意度，而满意度又体现在用户使用软件的体验上。我们需要了解<strong>最终用户侧</strong>的体验；确保我们的方案不会影响用户使用产品的同时，完成他们自己的工作<br>如果你有渠道可以和终端用户直接交流，就尝试去理解他们的需求和痛点吧</p><p>译者：理解用户需求并不简单，现实中总会遇到各种问题，译者经历过的主要有：</p><ul><li>和用户的沟通渠道不通畅<ul><li>大部分是平台问题导致的，比如产品首页缺少反馈按钮，用户想反馈问题只能靠投诉（想到了之前遇到的一个产品，想反馈一个bug，甚至要跳转另一个平台才能提，体验极差）</li></ul></li><li>用户需求和产品规划矛盾<ul><li>大部分用户需求都是站在短期实现的基础上的，和产品的长期规划不一定吻合。比如我想做一个笔记软件，长期来看，体验便捷 和 云端同步 可能是我首先考虑的功能点。对于 画图、共享这种功能，可能就不会排在很高优先级。但如果用户又站在强势地位，要求开发优先实现额外的需求，那开发就要受累了。后面可能就会能看到 产品、开发和测试 天天battle，需求赶着时间做出来，质量很差，转测的时候测试又提一堆bug，开发迫不得已边改bug 边开发，陷入恶性循环中</li></ul></li><li>用户也不清楚真实需求<ul><li>产品发展初期容易出现。用户对产品没有特别具体的认识，需要产品经理和用户进行更多的沟通，去发掘需求</li></ul></li></ul><h3 id="提升自己的能力"><a href="#提升自己的能力" class="headerlink" title="提升自己的能力"></a>提升自己的能力</h3><blockquote><p>选择适用于你的场景的技术，而不是当下流行的（flavor of the month）</p></blockquote><p>对比两种观点：使用“无聊”的技术（经过充分测试和体验的）也是ok的 VS  跟上潮流技术</p><p>语言、框架和库 都在经常发展。选择能帮助你顺利交付最终产品的就好。开始一个新项目时，建议从“无聊”的技术（<strong>但非常了解</strong>）开始，然后基于这个技术，有意选出最好的工具来帮你解决问题</p><p>即使是选择了新的技术来学习和使用，也不要害怕选择一些看上去无聊、不属于“社区”上主流的方向。FOMO<sup><font color='#49E844'>[9]</font></sup>（Fear of missing out 错失恐惧症）面对 语言、框架、库 和 工具这些技术的时候，可能就不是很有效了，因为更重要的事情是为了交付优秀的最终产品，你需要对自己所用的东西更加了解。请不要盲目为了追求新颖、漂亮的技术，除非你确定它们能为你的方案添砖加瓦。当然，也不要因为某个事情还没有被讨论充分，而忌讳提到它</p><h3 id="利用参与新项目的优势，学习新技术"><a href="#利用参与新项目的优势，学习新技术" class="headerlink" title="利用参与新项目的优势，学习新技术"></a>利用参与新项目的优势，学习新技术</h3><p>了解 <strong>个人开源项目和黑客项目</strong> 是学习新技术的好契机<br>对我们大部分人而言，基于现有项目是很难了解到新技术的，因为技术选型已经基本定型了<br>刚提到的两种项目，能让你以低风险、低成本方式研究新技术，了解新技术的优势和不足，以及了解可能在未来对你有用的一手知识</p><p>译者：另外，对初学者而言，还是要有对做什么项目的期望和思考，<strong>先有对项目的初步设想，再去找实现思路（如社区demo）</strong>。想法也不一定要很具体，有一个大体想法也可以，比如想做一个自定义规则的天气预报，想写一个小程序等<br>不是盲目找一个看起来很火的开源项目，随便搭起来就好了。因为并不是每个项目都适合你，越是花里胡哨的项目，越难应用于实际。<strong>带目的性的去找开源项目就是最好的甄别方法</strong><br>再提一点自己的感受：当有一个新技术摆在你面前时，<strong>学习它的最好时候永远是现在</strong>。错过了现在，你后面就可能花费更多的时间精力去重新捡起来</p><h3 id="保持好奇心，保持学习"><a href="#保持好奇心，保持学习" class="headerlink" title="保持好奇心，保持学习"></a>保持好奇心，保持学习</h3><h3 id="经常做笔记"><a href="#经常做笔记" class="headerlink" title="经常做笔记"></a>经常做笔记</h3><p>写下所学的东西，能帮助你更好的理解知识点。有的时候只有你尝试把自己所了解的知识讲给别人听，才能真正把你不懂的点弄清楚<br>如果你写的东西（博客）没人看，那也没关系。<strong>做笔记主要还是为了自己</strong>，（只是记下）你已经从中收获很多了</p><p><strong>学习还应该是一个持续坚持的事</strong> – 那些号称自己对特定领域无所不知的人通常都不是真正的专家。真正的专家精通一些技术，但他们能够意识到，总会有（继续）学习和改进的地方。<strong>好奇心驱动学习</strong> - 所以如果你对一个新框架感兴趣，那就去谷歌它、阅读它的文档、尝试新手教程、以及阅读源码！学习并不只是出现在教室中，<strong>学习可以在任何地方、任何时候发生</strong>。每天花半个小时阅读一本书的一小章节，听一次技术广播，阅读技术博客，学一门新的编程语言等</p><h3 id="Leader承认自己不知道的方面，将会很有感染力"><a href="#Leader承认自己不知道的方面，将会很有感染力" class="headerlink" title="Leader承认自己不知道的方面，将会很有感染力"></a>Leader承认自己不知道的方面，将会很有感染力</h3><p>Leader 需要降低期望：<strong>即使是高级工程师，也没有了解方方面面的必要</strong>。承认自己对一些细节不了解的同时，并致力于找到 和 团队一起解决问题的方法（即合作），这个比了解技术细节更重要</p><h3 id="Leader-也需要承认自己犯的错误"><a href="#Leader-也需要承认自己犯的错误" class="headerlink" title="Leader 也需要承认自己犯的错误"></a>Leader 也需要承认自己犯的错误</h3><p>教导下属 用虚心的态度承认和解决错误，愿意从错误中学习和提升自己，是很重要的。告诉下属现实世界并不完美，我们需要对可能发生的错误做好准备</p><p>译者： 理想状况下，我们提供的服务还是应该具备<strong>高可用、故障后可快速恢复</strong>的能力。这样就算是一个刚接手服务的同事，也能有快速上手的<strong>自信</strong>。遇到问题也能冷静处理<br>当然，不得不说，基础设施、服务维护工具和服务架构设计等，也是达到这种理想程度的基本条件。做到如上所述完全理想的情况不是不可能，只是确实有难度<br>如果你所维护的服务正好没有做到上面几点，那就根本别指望不会出问题，更别指望能不被用户投诉、领导责备了。不过这个时候，也只能想办法去<strong>尽量改变现状。每次犯错都去责备团队或者责备自己，对现状不会有任何改进</strong></p><h3 id="做开源项目的caretaker（管理者），而不是owner（所有人）"><a href="#做开源项目的caretaker（管理者），而不是owner（所有人）" class="headerlink" title="做开源项目的caretaker（管理者），而不是owner（所有人）"></a>做开源项目的caretaker（管理者），而不是owner（所有人）</h3><p>在项目发展的初期，以 owner 的角度去思考是没问题的。你会经常去思考项目的价值，开发新特性和回复 issue。对为项目争取社区支持、赞助是好事，但随着项目人员的变化，以及个人时间受限，这种模式对项目的发展就不是最好的了</p><p>经过初期的项目规模收缩之后，另一种参与项目的方式是成为项目的<strong>管理人</strong>，而不是<strong>所有人</strong>。管理人的角色更专注于扩大自身的影响力。比如和其他项目所有人、贡献者和社区之间 分享知识（通过文档、代码注释、最佳实践文档化等）。这对扩大项目的 reviewer 规模同样有用，有助于后续不再参与项目的时候，项目也能朝着正确方向发展</p><h3 id="技术的广度和宽度"><a href="#技术的广度和宽度" class="headerlink" title="技术的广度和宽度"></a>技术的广度和宽度</h3><blockquote><p>考虑成为一个全才和某一领域的大师，哪一个更适合你？</p></blockquote><p>你应该掌握的一个很重要的技能，就是掌握 如何学习 的方法。这比你怎么说更重要，（你需要做的）只是深入到编程语言或者框架的底层。另外这也有助于保持好奇心。一旦你经历了这种学习方式，你可能就会提出刚刚说的问题：是追求成为某个领域的专才，还是全栈的多面手（a jack of all trades）<br>我个人更喜欢成为 <strong>T型工程师</strong><sup><font color='#49E844'>[10]</font></sup>（T-Shaped Team Members） 的想法。这种工程师会在一个或少数几个领域有深入研究（<strong>T 的纵向深度</strong>），但对构建和运行大型项目需要的多个领域的技术，也有基本的认识（<strong>横向宽度</strong>）。有的团队会愿意将团队成员定期相互交换，来培养这种 T型工程师<br>我已经发现在中-大型团队中，如果有那种在某一领域专长的人员，能够很有效地补充其他人的技能、全面性和合作能力</p><p>译者：<strong>初学者还是建议以技术宽度为主</strong>。宽度能帮助你快速定位和解决问题（<strong>打开思路、用好工具</strong>），然后能更专注于研究深度。因此确实不要放过任何一个能学到新东西的机会<br>而最理想的状态，就是在对大的领域，比如后台，所有热门技术栈都有实践性的认识，同时对1-2个领域有非常深的实战经验</p><h3 id="从实践中学习"><a href="#从实践中学习" class="headerlink" title="从实践中学习"></a>从实践中学习</h3><p>学习一门新语言的时候，需要专注于构建有形的结果，能让你有更深刻的一手体验<br>不一定要完整阅读新语言的官方文档，记住所有的特性、关键词。<strong>了解这门语言如何解决问题</strong>更重要。从demo项目中，或者亲手写代码来获得经验。正如《Why Bad Software Happens to Good People》<sup><font color='#49E844'>[11]</font></sup>这里所说，“软件的主要价值并不是产生的代码，而是创造这个语言的人传递的知识本身”<br>也要注意：不要在生产环境进行新技术的试验</p><h2 id="技术复杂度"><a href="#技术复杂度" class="headerlink" title="技术复杂度"></a>技术复杂度</h2><h3 id="通用代码-vs-专用代码"><a href="#通用代码-vs-专用代码" class="headerlink" title="通用代码 vs 专用代码"></a>通用代码 vs 专用代码</h3><blockquote><p>解决手头问题的时候写专用代码，但也尝试能让代码变得更通用的地方</p></blockquote><p>当我们为了解决一个问题的时候，往往会因为紧急程度、升级复杂程度等，写出一些比较不那么通用，只是为了快速解决问题的“专用”代码。<br>通常，我们会先尝试写出尽可能通用的代码，最后写出那些看似高效的代码，但并不能解决问题。实际上，（应该）<strong>先是为了解决问题写代码，再去找到可以让代码变得更通用的地方</strong>，这样能在更迅速地解决问题的同时，减少后续再回顾和重构的时间（译者：解决手头问题的时候，短期效率还是排在第一位的）</p><p>关于设计复杂度上，有一些通用的原则：<br>YAGNI（You aren’t gonna need it）<sup><font color='#49E844'>[12]</font></sup>、Do the simplest thing that could possibly work<sup><font color='#49E844'>[13]</font></sup><br>这两点说的其实是一个事：<strong>不要过度设计</strong><sup><font color='#49E844'>[14]</font></sup>（overengineering）。尽量通过最简单的设计完成工作，让后续的需求通过快速迭代实现，而不是一开始就把所有特性都规划好。不过滥用这两个原则，也容易导致设计出过于抽象和简单的方案，后续不能很好地实现和集成</p><p>另一方面，你还会经常听到<strong>抽象原则</strong><sup><font color='#49E844'>[15]</font></sup>，旨在通过抽象和通用化思想，减少重复代码。我更喜欢在极端抽象和极端简单中找到平衡点，AHA<sup><font color='#49E844'>[16]</font></sup>（Avoid Hasty Abstractions）（避免过度抽象） 体现了这种思想</p><h3 id="Deep-Module-模块化-思想"><a href="#Deep-Module-模块化-思想" class="headerlink" title="Deep Module (模块化) 思想"></a>Deep Module (模块化) 思想</h3><blockquote><p>解决复杂问题，并通过开放清晰的接口给其他开发者使用</p></blockquote><p>如果你是一个API 的设计者或者开发者，你的职责就是提供能简化功能的接口。如果接口过于难懂，让其他程序员调用需要花费过多成本，那这个接口就是不合格的。这个理念同样能在 <strong>Deep Module</strong><sup><font color='#49E844'>[17]</font></sup> 的思想中体现：“最好的模块能够同时提供最好的效果和最低的成本。效果就是它的功能，成本就是它的接口”</p><p>尽管让接口变得简单是可行的，但代码不一定，复杂问题有时就是需要复杂的代码来实现（这是一个通用规则，但不一定总是正确）。复杂度最好是内嵌到代码中。复杂的功能抽象程度越高，作为接口提供给最终用户的价值就越高<br>API 使用越多的函数和类，就越难被搜索到。随着函数和类的新增，将会增加 程序员的维护和接口使用的成本</p><p>译者：接口设计规范也是老生常谈的规范了，这里简单提一下</p><ul><li>接口的入参不应超过3个<ul><li>接口入参 其实就能体现给用户调用这个接口的成本。参数越多，也意味着这个接口越复杂，甚至不是复杂在功能，而是理解成本</li></ul></li><li>用更少的类实现接口<ul><li>这里就涉及到模块架构的设计了，比如一个 http 接口，最普遍的分层方式就是 api 层 + controller + service + 数据层</li></ul></li><li>接口名称</li><li>接口返回值</li></ul><h3 id="学会管理项目"><a href="#学会管理项目" class="headerlink" title="学会管理项目"></a>学会管理项目</h3><blockquote><p>处理旧系统的代码时，应该理解需要保留的代码，和需要废弃的代码之间的区别</p></blockquote><p>大型、年久失修的项目往往会有一些不好的、没有好的理由再保留下去的代码。应该去深入了解这些代码，分析留下的理由、去除的理由。去除坏代码，留下好代码</p><p>我曾经在很多公司中遇到过这种情况：<strong>同事们认为旧的代码是不可动的</strong>，或者是出于一个好的理由设计的，导致这些代码流失于历史之中（译者：即没人敢动，也没人能动的状态）。这会产生对修改旧系统代码的畏惧感，只能在一个脆弱的基础上继续添加功能</p><p>软件行业已经发展到了一个阶段：<strong>很多团队都需要维护或者迁移 旧系统</strong>。当你发现自己就在这样的团队的时候，不要灰心，你可以从这些旧代码中学到很多特定领域的知识。尽管旧的代码在生产环境中继续保留 会有充分的理由，你还是可以怀疑不是每一行都有存在的价值</p><p>有的软件开发者会对修改在线上环境运行的代码很谨慎，担心会导致bug。所以他们会根据现有的系统的代码，通过重复代码来添加新功能（译者：比较典型的情况就是修改接口，对旧系统存在 bug 的接口不敢改，而是添加一个新的接口，但这个接口绝大部分代码都和旧接口一样）这种解决方式在当时会很省时，但随着时间推移，维护就会变成噩梦了。不要假设现有的代码都是可靠的，它们在可扩展性和效率上可能会有问题，你可以去尝试发现这些问题</p><h3 id="从新项目（green-field）中学习"><a href="#从新项目（green-field）中学习" class="headerlink" title="从新项目（green-field）中学习"></a>从新项目（green-field）中学习</h3><blockquote><p>实验、创新、快速失败和更好地解决问题</p></blockquote><p>当你的任务是从头开始搭建一个系统的时候，你的学习之旅就将很不同。在迭代制作原型、实现特性的时候，你将能学到什么能起到作用，什么不能<br><strong>敏捷方法论</strong> 和 <strong>快速失败</strong> <sup><font color='#49E844'>[18]</font></sup>（fail-fast）的原则，将帮助你通过很少的资源就能确认你的想法是否正确。它们能帮助你拆解并解决复杂问题</p><p>译者：敏捷开发这块，现在已经有很多开源的工具，可以帮助我们在本地实践。简单列几个：</p><ul><li>代码仓库：gitlab（需要使用体验）</li><li>发布：jenkins</li><li>镜像仓库：harbor</li><li>服务管理：k8s、istio、etcd等</li></ul><h3 id="定义完成事项"><a href="#定义完成事项" class="headerlink" title="定义完成事项"></a>定义完成事项</h3><blockquote><p>定义什么算是“完成”事项能节省时间，因为它能帮你评估所需要的工作、制定开发计划、并避免不必要的调整</p></blockquote><p>在解决复杂问题时，有效的敏捷原则是对 “完成”事项（The Definition of Done<sup><font color='#49E844'>[19]</font></sup>） 达成一致。除了用户需求列表和验收标准外，还包括代码审视（code-review）、测试、文档化等</p><p>译者：这里体现一种“<strong>闭环</strong>”思维：在手头事情很多，需要来回切换的时候，事情做得稍有疏忽很正常。因此需要特别注意 “完成” 事项的明确<br>比如刚给用户改完一个bug，在用户群回复用户、知会受影响方、提交fix代码，都是需要“闭环”的事情。可以先稍微花点时间先把它们写下来，避免忘记</p><h3 id="分阶段发布"><a href="#分阶段发布" class="headerlink" title="分阶段发布"></a>分阶段发布</h3><blockquote><p>单个大的版本可以拆解成一系列低风险、容易理解的小版本来发布</p></blockquote><p>在大型生产环境系统 进行 版本发布的时候，版本发布计划的重要性不亚于 架构、代码实现等。通过迭代开发、分阶段发布版本，能帮你更好地管控因重大更改而导致的风险。你还可以制定版本发布策略，包括开发、测试策略，来保证在发布复杂特性的时候，有（完整的）端到端计划</p><h3 id="系统性调试"><a href="#系统性调试" class="headerlink" title="系统性调试"></a>系统性调试</h3><blockquote><p>当你在 debug 的时候，你应该系统地、严谨地解决问题，确保覆盖到了所有的测试条件</p></blockquote><p><strong>总是阅读错误和堆栈信息</strong>。那里大概率会有关键信息，能帮你定位和解决问题<br>惊人的是，很多工程师在调试之前，都会忽略错误信息能提供的线索。我们应该假设 机器/软件能告诉你发生了什么问题，而不是假定 稍微做点修改、重启服务就能解决问题。如果你还没有仔细阅读程序抛出的异常，就开始写解决方案，你可能会浪费时间。大部分情况下，异常信息中就包含了真正错误的提示</p><h2 id="文档"><a href="#文档" class="headerlink" title="文档"></a>文档</h2><h3 id="设计文档的重要性"><a href="#设计文档的重要性" class="headerlink" title="设计文档的重要性"></a>设计文档的重要性</h3><blockquote><p>设计文档不应该放在后面来考虑，而应该是软件开发过程的一部分</p></blockquote><p>设计文档能帮助你和 <strong>同事</strong> 或者 <strong>其他需要和你的系统进行交互的团队</strong> 之间获得共识，是一个无处不在的工具。从他人获得的反馈，又可以让你认识到差距，并改进你的设计。设计文档还可以为后续加入团队的工程师提供宝贵的帮助，可以帮助他们理解问题，在设计解决方案的时候考虑到权衡点、替代方案等。设计文档也提供了一个团队空间，能够记录所有设计的参与者，以及它们的贡献，作为历史文档的一部分，以方便他人找到具体解决方案的贡献者，以及方案具体解释的负责人</p><p>译者：一个成熟的项目，团队空间中包括的文档应该包括而且不限于：</p><ul><li>项目 milestone</li><li>公司权限申请帮助文档</li><li>服务设计文档</li><li>服务环境、部署文档</li><li>内部服务和第三方服务的接口人</li></ul><h3 id="文档审查"><a href="#文档审查" class="headerlink" title="文档审查"></a>文档审查</h3><blockquote><p>协同检视设计文档，比较当前文档和历史文档，确保所有依赖项都被记录了</p></blockquote><p>尽管每个人都可以在文档中记录设计思路，但实际的设计过程通常出现在白板会议、随机面对面讨论、空闲时间段 或者 邮件/手机讨论（这种<strong>随时发生的场合</strong>）中。在这之后，只有通过文档把设计记录下来，你才能确认 结论之间的矛盾点，并确认（现在讨论的结论和）之前讨论过的点是否吻合。初稿完成后，需要进行审视，确保所有相关人员都参与进来。另外，随着项目发展，还是可能存在代码实现 和 文档中记录的设计思路 变得不吻合的情况（因此文档需要定期审查和更新）</p><h2 id="沟通"><a href="#沟通" class="headerlink" title="沟通"></a>沟通</h2><blockquote><p>谦虚、清晰沟通、并尊重他人。保持亲切 本身不计成本，它产生的影响却是无价的。有的人会认为 沟通需要消耗能量和思考。正是因为如此，我们需要以更多的能量和热情来和他人沟通</p></blockquote><p>沟通是一个非常关键的通用能力和社交能力。成为一位有用、高产、和高效（effective, productive, and efficient）的软件开发者也离不开（和他人）沟通。沟通不通畅会导致（开发出）不正确的功能、不兼容的代码、冲动的团队氛围等。沟通能帮助开发者更好地理解需求，避免问题继续升级<br>理想情况下，<strong>软件开发者是把（大部分）时间花在编写代码上的</strong>。但是为了保证我们的产品真正对用户有用，我们还需要和团队成员同步工作（进度）、业务需求和用户期望。这让协作和沟通成为我们工作很重要的一部分<br>初级工程师主要的沟通对象是 其他团队成员、测试工程师和项目leader，分享想法和解决问题的方案。随着我们职业发展，为了有效完成工作，需要的沟通量将会越来越多。邮件、会议和公开演讲也会变多。我们必须和 <strong>业务leader、项目经理、利益相关人员</strong>沟通。然而沟通越多，产生误解的风险也会越大，因为不是每个人都能轻松理解你的表达方式</p><h3 id="定义你的沟通方式"><a href="#定义你的沟通方式" class="headerlink" title="定义你的沟通方式"></a>定义你的沟通方式</h3><blockquote><p>和沟通对象 确定好 语言、概念 和 沟通细则的相关性</p></blockquote><p>不管我们对问题或者情况有多么理解，和别人沟通的时候，我们还是应该设计好沟通关键词，保证沟通对象能够快速get到 和自己相关的内容：</p><ul><li>和业务人员沟通的时候，谈论你所做的事情在业务层面的影响。避免使用过多的技术术语</li><li>和工程管理人员沟通的时候，说明技术影响和挑战</li><li>和决策者沟通的时候，描述你期望的可行方案，以及这些方案的影响和风险，不要谈到方案实现的细节</li><li>提供状态更新的时候，需要特别关注随着更新可能导致的周边影响，以及你的更新和目标之间的关联度</li></ul><p>这些原则 同样适用于写邮件和举行大型分享。你需要写下和沟通对象相关的事项。在分享的时候，还需要保卫你的观点，以深思熟虑的态度回复问题，膝跳反应（knee jeck）的回答方式通常不适用于沟通</p><h3 id="耐心、深思熟虑"><a href="#耐心、深思熟虑" class="headerlink" title="耐心、深思熟虑"></a>耐心、深思熟虑</h3><blockquote><p>亲切是一种超能力，尝试用好它</p></blockquote><p>成为冷静、亲切和乐于助人的人，能让你走得更远，而不是切断自己和其他人的联系。善于帮助团队内的同事，能帮助你的团队变得更强大和更成功。对团队外的成员也保持友善，对公司的职能部门同事（<strong>hr、财务、市场</strong>）也给予同样的尊重，（在工作上）你可能不会直接帮助到他们，但你可以理解他们的工作，对他们拥有同理心。当他们在工作上有所成就，或者获得赞誉的时候，也同样送上你的祝贺和赞赏。善良是能传递下去的，那些你曾经善待的同事，在未来可能也会积极回应你的需求</p><blockquote><p>不要吝啬（be liberal）称赞他人</p></blockquote><p>产品需要改进的时候，（问题的）反馈很重要。产品体验很优秀的时候，正面的反馈同样很重要。这能帮助你的团队（成员）明白 正在做的事情是能带来改变，并且是有价值的</p><h3 id="学会说“不”"><a href="#学会说“不”" class="headerlink" title="学会说“不”"></a>学会说“不”</h3><blockquote><p>说“不”比工作过度要更好</p></blockquote><p>很多时候在工作逐渐累积的时候，我们都不是很擅长说“不”。要么是因为没有意识到<strong>说“不”其实是一种选项</strong>，要么是我们沉迷于挑战之中。但是过度工作是一种负担，它可能会导致交付延迟。让其他人也知道你正在进行的计划，以及一个合理的时间预估，也是一种尊重的态度。因为这能够让其他人调整他们的选项：向其他人寻求帮助，或者推迟时间表。如果 leader 能了解到（过度工作）会明显影响产品交付质量，他们也不会强行要求你在很紧的时间内完成工作。如果你是高级经理，请让你的团队成员有权利对坏主意说“不”<br>高级工程师是很擅长于说“不”的。人们会试图占用你的空闲时间。你可以平静而又坚定地说不，将他们指向其他思路，或者让他们找你主管，确认你到底是否可以将更多的时间，花在帮助他们身上（而不是手头的事情）” - 观点来源<sup><font color='#49E844'>[20]</font></sup></p><blockquote><p>你不可能让所有人感到满意：不管是说 “yes”还是 “no”都要格外小心</p></blockquote><p>领导对一切事情说“no” 的对应面，就是对一切事情说“yes”，并且两者没有明显的边界。承担超过 利用现有的资源（人力、时间等）能承受的工作范围，可能最终会导致你自己、你的团队和客户都受伤。<strong>向下属制定 什么时候应该说 “yes”，什么时候应该直接拒绝 的规范，对 leader 来说是特别重要的</strong></p><h3 id="接受与尊重"><a href="#接受与尊重" class="headerlink" title="接受与尊重"></a>接受与尊重</h3><blockquote><p>敢于承认你不了解的东西。开放地接受别人寻求帮助的请求，包括初级工程师（的提问）</p></blockquote><p>承认你不知道的事情，是很ok的。对软件工程师来说，最重要的技能之一就是找到问题的答案，并从中学到东西<br>作为一名 高级leader，需要学会接受 身边的下属 可能比你更了解工程的技术细节。承认你不了解一些细节是 ok 的，让下属负责解释他们。下属会因为你的诚实，以及对学习的兴趣，对你更加尊重，你也会对当前团队正在做的事情有更清晰的画面，并在这些事情上增添更多的价值。作为初级工程师，你应该向更高一级工程师把技术概念和方案细节解释清楚，可以是开放式（交流会），也可以是在会议室，取决于你觉得哪种方式比较舒适</p><h3 id="信息分享"><a href="#信息分享" class="headerlink" title="信息分享"></a>信息分享</h3><blockquote><p>通过会议 或者 问答 的形式，提出合适的问题，交换所学，并在团队中分享</p></blockquote><p>举行会议的时候，不要只是一个人在说。会议是一个很好的 分享想法、提供真实反馈的机会，除了表达自己，也应该给别人一些空间去发言，并认真倾听<br>初级工程师可能会羞于提出过多的问题。如果你是高级工程师，你可以通过提出（需求）上下文，来提示他们提出正确的问题。筛选问题之后，也要让提出问题的同学知道，你对（真实）问题的抛出感到高兴</p><h3 id="灵活性"><a href="#灵活性" class="headerlink" title="灵活性"></a>灵活性</h3><blockquote><p>捍卫你的观点，但是发现新的观点，和自己的观点对立的时候，也要懂得审视它们</p></blockquote><p>审视其他观点，也是交流的重要过程之一。有不同于自己的观点是很正常的，因为一个问题的解决方法本来就可能不止一种。与其固执于自己的观点，不如去倾听、审视其他观点。说不定这些不一样的想法，还能让你的观点在之前忽略的方向更进一步。Paul Saffo（斯坦福大学工程学院的咨询教授） 的原则 “<strong>Strong opinions weakly held</strong><sup><font color='#49E844'>[21]</font></sup>” 告诉我们要捍卫自己的观点，同时也要在发现新的对立现象之后，及时更新观点。这是一种科学、通用的方法论，不管提出观点的人是谁</p><h3 id="保持记录"><a href="#保持记录" class="headerlink" title="保持记录"></a>保持记录</h3><blockquote><p>非正式会议之后的一封邮件，有助于我们确认讨论的关键点和关键进展</p></blockquote><p>完全口头的交流有一个缺点，就是会后 （讨论过的事情）很容易忘记，或者是记错。保持会议过程所发生事情的记录，以及所有讨论点的总结，能降低这种风险。如果你和另一个同事已经确定要参与一项任务，你需要通过邮件将 ddl 知会到所有相关人，包括你的导师。在事项的（排期）评估讨论过程中，对尚未具体排期的计划进行记录也会很有用</p><h3 id="真诚"><a href="#真诚" class="headerlink" title="真诚"></a>真诚</h3><blockquote><p>了解在什么时候应该保持冷静，观察正在发生的事情</p></blockquote><p>有的时候，你对团队讨论做出的一些决定 会不太理解，或者是这些决定无论从技术还是业务角度看都不合理。这在跨团队讨论过程中可能会出现。（尽量）表现出你的真诚，并假定人们不会冒着 带有恶意 的风险。可能你只是对整体背景还没有完全的认识，或者是参与讨论的人们有各自的优先级考虑。你需要提出你的疑惑，列出你的观点，而不是对最终决定直接表示愤怒和消极</p><p>译者：“沟通”这一章节所说能否应用到现实，建立在团队有开放的交流氛围、leader和其他成员乐于听取你的想法的基础上。当然，现实情况并不总是那么理想，但不管怎样，<strong>保持冷静，少冲动做事</strong>是总没错的</p><h2 id="资历"><a href="#资历" class="headerlink" title="资历"></a>资历</h2><p>我们期望不断提高自己的资历，不管是从角色还是能力方面。有的人会对高级工程师职位感兴趣，有的人会更愿意往团队leader或者部门管理方向发展。不管是哪种选择，在我们职业发展的过程中，总会有一些关键特征，是会慢慢展示出来的。在你的成长过程中，你可能会由你的导师来带领你，下面是我的一些方法，可以帮助你在走上高级职位之前，准备好必要的素质</p><h3 id="资历和战略思维"><a href="#资历和战略思维" class="headerlink" title="资历和战略思维"></a>资历和战略思维</h3><blockquote><p>不要害怕做决定，或者表现得很不确定</p></blockquote><p>大部分时候你会发现，<strong>做决定的结果比不做决定要好很多</strong>。至少你的决定能让别人知道，你在朝哪个方向前进。作为leader，我们往往没有花足够的时间审视 整个团队到底期望我们做什么样的决定。即便如此，我们也不会这么去审视，因为我们不可能掌握 100% 的事实。我们确实应该在做决定前，尝试描述所有的依据和细节，但不可能做到面面俱到（特别是时间紧张的情况下）。（过度注意细节）这可能导致团队 长时间陷入 停滞、不确定的状态。通过有限的信息，在有限的时间作出的决定，效果反而会更好（译者：感到没事做是最不好的状态，对个人和对团队来说都是如此）</p><blockquote><p>leader 负责补充自己的知识库，来让自己全方位、战略性地思考，并为他人制定前进路线图</p></blockquote><p>随着经验成长，你的战略性规划、将想法应用于更多领域 的能力，也应该提升。从独立开发者角度出发，你可能会专注于你所负责的任务，还有需要实现的功能。但随着你的进步，你的影响力就不仅体现在工作任务和负责项目上了。在权衡选择时，你将学会根据选择带来的 效益和限制 两个角度，去思考更多的东西（即权衡利弊）。举个例子，在早期 你只是为了自己的团队，指引组内其他同事 去做决定，随着你的成长，你的选择和交流将会影响到多个团队</p><h3 id="以身作则"><a href="#以身作则" class="headerlink" title="以身作则"></a>以身作则</h3><blockquote><p>向团队传授学习方法。不要只是为了解决手头问题而去行动，耐心地指引他们 去锻炼一些能力，并让这些能力为自己服务</p></blockquote><p>工程师行业的领导善于<strong>授权</strong>。随着你的职位越来越高，尝试下放原来属于你的工具、权限、责任等，让团队成员自己去用这些资源并取得成功，（对下属）会很有帮助。这也是你继续提升效率的方法。还可以通过 提出好问题 来提升，而不只是回答问题</p><blockquote><p>在别人提供解决方案的时候，以身作则地 负责具有挑战性的任务，并提出（过程中遇到的）相关问题</p></blockquote><p>技术领域的高工 需要负责 团队内和团队外的协作、沟通和共识建立。<strong>他们致力于提高团队的整体产出，而不仅是自己的</strong>。作为高级工程师，你可能偶尔是为了学习新技术，或者是了解行业现状 去写代码，但这种事情并不会被写在工作内容中（需要自觉去做）。现实中，你还需要自觉去审视代码，确保架构图中没有疏漏。你还应该为自己的决定 如何带来技术或者商业价值 收集好依据和原因<br>高级工程师还应该熟练管理软件系统和团队。你可以领导一个多元化的工程师团队，分配给他们 注重代码质量、性能、复杂度 的任务，及时给予反馈和指导。同时，<strong>你还应该适当展示你的能力、工作和技能</strong>，让自己未来有能力解决具有挑战性的问题，在团队甚至公司获得知名度。总而言之，你应该培养和团队内同事、公司内领导层的关系</p><h3 id="提升你的影响力"><a href="#提升你的影响力" class="headerlink" title="提升你的影响力"></a>提升你的影响力</h3><blockquote><p>伟大的软件项目通常是由团队创造的，而不是个人。所以 如果你想实现更多的目标，或者在公司展示 你已经为成为 高级工程师 做好准备了，你需要通过合作和指导力来展现自己。提升影响力，不仅仅是为了自己，也为了团队的其他同事</p></blockquote><p>当我意识到需要扩展自己（的能力）的时候，就是我在google公司内向着成为高级工程师的时候。<strong>我必须在考虑 “我”和 “我们”的模式之间切换</strong>。通过和其他人协作、分享所学、专注于提升身边同事的经验和技术，我们深刻意识到做了更多有价值的事情</p><p>如果你是从独立开发者开始，你可能不会专门领导一个团队，但<strong>你可以寻求更多志同道合的小伙伴来和你共事</strong>，实现一个人难以实现的项目。随着你的技能、职位越来越高，你会通过建立团队，进一步提升工作效率，来继续贯彻这种（合作）思维</p><h3 id="“不能胜任”综合症（Imposter-syndrome-22-）"><a href="#“不能胜任”综合症（Imposter-syndrome-22-）" class="headerlink" title="“不能胜任”综合症（Imposter syndrome[22]）"></a>“不能胜任”综合症（Imposter syndrome<sup><font color='#49E844'>[22]</font></sup>）</h3><blockquote><p>尝试接受 犯错误、难以找到答案、需要寻找指导 的工作过程，可以帮你克服“我不能胜任”这种心理负担</p></blockquote><p>我们在工作中几乎都遇到过，对特定的工作或者是角色，（一开始）会感到自己并不能胜任。这种心理是非常普遍和真实的，甚至在一些已经获得明显成就的人身上也会出现。即便是别人会找自己咨询意见，你依然可能会觉得自己不适合。甚至你永远也不会放下这种内心负担，但它确实能激发你的好奇心，推动你去学习新东西</p><h2 id="指导"><a href="#指导" class="headerlink" title="指导"></a>指导</h2><h3 id="指导他人"><a href="#指导他人" class="headerlink" title="指导他人"></a>指导他人</h3><blockquote><p>及时提供信息和指导建议，让你的学员不至于陷入完全不正确的方向，而是通过做好自己的事情来掌握技能</p></blockquote><p>在你职业生涯的发展过程中，你可能会发现自己时而是导师，时而是学员。作为导师指导别人，不一定非要很正式的过程。非正式（日常工作）情况下，你也可以寻求指导别人或者获得别人的指导的机会。指导别人可以锻炼自己的人际交往能力。下面是一些指导的关键点：</p><p><strong>指导别人是引导别人去发现答案，而不是直接给他们最终答案</strong>。允许你的学员在解决问题的时候多尝试，多实验，因为他们有直接感受解决方法的风险和收益的最佳机会。不过，你也应该及时把解决问题用得到的工具（比如方法论）告知给他们，如果是一个技术问题，也可以参与讨论，提出你所建议的想法和方案，具体实施还是交给他们。让学员也分享所想，提出问题，进行对话讨论</p><p>如果你的学员发现自己很难找到问题的解决方法，你可以分享你会怎么去分析问题，接近答案，以及为什么你会用一个特定的模式来解决问题。教会他们分析问题和debug的方法，分享你在 诊断问题、提出解决方案、实现解决方案 和 debug 时候的思路。<strong>分享如何解决问题的技巧</strong>，而不仅仅是答案</p><h3 id="组织层面的指导"><a href="#组织层面的指导" class="headerlink" title="组织层面的指导"></a>组织层面的指导</h3><blockquote><p>指导别人是作为高级工程师的职责之一，有助于在组内成员变化之后，依然能保留关键领域的知识</p></blockquote><p>假设你在很投入地指导别人，而且也是你日常工作的一部分。这种情况下，你就需要安排一部分工作时间，专门用在指导活动上。这能让你指导的效果更好，在指导生涯中做出更有意义的事。有的公司还会根据职责发展阶段和要求，在员工发展的每一阶段都会对 导师/学员机制 有一定的流程规范</p><h3 id="学员的职责"><a href="#学员的职责" class="headerlink" title="学员的职责"></a>学员的职责</h3><blockquote><p>导师可以给你建议，但真正评估和实施方案的还是你自己，你需要对自己的职业生涯发展和成长做好规划</p></blockquote><p>假设你是期望在团队内成长起来的初级工程师，我只有一条建议给你：找到那些能帮你规划职业发展的优秀导师<br>你会在职业生涯中，遇到仰慕的教练、导师和同事。他们会给你如何培养技能的建议，但真正实践还是得靠自己。吸收别人的建议时，也要注意技术层面的条件，不同场景，有效的法则也会不同。在一个项目有效的理论，换个项目就不一定适用了（<strong>具体情况具体分析</strong>）</p><h2 id="高效的团队"><a href="#高效的团队" class="headerlink" title="高效的团队"></a>高效的团队</h2><h3 id="构建信任"><a href="#构建信任" class="headerlink" title="构建信任"></a>构建信任</h3><blockquote><p>信任可以将团队人员拧成一股绳，朝着共同的目标努力工作。相反，官僚主义会让彼此产生隔阂</p></blockquote><p>当工程师一起参加一个<strong>开放、公正</strong>的头脑风暴会的时候，（这种形式）为能够驱动创新 的新的想法和不同思维角度（的提出）铺平了道路。（这种开放的氛围）确实能驱动团队变得高效和高产出。不过团队内成员能高效合作的基础，还是健康的沟通和关系。下面是一些构建和管理高效团队的关键点：</p><p>构建起信任，是团队构建中最重要的事项。跨越不同级别的同事之间的信任，对工作事项能快速完成、团队能高效运作很必要的。团队成员可能会使用不同的开发工具，比如为了检查工程质量而使用的代码检视工具，或者是测试工具。然而如果没有信任作为基础，这些（开发）过程都会变得乏味和官僚主义。举个例子，如果你信任一个工程师和他的代码，那么在进行代码检视的时候，就会更少地吹毛求疵</p><p>译者：确实有的公司盲目追求编程规范，搞了各种可信认证，已经让编程完全变了味。译者认为，可信的目的并不是让大家都变成“一样”的人，写完全相同风格的代码，用同样的工具，甚至用同样的开发语言。如果是这样不如开发一个机器人来写代码，而是相信他的代码上线之后能稳定运行、代码风格比较规范、代码具有可扩展性等</p><p>真正开放、有彼此促进的开发氛围，是需要靠实际的团队合作培养出来的，比如分享、代码检视会等，而不只是各种枯燥的考试和认证</p><h3 id="理解业务模型"><a href="#理解业务模型" class="headerlink" title="理解业务模型"></a>理解业务模型</h3><blockquote><p>理解变更会对业务侧带来的影响</p></blockquote><p>当你（从业务侧）接到一批需求时，你需要了解它们背后的动机。一定不要跳过需求文档中的“<strong>目的（或背景）</strong>”和“<strong>业务目标</strong>”章节。你还可以通过（向产品经理或用户）提问来了解业务模型，以及它和需求之间的关系。通过（检视）现有的代码，或者是一次和SME（subject-matter-experts 行业专家）之间的交流，可以让你对领域和架构有更深入的视角。在进行系统流程和数据工作流（data flow）的时候，请参考业务文档、特性地图 以及 使用示例等</p><p>“大部分软件工程师都喜欢带着技术上的挑战去解决问题。然而当你理解业务的角度（去思考）时，你会收获更多，比如成本更低的解决方案。要记住你的用户/客户 使用你的产品，也是为了去完成他们自己的工作，就像你完成每天的工作方式一样。尽量不要让他们的工作比使用你的产品之前还要困难” - 来源<sup><font color='#49E844'>[23]</font></sup></p><h3 id="提升你的影响力-1"><a href="#提升你的影响力-1" class="headerlink" title="提升你的影响力"></a>提升你的影响力</h3><blockquote><p>对业务-软件之间的关系 保持一定的洞察力和敏锐度，能提升你的工作影响力</p></blockquote><p>对业务和产品进行360度的审视，能帮助你对团队和项目有更积极的贡献。如果你能够<strong>从销售和市场人员的角度进行思考</strong>，你将能够有更好的方式去做出正确的选择和高产出的工作。随着你对团队的影响力的提升，你对工作的满意度和工作给你的收获也会更多（译者：当然这是一种很理想的情况：工作和成长是相互促进，正相关的关系）。领导会注意到，你有能力自我驱动，不需要过多的监督，就能够做出对团队、项目和业务都有促进的事情，来提升整体效率</p><h2 id="Work-Life-balance"><a href="#Work-Life-balance" class="headerlink" title="Work-Life balance"></a>Work-Life balance</h2><p>如果你已经掌握了 技术能力、人为因素和领域方面的知识，作为软件工程师，你将会更受欢迎。团队内部的同事也会经常向你请教。除了工作本身的工程任务之外，你可能还需要承担过多协作相关的事情，导致<strong>协作过载</strong>（collaboration overload<sup><font color='#49E844'>[24]</font></sup>）。过多的临时请求会侵占你的时间，导致你没有精力去做真正想做的事</p><h3 id="时间管理"><a href="#时间管理" class="headerlink" title="时间管理"></a>时间管理</h3><blockquote><p>为 <strong>Deep Work</strong>（沉浸式工作）规划好你的时间表</p></blockquote><p>你需要在日程中专门留出一部分时间，用来做 Deep Work。坚持了几年，我发现这个方法对编写设计/策略文档，或者钻研一个技术问题是非常有效的。Deep Work 是一种<strong>远离干扰、深度集中（注意力）</strong>的工作模式，能够在有限的时间创造出很多价值。Cal Newport（乔治城大学计算机科学系副教授）的《Deep Work》<sup><font color='#49E844'>[25]</font></sup>也谈到了这一点</p><p>“<strong>注意力残留</strong>”（Attention residue）是 Cal 提到的一个观点，也是 为什么 持续的 Deep Work 能如此高效的原因：每当你从一件事情切换到另一件事的时候，内心注意力的“残留”，会让你依然陷入对上一件事的思考上面，很难重新集中注意力去做当前真正重要的事</p><p>Deep Work 通过让你专注于一件事情上，最大程度地提升你在有限时间内的产出。期间<strong>没有打扰，没有推特，没有会话或者邮件</strong>。我非常推荐你尝试一下，对那些认知工作比较重的任务（译者：需求方案设计、技术问题定位等），放在 Deep Work 的时间去完成它们</p><p>我还发现偶尔换一个工作位置，对 deep Work 很有用。我们可能会陷入到（“过于习惯”）一些特定的工作地点和特定的工作任务，如 一个桌子、一个房间、高楼里面（需要完成老板日常吩咐的任务）。适当进行一些改变，可以帮助我们重振活力</p><p>译者：有意思的是，我有个导师也经常这么做。一开始还纳闷怎么每天他下午3点多都要出去工位一段时间，后来接了个茶才发现，原来他正在茶水间摆着电脑沉浸式敲代码呢</p><blockquote><p>尽量不要打乱自己的工作时间</p></blockquote><p>如果你的一个小时因为分心，被分割成几分钟的时间块，你可能会感到焦虑。找到让你分心的原因（不管是因为自己还是别人）并解决他们。否则你的一天将会变得很低效</p><p>译者：这里提几点比较具体的建议：</p><ul><li>每天都固定留至少1h 用于专注做1-2件事情上（尽量是做有长期价值的事）</li><li>专注模式下，尽量关闭社交软件的通知，眼不见心不烦</li><li>通过公司内部的聊天工具备注，或者是其他方式，把自己的专注时间也告知别人，让别人尽量尊重你的时间的同时，提高彼此沟通的效率</li><li>专注模式尽量用在精神状态比较好的时候，这个因人而异，对译者来说就是下午3-4点的时间</li><li>也分配一个“杂事模式”，专门用来处理bug、回复、部署等这一类偏流程或运维的事情</li><li>临时的事情超过3个，一定要排个优先级，防止安排不过来（毕竟人类大脑在“多线程切换”这件事上可没有计算机这么灵活）</li><li>进入专注模式前，对自己要做的事尽量拆细，做到万一真的被打断了，能快速切换状态</li><li>（作者）切换工作地点，给自己寻找不一样的灵感。译者就发现有的大佬喜欢到茶水间/会议室专心写代码，远离嘈杂的办公位</li></ul><h3 id="过度工作并不是好的工作素养"><a href="#过度工作并不是好的工作素养" class="headerlink" title="过度工作并不是好的工作素养"></a>过度工作并不是好的工作素养</h3><p>你不可能比所有人都更努力工作。很多公司都以“加班”作为工作态度的“标准”，并将他们和良好的职业道德挂钩。然而成功来自很多因素，绝不仅仅是加班</p><h3 id="不断尝试超越自己的标准是不现实的"><a href="#不断尝试超越自己的标准是不现实的" class="headerlink" title="不断尝试超越自己的标准是不现实的"></a>不断尝试超越自己的标准是不现实的</h3><p>我对此感到很惭愧。如果你想保持平静的心态去开发，避免疯狂的工作环境，你需要有“<strong>知足心</strong>”，对现状保持满意。作为领导，你应该领导你的团队形成这样的氛围，有“<strong>足够好就可以了</strong>”的心态，树立好的榜样</p><p>译者：说白了，就是“<strong>反对无休止的内卷</strong>”。对个人来说，不断追求更好的自己是好事，但是对团队来说，看不到努力的天花板，不知道做到怎样算是足够，绝对不是好事。Leader 在给员工审核目标的时候，也应该给每个下属明确“<strong>达到足够</strong>”的指标</p><blockquote><p>工作时间是有限的，与其花更多的时间，不如减少没有必要的工作</p></blockquote><p>（市面上）已经有很多关于如何更好地重新梳理工作的指导（书、文章），然而真正的问题可能是在一开始就规划了太多需要完成的事情。你完全可以毫不犹豫地消除没有必要、浪费时间的事，而不是试图管理本来就有限的工作时间</p><h3 id="你不需要知道每一件时事"><a href="#你不需要知道每一件时事" class="headerlink" title="你不需要知道每一件时事"></a>你不需要知道每一件时事</h3><p>很多人会对没有跟上实时热点感到焦虑甚至害怕，这也是人们会沉迷于每个小时都去刷推特、reddit、instagram 等等（社交软件）的原因。我肯定也经历过（这种心态）<br>大部分信息对我们来说都没有那么重要，（与其关注时事）应该尝试更多地阅读<strong>读总结类的新闻</strong>，或者是<strong>减少查看时事的频率</strong><br>Jason Fried 的 《It doesn’t have to be crazy at work》<sup><font color='#49E844'>[26]</font></sup> 里面提到了关于这方面的更多思考</p><h3 id="通过学会说不、了解什么时候该停下来、以及规划好自己的时间（包括工作间隙的休息），主动把自己从焦虑中解放出来"><a href="#通过学会说不、了解什么时候该停下来、以及规划好自己的时间（包括工作间隙的休息），主动把自己从焦虑中解放出来" class="headerlink" title="通过学会说不、了解什么时候该停下来、以及规划好自己的时间（包括工作间隙的休息），主动把自己从焦虑中解放出来"></a>通过学会说不、了解什么时候该停下来、以及规划好自己的时间（包括工作间隙的休息），主动把自己从焦虑中解放出来</h3><p>时间管理和把握好工作-生活的平衡，对每个级别的工程师来说都至关重要。长期加班可能会让你倍感压力和失去动力。压力（过大）还会导致其他身心健康并发症。在一天结束之前把问题都解决完，会很诱人，但慢慢地这可能会变成一种（坏）习惯（加班）</p><p>扩展：压力对身体带来的影响<sup><font color='#49E844'>[27]</font></sup><br>（建议在医学生的陪同下阅读）</p><h3 id="鼓励你和你的团队成员进行休息、旅游和调休"><a href="#鼓励你和你的团队成员进行休息、旅游和调休" class="headerlink" title="鼓励你和你的团队成员进行休息、旅游和调休"></a>鼓励你和你的团队成员进行休息、旅游和调休</h3><p>你的健康和家庭都是很重要的。如果你能意识到这点，并作为高级工程师给团队其他成员做好示范，这将会很好地提升职场整体的幸福感。反之，筋疲力尽和倦怠（的工作氛围）会导致职场氛围非常不健康</p><h3 id="随着对问题的了解深入，更新（排期）评估"><a href="#随着对问题的了解深入，更新（排期）评估" class="headerlink" title="随着对问题的了解深入，更新（排期）评估"></a>随着对问题的了解深入，更新（排期）评估</h3><p>在工作中，总是会有客户或利益相关者 这样的角色，会想要了解产品什么时候可以交付，以及所投入的成本（人力、机器等）是否值得。这是非常合理的。有时他们想要对齐DDL，或者确定 为了支持你的工作，需要进行的依赖项（准备）的规划</p><p>众所周知，<strong>软件层面的 DDL 很难准确预测</strong>。只有在项目进入特定时期的时候，才能给出预估性的截止时间。随着时间推移，了解了团队解决问题的能力之后，（leader）应该更新预期。<strong>初次预估通常是最不靠谱的，但它作为起点，可以在之后不断被修正</strong>。<strong>初始预估还会比较保守</strong> — 当产品需求、用户体验或者是依赖关系不清楚的时候，一个更宽松和保守的预估，对项目发展是有帮助的。我还发现，通过和 PM 合作，保证我们都在讨论同一件事情，来制定预估，能经常获得成功</p><p>软件预估的问题在于，初次预估被固定下来之后，是当做计划，而不是初稿。当团队处在关键阶段，将初步预估当成计划（之后），却不注意及时修正，就可能会带来问题（译者：也不必做惊弓之鸟，需求排期大概2-3天左右更新一次即可）。一旦项目获得批准，细节更是需要留意 — 随着对如何实现需求有更加清晰的认识，原本3个月的预估可能就要变成2个月（或4个月）</p><p>你几乎总是尽可能想要让预估驱动你的计划，或者是让计划驱动更新你的预估。在我的团队中，如果我们确实有一些不可推迟的 DDL（如会议），（其他需求）预期超过ddl 可能也是可以的 — 我们可以通过修改提示（如：预览，或在界面提示：该功能将在不久之后实现）、将需求推向更久之后的未来完成等，这些都是可以和领导商量的选项。当然，我必须确认，这些（变化）并不总是这么微小（所以需要谨慎考虑）。当工作计划变得紧张的时候，我们可以把工作拆解成 “必须实现（<strong>must-have</strong>）” 和 “如果有会更好（<strong>nice-to-have</strong>）” 两部分，将后者移到后续的迭代中去，并确认前者是否能赶上 DDL</p><p>（在做了这些调整之后）如果计划还是太赶，你还有其他问题可以确认：比如 “我们是否还可以增加项目人手？” 以及 “是否有一大部分（工作）范围可以削减，之后依然能实现（令用户）满意的交付水准？”</p><p>译者：对 leader 来说，还应该注重的点是<strong>备用方案的制定</strong>。需求在实现过程中不可能所有事都一帆风顺，对中间环节可能遇到的问题，leader 应该要有准备意识，对各种情况都有一套备用方案，保证需求能够按时交付</p><h3 id="有时取消项目是正确的选择（即便是让人感到不舒服）"><a href="#有时取消项目是正确的选择（即便是让人感到不舒服）" class="headerlink" title="有时取消项目是正确的选择（即便是让人感到不舒服）"></a>有时取消项目是正确的选择（即便是让人感到不舒服）</h3><p>我讨厌（取消项目）这件事，但长远来看，对项目和组织来说它确实可能是最健康的选择。特别是在项目获得支持、准备正式上线之前，却因为团队成员要解散，而最终不得不停止之前做这个（取消项目的）决定，（提前取消项目）是尤其正确的。如果大家想知道，建议阅读 《Killed by Google》<sup><font color='#49E844'>[28]</font></sup>，这篇文章旨在尽量减少因为大环境问题，导致需要裁减项目的情况。最近我就停止了一个经营了 好几年的项目，感到很艰难</p><p>什么时候会出现需要停止项目的情况？你可以决定投资一个在当时看起来方向正确的新项目，各种事情看起来都完美契合（市场需求、公司投入、人力投入承诺等），使得整个项目也是完全有价值有意义的。<strong>但一年之后，市场、领导层、项目的重要性等环境因素，可能就变了</strong>。定期检视 项目成立初期的假设，随着项目的发展，是否依然成立 （对保障项目稳定）很关键</p><p>当你越能为你的假设支撑起更多的信心时，你就越有机会让项目成功启动，并继续获得支持。有很多原因 让停止项目很艰难，包括参与项目的同事们，已经投入了真心实意的情感，希望能看到项目成功落地。作为leader，将被解散团队的成员引导到其他已经成功落地的项目 也是一个艰难的选择，因此让他们重新感觉到 内心的安全、信任和幸福 是很重要的。从客户角度来说，（作为leader）也需要留意 用户的信任度，你需要认识到你的长期决策 会如何影响到用户感受</p><h3 id="关于技术债：预防远远-gt-补救"><a href="#关于技术债：预防远远-gt-补救" class="headerlink" title="关于技术债：预防远远 &gt; 补救"></a>关于技术债：预防远远 &gt; 补救</h3><p>Titus Winters<sup><font color='#49E844'>[29]</font></sup> （Google c++ 代码负责人） 将技术债定义为“<strong>系统（效果）和代码之间的差距，在当下的情况 vs 我们预期的情况</strong>”（译者：这里提到的“差距”，其实就是需要“<strong>补救</strong>”的工作，<strong>在项目起步阶段容易被忽略的事情</strong>，比如单元测试、调试工具、故障处理机制等）。这些差距会有具体的体现，并且会比其他债务的影响更深。技术债有的来自早期没有出现的软件异常（疏忽），有的来自事后发现（后见之明），还有的来自技术的变化（环境因素）</p><p>持续优先应对技术债还是很难的，因为你不是总能将还没出现的bug 或者 还没发生的 服务故障 量化，因为你还没“还清足够的技术债”。因此 保持住团队对 修补技术债 这种事情的兴趣，并在评估绩效的时候（适当）奖励这种事项，是很重要的。问题随着时间的积累，“补救”的成本也会越来越大，就像解决污染问题一样，因此对技术债的预防，永远是比在之后再进行补救的成本更低</p><p>那么，我们该怎么避免技术债（过度）积累呢？技术 leader 应该在迭代中，除了新功能的需求之外，也定期安排 整理和“弥补”技术债的工作。检视者需要意识到，（过于）追求短期成效，可能会在之后导致问题。管理者和董事会也应该特别小心 用新项目替换（覆盖）已存在项目。除非权衡利弊之后，觉得替换值得的（比如需要对比：解决当前项目技术债是不值得的 vs 构建新的项目）。另外，监控项目的健康状态，是在这里讨论如何解决技术债的 基础</p><h3 id="如果没有充足的休息，和-work-life-balance（的习惯），你的团队将会产生职业倦怠"><a href="#如果没有充足的休息，和-work-life-balance（的习惯），你的团队将会产生职业倦怠" class="headerlink" title="如果没有充足的休息，和 work-life balance（的习惯），你的团队将会产生职业倦怠"></a>如果没有充足的休息，和 work-life balance（的习惯），你的团队将会产生职业倦怠</h3><p><strong>Burnout</strong><sup>（<strong>职业倦怠</strong><font color='#49E844'>[30]</font></sup>）是一种 由于压力没有被成功管理好，而导致 精力耗尽的状态。我见过很多程序员，在大环境导致的工作压力下，产生职业倦怠。在科技领域，这种情况总是会出现。最近我采访（同事）会按 1:1 的比例问两个问题：“你的压力等级现在怎么样？”、“我可以怎么帮助你？”</p><p>我对职业倦怠的体验是：<strong>这种感觉来得不知不觉，又很难消散</strong>。你会慢慢地感觉能量开始变少，失去动力，甚至还要继续尽力应付工作压力。你开始怀疑自己出现了什么问题，但没有意识到，你的身体已经在过度工作，来弥补能量的不足。你还会继续让自己工作强度越来越大，但最终会发现（身体）已经没有多少可以付出的了</p><p>大概5年前，我经历过这种职业倦怠，不过我感到欣慰的是现在走出来了。是什么让我走出来的呢？有很多因素。（职业生涯）前几年，我把工作放在第一位，工作时间越来越长，并总是说做得还不够。从来没有进行足够的休息的假期。晚上平均只睡5个小时。到家之后，我已经是“低能量”的状态了，没有给家庭足够多的陪伴<br>所谓的“修正”，就是做和这些相反的事：<strong>工作之余多休息、晚上多睡觉、在工作时间内挤出更多价值（即 提升工作效率），更好地委派（工作），并有一个明确的“非工作”时间</strong></p><p>对主管来说，为了避免下属产生职业倦怠，我们应该鼓励团队成员多用上假期时间，获得休息，并定期（沟通）确认下属在有压力情况下，依然能顺利做好他们的工作</p><h3 id="大型组织-公司中流程会比较缓慢"><a href="#大型组织-公司中流程会比较缓慢" class="headerlink" title="大型组织/公司中流程会比较缓慢"></a>大型组织/公司中流程会比较缓慢</h3><p>我和工程师们进行过很多对话，最后（主题）都可以归结为“为什么在大型组织中进行 <strong>X moon-shot</strong>（谷歌内部形容 “创新性的、难以实现的项目” ） 很困难？”Alex Komoroske<sup><font color='#49E844'>[31]</font></sup>（前谷歌产品经理） 对此有一个很好的比喻：<strong>黏菌</strong><sup><font color='#49E844'>[32]</font></sup>（slime mold）。背后的意思是，即使是（在公司中）执行一件很小的工作，可能都会因为 协作阻力，比你理想中进展要慢很多。随着直接参与、或者合作参与项目的人变多，组织的系统、架构和内部动态 变得复杂，这种阻力就会变大</p><p>还有很多因素对这种阻力起着作用，包括对其他同事的工作事项复杂度的低估（比如：这些事情之间有依赖关系的时候），你不能忽略这些因素，因为它们会让系统故障（影响面）扩散开。解决这种阻碍的唯一方式就是尽可能地<strong>解耦</strong><sup><font color='#49E844'>[33]</font></sup>，这样才能让（功能）能按正确的时间节点交付，最终收敛于目标需求</p><p>与其一开始就追踪所有的不确定（X）因素，你可以避免只关注“对月亮射击”（成功风险较大的努力）的问题，而更多地关注“对天花板射击”（完成每一步的风险更小）的问题，能让你更容易地接近目标。如果你遇到的问题和这个章节非常类似，非常建议你阅读 Alex 的 分享《Coordination Headwinds》<sup><font color='#49E844'>[34]</font></sup> （PPT）</p><h3 id="专注于-问题-VS-专注于-项目"><a href="#专注于-问题-VS-专注于-项目" class="headerlink" title="专注于 问题 VS 专注于 项目"></a>专注于 问题 VS 专注于 项目</h3><p>想象你的用户有一个未解决的需求（比如 一个问题），当你是具体负责一个项目的工程师的时候，思考你的项目会如何解决这个问题是很正常的（局部最大值）。在一个拥有几个类似项目的大型组织中，很可能会看到工程师们独自思考“我的项目如何解决这个问题”。如果你是一批项目的管理者，（这种解决问题的思考方式）就不是那么清晰了。如果你的用户表示希望用到你们好几个产品的时候呢？如果每个项目都独立地按几乎相同的思路，去解决问题，不会觉得很奇怪吗？相反，你真正想提的问题可能是 “<strong>什么是解决这个问题 端到端 的方案？</strong>”，并探索需要如何对多个项目进行修改/升级，才能够全面地解决用户需求。这种方式可能需要参与了多个相关项目的开发者，进行更深入的合作。（虽然人力成本会提升，然而）这种方式能最终给你的用户一个更清晰、更全面的解决方案（场景故事）</p><p>译者：作者的出发点主要是在有多个成熟方案的基础上，保留最优解。但在项目还处于探索阶段，需要跟紧开源社区、竞争对手的时候，产品之间出现重叠并不算大问题，甚至公司还会有意保留产品功能类似的团队，促进竞争</p><h2 id="作者总结"><a href="#作者总结" class="headerlink" title="作者总结"></a>作者总结</h2><p>Brian Staufenbiel（Opera Parallèle 的创意总监和设计师） - “多和专家在一起（共事），多和那些在特定领域有专长的同事一起工作”</p><p>（将时间）投资于 那些 能够让你学到东西的同事的关系和友谊上，对他们的指导、领导和成功保持开放态度。<strong>永远不要羞于提出问题或者咨询意见</strong>。在很多情况下，（你离正解）只是一个问题的差距。</p><p>不管在什么阶段，<strong>对技术、商业领域和 人脉资源 技能的掌控（能力）</strong> 都是需要持续培养的。一个企业不可能期待 从别的企业招来的 高级别人才，从第一天就能非常适应公司并高效工作。如果你是一个优秀的工程师，你将会对公司的成长也有所帮助。作为回报，你也会获得一些新的途径，它们将指引你 继续吸收新的技术，不断成长</p><p>最后，感谢 Leena Sohoni, Joshua Cruz, Kara Erickson, Jeff Posnick, Houssein Djirdeh and Sriram Krishnan 对本文积极的帮助和贡献</p><h2 id="资料"><a href="#资料" class="headerlink" title="资料"></a>资料</h2><p>[1] <a href="https://addyosmani.com/">Addy Osmani</a></p><p>[2] <a href="https://addyosmani.com/blog">作者博客首页</a></p><p>[3] <a href="https://www.glassdoor.com/blog/guide/soft-skills-vs-hard-skills">通用技巧</a></p><p>[4] <a href="https://en.wikipedia.org/wiki/First_principle">第一原则</a></p><p>[5] <a href="https://www.learningscientists.org/blog/2021/3/25-1">批判性思考是通用技能吗？</a></p><p>[6] <a href="https://skorks.com/2010/04/on-the-value-of-fundamentals-in-software-development">The value of fundamentals in Software Engineering</a></p><p>[7] <a href="https://medium.com/@felixthedev/why-learning-the-programming-fundamentals-matters-67e5dbbdee8f">Why learning the fundamentals matters</a></p><p>[8] <a href="https://www.freecodecamp.org/news/learn-the-fundamentals-of-a-good-developer-mindset-in-15-minutes-81321ab8a682">Learn the fundamentals of a good developer mindset</a></p><p>[9] <a href="https://en.wikipedia.org/wiki/Fear_of_missing_out">FOMO</a></p><p>[10] <a href="https://itrevolution.com/articles/why-the-full-stack-engineer-is-problematic">T型工程师</a></p><p>[11] <a href="https://www.csc.gov.sg/articles/how-to-build-good-software">Why Bad Software Happens to Good People</a></p><p>[12] <a href="https://en.m.wikipedia.org/wiki/You_aren%27t_gonna_need_it">YAGNI</a></p><p>[13] <a href="https://ronjeffries.com/xprog/articles/practices/pracsimplest">Do the simplest thing that could possibly work</a></p><p>[14] <a href="https://en.m.wikipedia.org/wiki/Overengineering">不要过度设计</a></p><p>[15] <a href="https://en.m.wikipedia.org/wiki/Abstraction_principle_(computer_programming)">抽象原则</a></p><p>[16] <a href="https://en.m.wikipedia.org/wiki/Don%27t_repeat_yourself#AHA">AHA</a></p><p>[17] <a href="https://medium.com/@nathan.fooo/4-notes-modules-should-be-deep-ba5671c4288c">Deep Module</a></p><p>[18] <a href="https://asbresources.com/pros-and-cons-of-failing-fast-with-agile">快速失败</a></p><p>[19] <a href="https://www.productplan.com/learn/agile-definition-of-done">The Definition of Done</a></p><p>[20] <a href="https://hbr.org/2017/06/help-your-team-stop-overcommitting-by-empowering-them-to-say-no">Help Your Team Stop Overcommitting by Empowering Them to Say No</a></p><p>[21] <a href="https://www.saffo.com/02008/07/26/strong-opinions-weakly-held">Strong opinions weakly held</a></p><p>[22] <a href="https://www.healthline.com/health/mental-health/imposter-syndrome">Imposter syndrome</a></p><p>[23] <a href="https://news.ycombinator.com/item?id=26177680">来源</a></p><p>[24] <a href="https://hbr.org/2016/01/collaborative-overload">collaboration overload</a></p><p>[25] <a href="https://www.amazon.co.jp/-/en/Cal-Newport/dp/1455586692">Deep Work: Rules for Focused Success in a Distracted World</a></p><p>[26] <a href="https://www.amazon.com/Doesnt-Have-Be-Crazy-Work/dp/0062874780">It doesn’t have to be crazy at work</a></p><p>[27] <a href="https://www.apa.org/topics/stress/body">压力对身体带来的影响</a></p><p>[28] <a href="https://killedbygoogle.com/">Killed by Google</a></p><p>[29] <a href="https://www.oreilly.com/pub/au/7953">Titus Winters</a></p><p>[30] <a href="https://zh.m.wikipedia.org/zh-hans/%E8%81%8C%E4%B8%9A%E5%80%A6%E6%80%A0">职业倦怠</a></p><p>[31] <a href="https://www.komoroske.com/">Alex Komoroske</a></p><p>[32] <a href="https://zh.wikipedia.org/wiki/%E9%BB%8F%E8%8F%8C">黏菌</a></p><p>[33] <a href="https://www.infoq.cn/article/8hlh2qewp1y00qumdmqj">解耦</a></p><p>[34] <a href="https://komoroske.com/slime-mold">Coordination Headwinds</a></p>]]></content>
    
    
    <summary type="html">既有感情，又有技巧</summary>
    
    
    
    <category term="职业规划" scheme="http://smiecj.github.io/categories/%E8%81%8C%E4%B8%9A%E8%A7%84%E5%88%92/"/>
    
    
    <category term="翻译" scheme="http://smiecj.github.io/tags/%E7%BF%BB%E8%AF%91/"/>
    
    <category term="职业规划" scheme="http://smiecj.github.io/tags/%E8%81%8C%E4%B8%9A%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>通过 sealos 部署 k8s 集群</title>
    <link href="http://smiecj.github.io/2022/09/22/sealos/"/>
    <id>http://smiecj.github.io/2022/09/22/sealos/</id>
    <published>2022-09-21T16:00:00.000Z</published>
    <updated>2022-09-21T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://blog.csdn.net/xiaoliizi/article/details/126998976">本文csdn地址</a></p><h2 id="sealos"><a href="#sealos" class="headerlink" title="sealos"></a>sealos</h2><p><a href="https://docs.sealos.io/zh-Hans/docs/Intro">官方文档</a></p><p><a href="https://github.com/labring/sealos/releases">release</a></p><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>sealos 是用于一键部署 k8s 集群的<strong>工具</strong>。对于不想被太多操作系统细节配置困扰，又想快速装好一套测试k8s集群的同学，无疑是很方便的</p><p>网上教程很多，这边自己简单写下在公司机器上安装的过程，绕了一部分坑，帮助大家更快地使用</p><p>官方文档还说明 sealos 可用来安装其他分布式组件，mysql、redis、pgsql 等</p><h2 id="下载-sealos"><a href="#下载-sealos" class="headerlink" title="下载 sealos"></a>下载 sealos</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -LO https://github.com/labring/sealos/releases/download/v4.0.0/sealos_4.0.0_linux_amd64.tar.gz</span><br></pre></td></tr></table></figure><p>解压后的文件列表:</p><p>[root@host_name sealos]# ll<br>总用量 68568<br>-rw-r—– 1 root root Clusterfile<br>-rwxr-xr-x 1  501   20 image-cri-shim<br>-rw-r–r– 1  501   20 LICENSE<br>-rw-r–r– 1  501   20 README.md<br>-rwxr-xr-x 1  501   20 sealctl<br>-rwxr-xr-x 1  501   20 sealos</p><p>sealos: 安装 k8s 工具<br>sealctl: 管理员工具，如生成证书。自己暂时没用到过</p><h2 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h2><h3 id="免密登录"><a href="#免密登录" class="headerlink" title="免密登录"></a>免密登录</h3><p>对于没有给 机器登录密码（比如 root 密码） 的环境来说，可以登录节点后配置 ssh key ，用于在<strong>执行 sealos 指令的节点 免密登录 安装节点</strong>（包括 master 和 其他节点）</p><h2 id="安装-k8s"><a href="#安装-k8s" class="headerlink" title="安装 k8s"></a>安装 k8s</h2><p>常用的安装方式有两种: 直接安装 和 导出配置文件后再安装</p><h3 id="直接安装"><a href="#直接安装" class="headerlink" title="直接安装"></a>直接安装</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sealos run labring/kubernetes:k8s_version labring/calico:calico_version \</span><br><span class="line">     --masters master_ip:ssh_port \</span><br><span class="line">     --nodes node_1_ip:ssh_port,node_2_ip:ssh_port</span><br></pre></td></tr></table></figure><p>自己测试用的版本: k8s: v1.20.0, calico: v3.22.1</p><h3 id="导出配置后安装（推荐）"><a href="#导出配置后安装（推荐）" class="headerlink" title="导出配置后安装（推荐）"></a>导出配置后安装（推荐）</h3><p>导出配置文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">./sealos gen labring/kubernetes:k8s_version labring/calico:calico_version \</span><br><span class="line">     --masters master_ip:ssh_port \</span><br><span class="line">     --nodes node_1_ip:ssh_port,node_2_ip:ssh_port &gt; Clusterfile</span><br></pre></td></tr></table></figure><p>配置google镜像源</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># vim Clusterfile</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps.sealos.io/v1beta1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Cluster</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">creationTimestamp:</span> <span class="literal">null</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">default</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="comment"># ...</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="comment"># 设置 google container 阿里代理源，加速下载</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">kubeadm.k8s.io/v1beta1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ClusterConfiguration</span></span><br><span class="line"><span class="attr">imageRepository:</span> <span class="string">registry.aliyuncs.com/google_containers</span></span><br></pre></td></tr></table></figure><p>运行集群</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./sealos apply -f Clusterfile</span><br></pre></td></tr></table></figure><h3 id="安装后测试"><a href="#安装后测试" class="headerlink" title="安装后测试"></a>安装后测试</h3><p>查看 pod</p><p><img src="/2022/09/22/sealos/sealos03.png" alt="all pods"></p><p>查看镜像</p><p><img src="/2022/09/22/sealos/sealos02.png" alt="all images"></p>]]></content>
    
    
    <summary type="html">sealos 使用初体验</summary>
    
    
    
    <category term="开发工具" scheme="http://smiecj.github.io/categories/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"/>
    
    <category term="Kubernetes" scheme="http://smiecj.github.io/categories/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/Kubernetes/"/>
    
    
    <category term="Linux" scheme="http://smiecj.github.io/tags/Linux/"/>
    
    <category term="Kubernetes" scheme="http://smiecj.github.io/tags/Kubernetes/"/>
    
  </entry>
  
  <entry>
    <title>通过 Docker Compose 本地启动 hadoop 集群</title>
    <link href="http://smiecj.github.io/2022/08/13/dockerfile-compose-hdfs/"/>
    <id>http://smiecj.github.io/2022/08/13/dockerfile-compose-hdfs/</id>
    <published>2022-08-12T16:00:00.000Z</published>
    <updated>2022-08-12T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://blog.csdn.net/xiaoliizi/article/details/126474924">本文csdn地址</a></p><h2 id="项目地址"><a href="#项目地址" class="headerlink" title="项目地址"></a>项目地址</h2><p><a href="https://github.com/smiecj/docker-centos/releases/tag/v1.3.0">docker-centos</a></p><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>在完成几个开源中间件的容器化一键部署之后，和一个同事聊到了关于如何在本地部署 hadoop 集群，方便进行大数据任务相关的测试</p><p>后面我们一起搜了一些资料，在知乎<sup><font color='#49E844'>[1]</font></sup>上找到有人弄好了一套镜像<sup><font color='#49E844'>[2]</font></sup>, 功能应该是比较完善的，只是稍微有一点不足是没有支持 arm 版本</p><p>所以之后那位同事还是用虚拟机的方式，手动部署 Hadoop 搭建好了本地测试集群，省不了的是一些手动配置的操作，虽然也不会太复杂</p><p>而自己的想法是: 既然已经接触了除了 hdfs 之外的上层应用，比如 knox、ranger 等，是否可以按照之前部署 zk 集群的思路<sup><font color='#49E844'>[3]</font></sup>，把 hadoop 基础集群也写到 docker compose 里面呢？</p><p>于是，接近两个月的各种踩坑和实践开始了</p><h2 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h2><h3 id="服务部署"><a href="#服务部署" class="headerlink" title="服务部署"></a>服务部署</h3><p>两种部署方式: 从头开始搭建镜像 再启动服务 or 直接从 dockerhub 拉取镜像并启动服务，通过前者有助于你了解镜像结构，但是如果是想快速部署服务建议参考后者</p><p>【建议】直接拉取镜像:<br>为了方便使用，我已经将镜像提交到 dockerhub (mzsmieli/centos_hdfs_full)，直接拉取并启动即可</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 下载镜像</span></span><br><span class="line">docker pull mzsmieli/centos_hdfs_full:v1.0.0</span><br><span class="line">docker pull mzsmieli/centos_mysql:v1.0.0</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 运行hdfs集群</span></span><br><span class="line">REPO=mzsmieli make run_hdfs_cluster</span><br></pre></td></tr></table></figure><p>构建镜像:<br>下载工程 docker-centos 后，需要依次准备以下镜像:</p><ul><li>centos_base<ul><li>centos 基础环境镜像</li></ul></li><li>centos_java<ul><li>java 基础镜像</li></ul></li><li>centos_hdfs<ul><li>hdfs 基础镜像，包含 hadoop 服务，依赖 java 镜像</li></ul></li><li>centos_hive<ul><li>hive 基础镜像，包含 hadoop、hive 服务，依赖 hdfs 镜像</li></ul></li><li>centos_knox<ul><li>knox 镜像，依赖 java 镜像</li></ul></li><li>centos_hdfs_full<ul><li>完整 hadoop 镜像，在 hdfs+hive+knox 基础上提供 flink、spark</li></ul></li><li>centos_minimal<ul><li>centos 部署服务最小镜像</li></ul></li><li>centos_mysql<ul><li>mysql 镜像，依赖 minimal</li></ul></li></ul><p>镜像整体架构图:<br><img src="/2022/08/13/dockerfile-compose-hdfs/hdfs_image.png" alt="hdfs_image"></p><p>概括来说就是 <strong>centos 基础镜像 -&gt; 各语言开发镜像 -&gt; 服务镜像</strong></p><p>完整指令:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 构建镜像（首次构建所有镜像大约需要半个小时）</span></span><br><span class="line">make build_hdfs_cluster</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 运行hdfs集群</span></span><br><span class="line">make run_hdfs_cluster</span><br></pre></td></tr></table></figure><p>端口和地址说明:</p><ul><li><strong>8443</strong>: knox 网关地址<ul><li><a href="http://localhost:8443/gateway/sandbox/yarn">http://localhost:8443/gateway/sandbox/yarn</a></li><li><a href="http://localhost:8443/gateway/sandbox/hdfs">http://localhost:8443/gateway/sandbox/hdfs</a></li></ul></li><li><strong>8088</strong>: hdfs resourcemanager web 地址（yarn）<ul><li><a href="http://localhost:8088/">http://localhost:8088</a></li></ul></li><li><strong>50070</strong>: hdfs namenode web 地址（data）<ul><li><a href="http://localhost:50070/">http://localhost:50070</a></li></ul></li><li><strong>10000</strong>: hive server 地址</li><li><strong>33306</strong>: mysql 端口</li></ul><h3 id="hdfs"><a href="#hdfs" class="headerlink" title="hdfs"></a>hdfs</h3><p><img src="/2022/08/13/dockerfile-compose-hdfs/hdfs_hdfs_datanode.png" alt="hdfs_hdfs_datanode"></p><h3 id="yarn"><a href="#yarn" class="headerlink" title="yarn"></a>yarn</h3><p><img src="/2022/08/13/dockerfile-compose-hdfs/hdfs_yarn_total.png" alt="hdfs_yarn_total"></p><h3 id="flink、spark"><a href="#flink、spark" class="headerlink" title="flink、spark"></a>flink、spark</h3><p>提交任务这块做了简单的提交验证</p><p>提交 flink 任务:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd /opt/modules/flink-1.15.0</span><br><span class="line">./bin/flink run -m yarn-cluster ./examples/batch/WordCount.jar</span><br></pre></td></tr></table></figure><p><img src="/2022/08/13/dockerfile-compose-hdfs/hdfs_flink_web.png" alt="hdfs_flink_web"></p><p>提交 spark 任务:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/opt/modules/spark/bin/spark-submit --master yarn --deploy-mode cluster --class org.apache.spark.examples.SparkPi /opt/modules/spark/examples/jars/spark-examples_2.12-3.2.2.jar 100</span><br></pre></td></tr></table></figure><p><img src="/2022/08/13/dockerfile-compose-hdfs/hdfs_spark_yarn.png" alt="hdfs_spark_yarn"></p><h3 id="hive"><a href="#hive" class="headerlink" title="hive"></a>hive</h3><p>hive 可通过 开源数据库客户端工具，dbeaver<sup><font color='#49E844'>[4]</font></sup> 直接连接，注意需要填用户名，否则可能会因为权限问题无法执行 SQL</p><p><img src="/2022/08/13/dockerfile-compose-hdfs/hdfs_hive_connect.png" alt="hdfs_hive_connect"></p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h3 id="组件版本"><a href="#组件版本" class="headerlink" title="组件版本"></a>组件版本</h3><p>hdfs - 3.3.2<br>knox - 1.6.1<br>hive - 3.1.2<br>flink - 1.15<br>spark - 3.2</p><p>其中 <strong>knox</strong><sup><font color='#49E844'>[5]</font></sup> 是大数据组件通用的网关服务，可以用于配置统一代理、身份认证、单点登录等，一般是刚搭建大数据集群的时候需要装，后续就不需要怎么管了。其他服务比较核心</p><h3 id="hadoop"><a href="#hadoop" class="headerlink" title="hadoop"></a>hadoop</h3><p>基本的安装和配置，参考网上的教程<sup><font color='#49E844'>[6]</font></sup>做就行。为了能在一个镜像中同时支持单点和集群启动，dockerfile 中做了通过识别容器启动环境参数，进行不同的初始化和服务启动的功能：在容器的启动参数中指定 <strong>-e HDFS_START=hdfsstart / hdfsstartall</strong>，即可区分</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"># Dockerfiles/emr/hdfs/scripts/hdfs-start.sh</span><br><span class="line"># 单点启动 hdfs 服务脚本</span><br><span class="line"></span><br><span class="line">## 服务启动指令（本地启动 namenode、datanode、resourcemanager）</span><br><span class="line">./sbin/start-dfs.sh</span><br><span class="line">./sbin/start-yarn.sh</span><br><span class="line"></span><br><span class="line"># Dockerfiles/emr/hdfs/scripts/hdfs-start-all.sh</span><br><span class="line"># 启动 hdfs 集群脚本</span><br><span class="line"></span><br><span class="line">## 配置: /etc/hadoop/conf/workers</span><br><span class="line">hadoop2</span><br><span class="line">hadoop3</span><br><span class="line"></span><br><span class="line">## 服务启动指令（主节点启动 namenode、resourcemanager，worker 节点启动 datanode、nodemanager）</span><br><span class="line">./sbin/start-all.sh</span><br></pre></td></tr></table></figure><h3 id="knox"><a href="#knox" class="headerlink" title="knox"></a>knox</h3><p>knox 主要是配置需要留意，大体分为 knox 本身的服务配置、网关配置 和 代理的服务配置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"># knox配置</span><br><span class="line">## /opt/modules/knox/conf/gateway-site.xml</span><br><span class="line">### 禁用 ssl 和 身份认证，方便调试</span><br><span class="line">&lt;property&gt;</span><br><span class="line">    &lt;name&gt;ssl.enabled&lt;/name&gt;</span><br><span class="line">    &lt;value&gt;false&lt;/value&gt;</span><br><span class="line">&lt;/property&gt;</span><br><span class="line"></span><br><span class="line">&lt;provider&gt;</span><br><span class="line">    &lt;role&gt;identity-assertion&lt;/role&gt;</span><br><span class="line">    &lt;name&gt;Default&lt;/name&gt;</span><br><span class="line">    &lt;enabled&gt;disable&lt;/enabled&gt;</span><br><span class="line">&lt;/provider&gt;</span><br><span class="line"></span><br><span class="line"># 网关配置</span><br><span class="line">## /opt/modules/knox/conf/topologies/sandbox.xml</span><br><span class="line">### hdfs 和 yarn 地址，因为 namenode 和 knox 都部署在主节点，所以这里配的都是 localhost</span><br><span class="line">&lt;service&gt;</span><br><span class="line">    &lt;role&gt;HDFSUI&lt;/role&gt;</span><br><span class="line">    &lt;url&gt;http://localhost:50070&lt;/url&gt;</span><br><span class="line">    &lt;version&gt;2.7.0&lt;/version&gt;</span><br><span class="line">&lt;/service&gt;</span><br><span class="line"></span><br><span class="line">&lt;service&gt;</span><br><span class="line">    &lt;role&gt;YARNUI&lt;/role&gt;</span><br><span class="line">    &lt;url&gt;http://localhost:8088&lt;/url&gt;</span><br><span class="line">&lt;/service&gt;</span><br><span class="line"></span><br><span class="line"># 代理服务配置</span><br><span class="line">## /opt/modules/knox/data/services/hdfsui/2.7.0/rewrite.xml</span><br><span class="line">### 这里需要加个规则: 因为 hdfs 的 index.html 页面实际是一个 跳转页面（&lt;a&gt; 元素），而直接访问</span><br><span class="line">### 这个地址会被链接到容器环境内部域名（hadoop1），而不是外部域名（localhost:8443）导致在外部访问跳转失败</span><br><span class="line">### 因此一个最直接的解决方式就是将 index.html 直接链接到 dfshealth.html 让 knox 帮我们做这个跳转，保持外部域名（gateway.url）</span><br><span class="line"></span><br><span class="line">&lt;rule dir=&quot;OUT&quot; name=&quot;HDFSUI/redirect&quot; pattern=&quot;/index.html&quot;&gt;</span><br><span class="line">  &lt;rewrite template=&quot;&#123;gateway.url&#125;/hdfs/dfshealth.html&quot;/&gt;</span><br><span class="line">&lt;/rule&gt;</span><br></pre></td></tr></table></figure><h3 id="hive-1"><a href="#hive-1" class="headerlink" title="hive"></a>hive</h3><p>hive 服务启动前，需要做初始化 mysql 的操作，涉及到两个细节：hive 初始化脚本 init-hive.sh 中，需要执行 schematool 进行元数据初始化；compose 文件中也要定义 主节点，也是 hive 启动的节点，需要依赖 mysql 容器（depends_on）</p><h3 id="compose"><a href="#compose" class="headerlink" title="compose"></a>compose</h3><p>各个组件都准备完成后，对 compose 配置文件的编写主要就是设置容器启动的环境变量了</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&quot;3.9&quot;</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">hadoop1:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">$&#123;HDFS_FULL_IMAGE&#125;</span></span><br><span class="line">    <span class="attr">hostname:</span> <span class="string">hadoop1</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="comment"># hdfs 主节点配置</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">DEFAULTFS=hdfs://hadoop1:8020</span> <span class="comment"># 主节点地址: 即 hadoop1 地址</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">DFS_REPLICATION=2</span> <span class="comment"># 两个 worker 节点</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">RESOURCEMANAGER_HOSTNAME=hadoop1</span> <span class="comment"># rm 节点: 依然是 hadoop1</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">WORKERS=hadoop2,hadoop3</span> <span class="comment"># worker 节点具体域名，会在 init-hdfs.sh 脚本中解析</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">HDFS_START=hdfsstartall</span> <span class="comment"># hadoop 启动方式: 集群模式</span></span><br><span class="line">      <span class="comment"># knox 配置</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">KNOX_START=knoxstart</span> <span class="comment"># 是否启动</span></span><br><span class="line">      <span class="comment"># hive 配置</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">HIVE_START=hivestart</span> <span class="comment"># 是否启动</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">mysql_host=mysql</span> <span class="comment"># mysql 配置，用于存储元数据</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">mysql_port=3306</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">mysql_db=hive</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">mysql_user=root</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">mysql_pwd=root_HADOOP_123</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="comment"># 主节点需要开放各主要节点的端口</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;8443:8443&quot;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;8088:8088&quot;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;50070:50070&quot;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;10000:10000&quot;</span></span><br><span class="line">    <span class="attr">depends_on:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">hadoop2</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">hadoop3</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">mysql</span></span><br><span class="line">  <span class="attr">hadoop2:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">$&#123;HDFS_FULL_IMAGE&#125;</span></span><br><span class="line">    <span class="attr">hostname:</span> <span class="string">hadoop2</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="comment"># hdfs worker 节点配置</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">DEFAULTFS=hdfs://hadoop1:8020</span> <span class="comment"># 主节点地址</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">DFS_REPLICATION=2</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">RESOURCEMANAGER_HOSTNAME=hadoop1</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">WORKERS=hadoop2,hadoop3</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">HDFS_START=hdfsnotstart</span> <span class="comment"># worker 节点不主动启动 hdfs，由主节点触发</span></span><br><span class="line">  <span class="attr">hadoop3:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">$&#123;HDFS_FULL_IMAGE&#125;</span></span><br><span class="line">    <span class="attr">hostname:</span> <span class="string">hadoop3</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">DEFAULTFS=hdfs://hadoop1:8020</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">DFS_REPLICATION=2</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">RESOURCEMANAGER_HOSTNAME=hadoop1</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">WORKERS=hadoop2,hadoop3</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">HDFS_START=hdfsnotstart</span></span><br><span class="line">  <span class="attr">mysql:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">$&#123;MYSQL_IMAGE&#125;</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;33306:3306&quot;</span></span><br><span class="line">    <span class="comment"># mysql 节点配置</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">ROOT_PASSWORD=root_HADOOP_123</span> <span class="comment"># root 账号密码</span></span><br></pre></td></tr></table></figure><h3 id="提交镜像"><a href="#提交镜像" class="headerlink" title="提交镜像"></a>提交镜像</h3><p>在实践的过程中发现 基于 Dockerfile 在分享上也不是特别方便，比如新来的同学想使用 dev_full 完整开发镜像，他还需要在自己的电脑上先重新构建一次镜像。更好的方法还是通过镜像仓库直接分享镜像<br>因此后面把自己的镜像都提交到了 dockerhub 中，包括之前做的 easyconnect<sup><font color='#49E844'>[7]</font></sup> 代理镜像、dev_full<sup><font color='#49E844'>[8]</font></sup> 包含多种开发语言的开发镜像<br>构建方式: 通过 <strong>buildx</strong><sup><font color='#49E844'>[9]</font></sup> 工具构建</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 示例: 构建并提交 base 镜像，同时构建 arm 和 amd 版本</span></span><br><span class="line">docker buildx build --platform linux/arm64,linux/amd64 --no-cache -f ./Dockerfiles/system/centos_base.Dockerfile -t dockerhub账号名/centos_base:v1.0 ./Dockerfiles/system --push</span><br></pre></td></tr></table></figure><p>在 dockerhub 查看刚提交的镜像:<br><img src="/2022/08/13/dockerfile-compose-hdfs/hdfs_dockerhub.png" alt="hdfs_dockerhub"></p><p>扩展: 运行 easyconnect 镜像</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 使用 easyconnect 镜像</span></span><br><span class="line">REPO=mzsmieli make run_rc</span><br><span class="line"><span class="meta">#</span><span class="bash"> 将下载 mzsmieli/centos_easyconnect:v1.0.0</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 完整指令</span></span><br><span class="line">docker pull mzsmieli/centos_easyconnect:v1.0.0</span><br><span class="line">docker run -it -d --privileged=true --platform linux/amd64 --hostname test_ec --name dev_ec -p 3389:3389 -p 7881:7881 mzsmieli/centos_easyconnect:v1.0.0 /usr/sbin/init</span><br><span class="line"><span class="meta">#</span><span class="bash"> vnc 默认密码: root/root_123</span></span><br></pre></td></tr></table></figure><h2 id="后言"><a href="#后言" class="headerlink" title="后言"></a>后言</h2><p>坚信搞好属于自己的一套开发环境是学习任何新技术的基础，工欲善其事，必先利其器</p><p>这篇博客也仅仅是将个人习惯的开发环境 分享一下，每个人肯定都有自己的习惯，不存在谁比谁更好，只要能达到自己想要的学习效果，都是好方法。开发镜像也是，IDE 也是，开发语言也是。总是陷入对 世界上最好语言的争论，真的没必要</p><p>当然，在自己整完这些东西之后，再次感觉到 应该喘口气，思考自己想做的下个东西是什么了</p><h2 id="资料"><a href="#资料" class="headerlink" title="资料"></a>资料</h2><p>[1] <a href="https://zhuanlan.zhihu.com/p/421375012">使用 Docker 快速部署 Spark + Hadoop 大数据集群</a></p><p>[2] <a href="https://github.com/s1mplecc/spark-hadoop-docker">git-spark-hadoop-docker</a></p><p>[3] <a href="https://mp.weixin.qq.com/s/4wT_C4Qvywwmh1a9edktxA">通过 Docker Compose 本地启动 zk 集群</a></p><p>[4] <a href="https://github.com/dbeaver/dbeaver">dbeaver</a></p><p>[5] <a href="https://knox.apache.org/books/knox-1-6-0/user-guide.html">knox官方文档</a></p><p>[6] <a href="https://segmentfault.com/a/1190000038508026?utm_source=sf-similar-article">Hadoop集群的部署（二）</a></p><p>[7] <a href="https://smiecj.com/2022/06/10/easyconnect-centos/">EasyConnect 代理工具容器化运行</a></p><p>[8] <a href="https://hub.docker.com/r/mzsmieli/centos_dev_full">dev_full image</a></p><p>[9] <a href="https://github.com/docker/buildx">docker buildx</a></p>]]></content>
    
    
    <summary type="html">一次对大数据组件“容器化”的实践</summary>
    
    
    
    <category term="开发工具" scheme="http://smiecj.github.io/categories/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"/>
    
    <category term="Docker" scheme="http://smiecj.github.io/categories/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/Docker/"/>
    
    
    <category term="Linux" scheme="http://smiecj.github.io/tags/Linux/"/>
    
    <category term="Docker" scheme="http://smiecj.github.io/tags/Docker/"/>
    
    <category term="大数据" scheme="http://smiecj.github.io/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
  </entry>
  
  <entry>
    <title>EasyConnect 代理工具容器化运行</title>
    <link href="http://smiecj.github.io/2022/06/10/easyconnect-centos/"/>
    <id>http://smiecj.github.io/2022/06/10/easyconnect-centos/</id>
    <published>2022-06-09T16:00:00.000Z</published>
    <updated>2022-06-09T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://mp.weixin.qq.com/s/r1pOM7CoSMx4-L2GVqNoxg">公众号</a><br><a href="https://blog.csdn.net/xiaoliizi/article/details/125231965">csdn</a></p><h2 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h2><p>目前代理镜像已提交到 dockerhub，可直接使用</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker pull mzsmieli/centos_easyconnect:v1.0.0</span><br><span class="line">docker run -it -d --privileged=true --platform linux/amd64 --hostname test_ec --name dev_ec -p 3389:3389 -p 7881:7881 mzsmieli/centos_easyconnect:v1.0.0 /usr/sbin/init</span><br><span class="line"><span class="meta">#</span><span class="bash"> vnc 默认密码: root/root_123</span></span><br></pre></td></tr></table></figure><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p><strong>EasyConnect</strong> 作为很多国内公司和学校用的代理软件，对上班族和学生党来说还是经常用到的。但是作为一个商用代理软件 ，EasyConnect 并没有开源，而且代理是系统级别的，主机的所有流量都会经过被 EC 进程代理。你也不知道它劫持了流量之后到底做了啥</p><p>偶然一天了解到有人已经通过 虚拟机方式 成功启动 easyConnect（git-hagb-docker-easyconnect[1]），相当于把 EasyConnect 运行在一个完全独立的环境，对流量安全来说确实是更好的。只是适配Arm 系统会有一些问题，比如内存占用太高，作者也提供了一些解决思路，不过需要使用者自行尝试</p><p>所以一不做二不休，自己动手尝试了使用 centos 系统封装 EasyConnect，并成功测试只让公司流量走 EC 代理。比较不足的点也就是手动配置有一定成本。不过从结果来看还是不错的，至少动手过程中也了解到了一些技术点，最后也写下了这篇博客让大家都可以参考快速配置一下</p><p>最后谈一下使用建议：如果你是学生党，那比较推荐通过开源项目 docker-easyconnect 来开启代理，主要是能够少折腾</p><p>但如果你是上班族，那就建议自己鼓捣一下。本文提供的思路应该是一个不错的选择，原理和开源项目也差不多</p><p>环境说明：<br>主机: Docker Desktop on Mac<br>基础镜像: centos 8（platform: amd64）<br>容器内安装的软件: EasyConnect 麒麟系统版本（兼容 centos）、firefox、clash、xrdp（提供远程桌面，用于打开 EasyConnect 并登录）</p><h2 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h2><h3 id="构建镜像"><a href="#构建镜像" class="headerlink" title="构建镜像"></a>构建镜像</h3><p>这边把用于代理的镜像构建过程提交到 (git-docker-centos-ec.Dockerfile[2]) 了，拉取代码后即可构建</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># 构建镜像</span></span></span><br><span class="line">make build_xrdp</span><br><span class="line"></span><br><span class="line">make build_ec</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># 运行</span></span></span><br><span class="line">make run_ec</span><br></pre></td></tr></table></figure><h3 id="启动容器和服务"><a href="#启动容器和服务" class="headerlink" title="启动容器和服务"></a>启动容器和服务</h3><p><img src="/2022/06/10/easyconnect-centos/ec05.png" alt="login ec"></p><p><img src="/2022/06/10/easyconnect-centos/ec06.png" alt="clash"></p><p><img src="/2022/06/10/easyconnect-centos/ec07.png" alt="内网服务"></p><p>下面具体说一下是怎么实现的</p><h2 id="centos-系统初始化"><a href="#centos-系统初始化" class="headerlink" title="centos 系统初始化"></a>centos 系统初始化</h2><h3 id="安装远程桌面"><a href="#安装远程桌面" class="headerlink" title="安装远程桌面"></a>安装远程桌面</h3><p>桌面的主要目的是登录 EC，EC 必须通过界面 输入公司域账号密码登录<br>Linux 常见的远程桌面软件有 <strong>xrdp</strong> 和 <strong>vnc</strong> ，这边使用 xrdp 进行安装和连接</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 安装 xrdp</span></span><br><span class="line">yum -y install xrdp</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 安装 xfce</span></span><br><span class="line">yum -y groupinstall Xfce</span><br><span class="line"></span><br><span class="line">echo &quot;xfce4-session&quot; &gt; ~/.Xclients</span><br><span class="line">chmod +x ~/.Xclients</span><br><span class="line"></span><br><span class="line">systemctl enable xrdp</span><br><span class="line">systemctl start xrdp</span><br></pre></td></tr></table></figure><p>Mac 和 Windows 系统都可以通过 <strong>Microsoft Remote Desktop</strong> 连接<br><img src="/2022/06/10/easyconnect-centos/ec02.png" alt="connect"></p><p><img src="/2022/06/10/easyconnect-centos/ec03.png" alt="desktop"></p><p>windows 系统有一点特殊: 通过 127.0.0.1 连接本地会提示 “原因是你正在运行一个控制台会话” ，需要连接 <strong>127.0.0.2</strong> ，本质上这两个 ip 都是本机地址</p><h3 id="可选-firefox"><a href="#可选-firefox" class="headerlink" title="可选-firefox"></a>可选-firefox</h3><p>这里装浏览器只是用来测试容器内代理是否生效。安装了 clash 之后也可以在主机测试代理，可以不装<br>chrome([3]) 和 firefox([4]) 这种主流的浏览器都支持在 centos 上安装。我一开始装的 chrome 但是重启过容器之后就发现打不开了。可能是 chrome 太吃内存导致起不来，后面换 firefox 就没遇到这个问题</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 下载 firefox，解压后直接打开 ./firefox/firefox 即可</span></span><br><span class="line">wget https://download-installer.cdn.mozilla.net/pub/firefox/releases/101.0/linux-x86_64/en-US/firefox-101.0.tar.bz2</span><br><span class="line">tar -jxvf firefox-101.0.tar.bz2</span><br></pre></td></tr></table></figure><h2 id="EasyConnect"><a href="#EasyConnect" class="headerlink" title="EasyConnect"></a>EasyConnect</h2><p>在容器内安装 EC 也不是特别复杂，选对和系统匹配的版本就行</p><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 下载 &amp; 安装</span></span><br><span class="line">wget http://download.sangfor.com.cn/download/product/sslvpn/pkg/linux_767/EasyConnect_x64_7_6_7_3.rpm</span><br><span class="line">rpm -ivh EasyConnect_x64_7_6_7_3.rpm</span><br></pre></td></tr></table></figure><p>安装后会自动配置成开机启动，你也能通过 ps 看到 <strong>ECAgent</strong> 和 <strong>EasyMonitor</strong> 进程，分别是流量代理 和 自监控服务</p><p><img src="/2022/06/10/easyconnect-centos/ec04.png" alt="ec process"></p><p>其中 <strong>qemu</strong> 可以理解为虚拟化的实现接口，适配 Mac Arm 系列。还有其他实现方式，对应不同的虚拟机软件，比如 vmware、hyper-v 等</p><h3 id="ECAgent-进程定期强制清理"><a href="#ECAgent-进程定期强制清理" class="headerlink" title="ECAgent 进程定期强制清理"></a>ECAgent 进程定期强制清理</h3><p>通过 qemu 启动的 EC 会有内存泄漏的问题：随着运行容器的内存占用越来越大。这个问题可以参考 Hagb 作者对部分 issue 的回复([5])。彻底解决可能需要修改系统调用，简单解决的话，写个 crontab 定期清理 ECAgent 就行，ECMonitor 会自动把它拉起来，这些都是 EasyConnect 自带的进程</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 每个小时重启一次 ECAgent 进程</span></span><br><span class="line">RUN echo &quot;0 * * * * nohup ps -ef | grep ECAgent | grep -v grep | awk &#x27;&#123;print $2&#125;&#x27; | xargs  kill -9&quot; &gt;&gt; /var/spool/cron/root</span><br></pre></td></tr></table></figure><h2 id="Clash"><a href="#Clash" class="headerlink" title="Clash"></a>Clash</h2><p>把 EC 通过 容器启动起来之后，我们就完成了大头了。接下来的关键就是要分别在容器和主机开启代理，将公司内网的流量指向容器内，非公司内网流量还是正常走。这样才能让主机正常的流量不被 EC 劫持<br>clash 的完整配置可参考官方wiki([6])</p><h3 id="容器内部-服务端"><a href="#容器内部-服务端" class="headerlink" title="容器内部-服务端"></a>容器内部-服务端</h3><p>安装 linux 版本的 <strong>clash</strong> 并设置 sock5 代理端口作为服务端即可，对应前面 启动容器 开放的 7881 端口</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 下载 clash linux 版</span></span><br><span class="line">wget https://github.com/Dreamacro/clash/releases/download/v1.10.6/clash-linux-amd64-v1.10.6.gz</span><br><span class="line">gzip -d clash-linux-amd64-v1.10.6.gz &amp;&amp; mv clash-linux-amd64-v1.10.6 clash &amp;&amp; chmod +x clash</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 启动方式</span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># 第一次启动需要下载国家名称和位置信息(https://cdn.jsdelivr.net/gh/Dreamacro/maxmind-geoip@release/Country.mmdb)，启动会比较慢</span></span></span><br><span class="line">./clash -d .</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> config.yaml, 需要和 clash 可执行文件放到同一个目录</span></span><br><span class="line">mixed-port: 7890</span><br><span class="line">external-controller: 127.0.0.1:9090</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># 这三个配置对应 sock5 代理地址</span></span></span><br><span class="line">allow-lan: true</span><br><span class="line">bind-address: 0.0.0.0</span><br><span class="line">socks-port: 7881</span><br></pre></td></tr></table></figure><h3 id="主机-客户端"><a href="#主机-客户端" class="headerlink" title="主机-客户端"></a>主机-客户端</h3><p>以域名作为规则，配置转发规则 + 转发目标端口即可</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">proxies:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">socks5_ec</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">socks5</span></span><br><span class="line">    <span class="attr">server:</span> <span class="string">localhost</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">7881</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># proxy 分组，只用于展示</span></span><br><span class="line"><span class="attr">proxy-groups:</span></span><br><span class="line">  <span class="string">......</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 规则配置，特定域名转发到对应 proxy</span></span><br><span class="line"><span class="attr">rules:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,内网域名,socks5_ec</span></span><br><span class="line">  <span class="string">......</span></span><br></pre></td></tr></table></figure><p>另外 git 、ssh 的协议还需要单独在 ~/.ssh/config 中 配置转发规则</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> vim ~/.ssh/config</span></span><br><span class="line">Host *内网域名</span><br><span class="line">  ProxyCommand nc -x localhost:主机的sock代理端口 %h %p</span><br></pre></td></tr></table></figure><h3 id="其他配置-容器内部-etc-hosts"><a href="#其他配置-容器内部-etc-hosts" class="headerlink" title="其他配置-容器内部-/etc/hosts"></a>其他配置-容器内部-/etc/hosts</h3><p>后面调试的时候发现部分内网域名无法正常代理，大概率是 <strong>DNS</strong> 的问题: EC 装在主机的时候，<strong>主机的 DNS 被注入了内网解析的策略</strong>，诸如 gitlab.公司内网域名 这种地址，才能被正常解析。但是通过 主机 -&gt; 容器 -&gt; clash -&gt; EC 的方式，DNS 似乎就没有被注入策略，需要手动配置 /etc/hosts，将域名和 ip 的关系硬写进去才行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># /etc/hosts</span><br><span class="line"># git</span><br><span class="line">内网ip gitlab.内网域名.com</span><br><span class="line">......</span><br></pre></td></tr></table></figure><h2 id="主机-EC-卸载"><a href="#主机-EC-卸载" class="headerlink" title="主机 EC 卸载"></a>主机 EC 卸载</h2><p>网上有不少人说EC很难卸载干净，实际尝试确实如此，需要好几步，好在已经有人整理了([7])，参考着来做就行</p><p>卸载前: 即便主机没有开代理，都有三个进程在后台运行<br>– ECAgentProxy 在 Linux 版本的 EC 上没有这个进程，不确定是做啥的</p><p><img src="/2022/06/10/easyconnect-centos/ec08.png" alt="ec process on mac"></p><p>卸载步骤:</p><ul><li><p>sudo su 进入管理员模式</p></li><li><p>删除 /Library/LaunchDaemons/com.sangfor.EasyMonitor.plist</p></li></ul><p>其中 <strong>plist</strong>([8]) 是 Mac 系统用来设置启动项的工具，相当于 linux 的 systemd<br>这里相当于删除了 EC 的开机启动项</p><p><img src="/2022/06/10/easyconnect-centos/ec09.png" alt="ECMonitor"><br>– ECMonitor 启动项，声明了启动程序位置</p><ul><li><p>删除 /Library/LaunchAgents/com.sangfor.ECAgentProxy.plist</p></li><li><p>打开钥匙串，找到深信服添加的根证书(搜索 sang)，删除</p></li></ul><p><img src="/2022/06/10/easyconnect-centos/ec10.png" alt="删除钥匙串"></p><ul><li>删除应用<br>直接删除 /Applications/EasyConnect.app 整个目录即可</li></ul><p>Windows 系统的卸载方式可以参考 Hagb 作者写的知乎([9])</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>做完了这些东西，还是很有成就感的，有一种看上去非常朴素的乐高，但稍加想象力和努力，就能够拼成各种建筑，而且过程中也能学到很多东西</p><p>还要特别感谢一个同事，平时他总能有各种意想不到的点子，经常关注新软件和新技术。这个需求的灵感也是来自于他</p><p>总之，对一些软件对系统不合理的侵入，确实应该想办法解决。现在已经不是资源吃紧的时代了，电脑卡往往有一部分原因是使用者没有注意一些细节。从一开始就杜绝软件对系统权限、流量、文件不合理的申请或使用，会比后面回过头再清理方便太多</p><p>希望后面还能发现更多软件的问题，多解决多总结~</p><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><p>[1] <a href="https://github.com/Hagb/docker-easyconnect">开源方案</a></p><p>[2] <a href="https://github.com/smiecj/docker-centos/blob/main/Dockerfiles/net/ec/easyconnect.Dockerfile">docker-centos easyconnect.Dockerfile</a></p><p>[3] <a href="https://segmentfault.com/a/1190000022425145">CentOS 7安装谷歌浏览器</a></p><p>[4] <a href="https://linuxconfig.org/how-to-install-firefox-on-redhat-8">How to install latest Firefox browser on RHEL 8 / CentOS 8 Workstation</a></p><p>[5] <a href="https://github.com/Hagb/docker-easyconnect/issues/120#issue-1148054348">issue-MAC M1 pro是否有合适的版本 #120</a></p><p>[6] <a href="https://github.com/Dreamacro/clash/wiki/configuration">clash官方配置教程</a></p><p>[7] <a href="https://www.v2ex.com/t/762221">Mac 删除深信服 EasyConnect 的 EasyMoniter、ECAgent 的开机启动和根证书的方法</a></p><p>[8] <a href="https://www.fythonfang.com/blog/2021/4/19/mac-launchd-daemons-and-agents-tutorial">Mac Launchd 介绍和使用</a></p><p>[9] <a href="https://zhuanlan.zhihu.com/p/389894063">用docker封印EasyConnect并连接远程桌面和数据库</a></p><p>[10] <a href="https://superuser.com/a/1500416">RDP to computer from same computer fails. Why?</a></p>]]></content>
    
    
    <summary type="html">网络隔离是更安全的选择</summary>
    
    
    
    <category term="开发工具" scheme="http://smiecj.github.io/categories/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"/>
    
    <category term="代理" scheme="http://smiecj.github.io/categories/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/%E4%BB%A3%E7%90%86/"/>
    
    
    <category term="docker" scheme="http://smiecj.github.io/tags/docker/"/>
    
    <category term="开发工具" scheme="http://smiecj.github.io/tags/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"/>
    
    <category term="代理" scheme="http://smiecj.github.io/tags/%E4%BB%A3%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>vscode 使用技巧闲谈</title>
    <link href="http://smiecj.github.io/2022/05/31/vscode-tools/"/>
    <id>http://smiecj.github.io/2022/05/31/vscode-tools/</id>
    <published>2022-05-30T16:00:00.000Z</published>
    <updated>2022-05-30T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="关于-vscode"><a href="#关于-vscode" class="headerlink" title="关于 vscode"></a>关于 vscode</h2><p>如果我们对一个开发者问你平时 <strong>首选 IDE</strong> 是什么，不同语言的开发者估计回答都会不太一样。对于后台来说，近几年比较热门的无疑就是 <strong>Jetbrains</strong> 全家桶系列了，java 用 Idea，go 用 goland，Python 用 PyCharm，体验本身无疑是很棒的。前端开发选择 vscode 就比较多了，主要原因可能是插件支持更完善，而且 vscode 本身就是用 TypeScript 写的。当然还有一些在几年前辉煌过的 Eclipse、Visual Studio Code 等，在一些特定的开发场景还是有一席之地的</p><p>那么自己作为后台开发，为什么自己要“反其道而行之” 选择 vscode 呢，主要有两个原因:</p><ul><li>自己的开发环境并不在本地宿主机，而是在容器内（参考: 仓库 docker-centos），要用容器环境一个最直接的方式就是类似连接远程机器那样，用 ssh remote，而目前来说 vscode 对这种模式支持比较好（也和 vscode 的插件机制相关，插件相当于开发环境，可以安装到远程机器，天生就对这种开发模式适配较好）</li><li>工作和个人习惯相关，需要经常<strong>在不同的开发环境之间切换</strong>，比如这会需要跑一个 golang 后台服务，过了几分钟突然一个 java 相关的需求来了。如果用 JetBrain 全家桶，就必须在不同软件（虽然操作逻辑类似）之间切换。而用 vscode 就不需要来回切换操作逻辑，很顺手</li></ul><p>讲到这里，也要提提 vscode + ssh remote 这种模式的缺点</p><ul><li>性能不如主机模式<br>如果是本机开发，其实直接用 <strong>JetBrains</strong> 就够了， 相当于直接用本地环境，比用容器开发肯定性能会好很多。像我现在开发的时候，电脑主机内存占用60-70算是家常便饭</li><li>熟练门槛高<br>对于我现在的开发模式来说除了本身的开发语言之外，还需要了解一些Docker相关的基本操作，还有 vscode 的快捷键（这个非常重要，说他是 vscode 的灵魂也不为过，快捷键用的少开发效率直接减半）、各个开发语言的插件和配置等</li><li>特定编程语言下功能不如 Jetbrains 系列<br>比如 Idea 可以直接下载和查看源码，vscode 只能查看编译后的 class 文件（虽然也是代码格式，但是少了注释，读开源项目的时候还是比较费劲）</li></ul><p>因此这篇文章依然算是<strong>安利</strong>的，比较实用的干货的地方，就是结合自己的经验推荐一下好用的 vscode 插件了。至于其他的技巧，就得看个人的使用习惯，我的方法也不一定适用于其他人</p><p>如果你觉得上面使用 vscode 的好处，比较契合自己的习惯，而且不太在乎其带来的影响，那么就可以动手尝试一下了。当然有使用上的感想也欢迎和我私信交流</p><p><img src="/2022/05/31/vscode-tools/vscode15.png" alt="show"></p><h2 id="常用快捷键"><a href="#常用快捷键" class="headerlink" title="常用快捷键"></a>常用快捷键</h2><p>注意: 一些键位我是改过的，因此还是要看个人习惯</p><table><thead><tr><th>快捷键</th><th>功能</th></tr></thead><tbody><tr><td>Command + Control + &lt;-</td><td>跳转到上一个位置</td></tr><tr><td>Command + Control + -&gt;</td><td>跳转到上一个位置</td></tr><tr><td>Control + `</td><td>打开终端</td></tr><tr><td>Command + Shift + P</td><td>插件功能列表</td></tr><tr><td>Command + Shift + F</td><td>全局搜索</td></tr><tr><td>Command + Shift + O</td><td>当前文件/类的所有方法</td></tr><tr><td>Command + P</td><td>打开当前项目的指定文件</td></tr><tr><td>Command + R</td><td>打开最近项目</td></tr><tr><td>Control + G</td><td>跳到指定行</td></tr><tr><td>F5</td><td>开始 debug</td></tr><tr><td>Shift + F5</td><td>结束 debug</td></tr></tbody></table><h2 id="ssh-remote"><a href="#ssh-remote" class="headerlink" title="ssh remote"></a>ssh remote</h2><h3 id="插件安装"><a href="#插件安装" class="headerlink" title="插件安装"></a>插件安装</h3><p><img src="/2022/05/31/vscode-tools/vscode01.png" alt="ssh remote plugin"></p><h3 id="开发环境准备"><a href="#开发环境准备" class="headerlink" title="开发环境准备"></a>开发环境准备</h3><p>开发环境可以是一个远程宿主机，也可以是你本地的 container 环境<br>这里还是以 容器环境为例</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 启动容器</span><br><span class="line">docker run -d --hostname dev --name dev -p 2000:22 centos_dev_full</span><br></pre></td></tr></table></figure><p>连接开发机</p><p><img src="/2022/05/31/vscode-tools/vscode02.png" alt="ssh remote connect"></p><p>输入账号密码之后，就可以顺利进行 vscode + ssh remote 模式开发了。不过体验上我们还可以继续优化一下</p><h3 id="ssh-key"><a href="#ssh-key" class="headerlink" title="ssh key"></a>ssh key</h3><p>如果不配置免密登录，每次打开一个新项目（新的代码地址），都需要输入一次，下次打开也还要，非常麻烦<br>所以这里我们把主机的公钥配置到开发机的 ~/.ssh/authorized_keys 中，后续不再输入密码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># linux 生成公钥</span><br><span class="line">ssh-keygen</span><br><span class="line"></span><br><span class="line"># 查看公钥</span><br><span class="line">cat ~/.ssh/id_rsa.pub</span><br><span class="line"></span><br><span class="line"># 将公钥写入服务端受信公钥列表上</span><br><span class="line">echo &quot;公钥&quot; &gt;&gt; ~/.ssh/authorized_keys</span><br></pre></td></tr></table></figure><h3 id="git-key"><a href="#git-key" class="headerlink" title="git key"></a>git key</h3><p>还有一个需要频繁输入密码的场景，就是使用git，为了方便我们按照配置ssh 免密类似的方式配一下，把主机生成的 ssh 公钥配置到 git 上</p><p>github: **settings -&gt; ssh and GPG keys **</p><p><img src="/2022/05/31/vscode-tools/vscode03.png" alt="ssh key github"></p><p>gitee: <strong>设置 -&gt; ssh 公钥</strong></p><p><img src="/2022/05/31/vscode-tools/vscode04.png" alt="ssh key gitee"></p><h2 id="各开发环境常用插件"><a href="#各开发环境常用插件" class="headerlink" title="各开发环境常用插件"></a>各开发环境常用插件</h2><h3 id="java"><a href="#java" class="headerlink" title="java"></a>java</h3><h4 id="Extension-Pack-for-Java"><a href="#Extension-Pack-for-Java" class="headerlink" title="Extension Pack for Java"></a>Extension Pack for Java</h4><p><img src="/2022/05/31/vscode-tools/vscode16.png" alt="java extension"></p><p>注意新版本的插件要求运行环境是 JDK11, 所以如果你的主力项目用的是 JDK8 ，还需要给开发机额外装 JDK11，另外环境变量也要配对</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># /etc/profile</span><br><span class="line">export JAVA_HOME=/usr/java/jdk8路径</span><br><span class="line">export JRE_HOME=$JAVA_HOME/jre</span><br><span class="line">export CLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar:$JRE_HOME/lib</span><br><span class="line">export JDK_HOME=/usr/java/jdk-11.0.14.1+1</span><br><span class="line">export PATH=$PATH:$JAVA_HOME/bin:$JRE_HOME/bin:$MAVEN_HOME/bin:$GRADLE_HOME/bin</span><br></pre></td></tr></table></figure><p>这些配置之前还提过 issue 专门问过开发者，最后解决的，亲自试验没问题</p><p>另外项目也要显式说明使用的 JDK 版本，maven 和 gradle 配置如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># pom.xml</span><br><span class="line">## 注意: 不同的 module 对应的 pom.xml, 都需要加上这个配置</span><br><span class="line">    &lt;properties&gt;</span><br><span class="line">        &lt;maven.compiler.source&gt;1.8&lt;/maven.compiler.source&gt;</span><br><span class="line">        &lt;maven.compiler.target&gt;1.8&lt;/maven.compiler.target&gt;</span><br><span class="line">    &lt;/properties&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># build.gradle</span><br><span class="line">  plugins.withType(JavaPlugin) &#123;</span><br><span class="line">    sourceCompatibility = 1.8</span><br><span class="line">    targetCompatibility = 1.8</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>最后打开 <strong>Java: Configure Java Runtime</strong>, 确认项目所使用的 JDK 版本是准确的</p><p><img src="/2022/05/31/vscode-tools/vscode17.png" alt="java runtime"></p><h4 id="maven"><a href="#maven" class="headerlink" title="maven"></a>maven</h4><p>maven 插件在上面装的插件包中自带了，但是有个很奇怪的问题: 插件无法按照 maven 安装路径 /conf/settings.xml 来读取配置，因此诸如本地依赖路径、配置文件路径都会按默认方式从 ~/.m2 路径读取。建议在初始化开发环境的时候配置一个软链指向实际路径，防止通过 maven 下载的依赖包存放在不同路径，造成空间浪费</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 创建配置和依赖路径软链</span><br><span class="line">mkdir -p ~/.m2 &amp;&amp; ln -s /本地maven 仓库地址 ~/.m2/repository &amp;&amp; ln -s /maven安装路径/conf/settings.xml ~/.m2/settings.xml</span><br></pre></td></tr></table></figure><p>或者手动修改插件 <a href="https://github.com/microsoft/vscode-maven#settings">maven.settingsFile</a> 配置，不过有点麻烦，不建议这么做</p><h4 id="gradle"><a href="#gradle" class="headerlink" title="gradle"></a>gradle</h4><p>gradle 插件需要另外下载: Gradle Extension Pack</p><p><img src="/2022/05/31/vscode-tools/vscode06.png" alt="gradle extension"></p><h4 id="formatter"><a href="#formatter" class="headerlink" title="formatter"></a>formatter</h4><p>设置 formatter 工具: 打开插件功能列表(command + shift + P), 选择 <strong>Open Java Format Settings With Preview</strong><br>第一次会提示还未设置，可以直接用默认的，也可以直接修改 .vscode/settings.json 设置用谷歌的formatter</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># .vscode/settings.json</span><br><span class="line">&quot;java.format.settings.url&quot;: &quot;https://raw.githubusercontent.com/google/styleguide/gh-pages/eclipse-java-google-style.xml&quot;,</span><br><span class="line">&quot;java.format.settings.profile&quot;: &quot;GoogleStyle&quot;</span><br></pre></td></tr></table></figure><h4 id="lombok"><a href="#lombok" class="headerlink" title="lombok"></a>lombok</h4><p>和 Idea 类似，lombok 要想在编写过程中让注解直接生效，也需要额外的机制: 插件: <strong>Lombok Annotations Support for VS Code</strong></p><p><img src="/2022/05/31/vscode-tools/vscode07.png" alt="lombok"></p><h3 id="golang"><a href="#golang" class="headerlink" title="golang"></a>golang</h3><h4 id="go"><a href="#go" class="headerlink" title="go"></a>go</h4><p>Golang 官方的插件装完之后，在代码编辑这块功能都已经很完备了，装好之后包括测试执行、formatter 等功能都有</p><p><img src="/2022/05/31/vscode-tools/vscode08.png" alt="go"></p><p><img src="/2022/05/31/vscode-tools/vscode09.png" alt="安装过程"></p><p>不过关于测试的参数这里，默认的配置往往不符合我们要求。需要额外设置超时时间，打印日志，取消测试缓存等<br><img src="/2022/05/31/vscode-tools/vscode10.png" alt="vscode-go-setting"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># .vscode/settings.json</span><br><span class="line">&quot;go.testFlags&quot;: [</span><br><span class="line">    &quot;-v&quot;,</span><br><span class="line">    &quot;-count=1&quot;,</span><br><span class="line">    &quot;-timeout=300s&quot;</span><br><span class="line">],</span><br></pre></td></tr></table></figure><h3 id="python"><a href="#python" class="headerlink" title="python"></a>python</h3><h4 id="python-1"><a href="#python-1" class="headerlink" title="python"></a>python</h4><p><img src="/2022/05/31/vscode-tools/vscode11.png" alt="python"></p><p>如果你的开发机上安装了多套 python，可通过 <strong>Python: Select Interpreter</strong> 进行切换</p><p><img src="/2022/05/31/vscode-tools/vscode13.png" alt="python interpreter"></p><h4 id="formatter-1"><a href="#formatter-1" class="headerlink" title="formatter"></a>formatter</h4><p>推荐 flake8，默认的 pylint 要求有点过于严格</p><p>打开插件功能列表，搜索 <strong>Python: Select Linter</strong> 并选择 flake8，第一次选择后提示安装即可</p><p>自动 format: black</p><p>在插件配置中搜索: <strong>python formatting provider</strong></p><p><img src="/2022/05/31/vscode-tools/vscode12.png" alt="black"></p><h3 id="markdown"><a href="#markdown" class="headerlink" title="markdown"></a>markdown</h3><p>插件名: <strong>Markdown All in One</strong><br>在写 readme 的时候还是非常好用的，可以直接看到效果: 打开 Markdown: open preview, 并把 preview 并把窗口拖到右边即可</p><p><img src="/2022/05/31/vscode-tools/vscode05.png" alt="markdown"></p><p><img src="/2022/05/31/vscode-tools/vscode14.png" alt="markdown preview"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>使用 vscode 很长一段时间回头看，插件功能确实很强大，自己现在用到的也只是万众插件中的冰山一角，希望后面有什么新的感受可以再补充一下</p><p>最后就希望自己每天都能像今天过节一样吧～</p><h2 id="引用资料"><a href="#引用资料" class="headerlink" title="引用资料"></a>引用资料</h2><p><a href="https://www.zhihu.com/question/322952427">如何评价 VS Code Remote Development？</a></p><p><a href="https://www.zhihu.com/question/304808444">讨论-买Jetbrains全家桶的都是什么人？</a></p><p><a href="https://www.v2ex.com/t/565476">讨论-IDEA 和 vscode 比较介绍，推荐那个？</a></p><p><a href="https://code.visualstudio.com/docs/java/java-linting">vscode官方-Java formatting and linting</a></p><p><a href="https://v2ex.com/t/587696">v2ex-大家在自己的 Python 项目中倾向使用哪个 Linter？</a></p>]]></content>
    
    
    <summary type="html">插件化的体验</summary>
    
    
    
    <category term="开发工具" scheme="http://smiecj.github.io/categories/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"/>
    
    <category term="vscode" scheme="http://smiecj.github.io/categories/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/vscode/"/>
    
    
    <category term="开发工具" scheme="http://smiecj.github.io/tags/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"/>
    
    <category term="vscode" scheme="http://smiecj.github.io/tags/vscode/"/>
    
  </entry>
  
  <entry>
    <title>通过 Docker Compose 本地启动 zk 集群</title>
    <link href="http://smiecj.github.io/2022/05/18/dockerfile-compose/"/>
    <id>http://smiecj.github.io/2022/05/18/dockerfile-compose/</id>
    <published>2022-05-17T16:00:00.000Z</published>
    <updated>2022-05-17T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="项目"><a href="#项目" class="headerlink" title="项目"></a>项目</h2><p>如果你想直接看代码，可以直接看我的 <a href="https://github.com/smiecj/docker-centos">git-docker-centos</a> 项目地址，最近发布了 <a href="https://github.com/smiecj/docker-centos/releases/tag/v1.2.0">v1.2.0</a> 版本，readme 已经非常详细了，包括项目的使用方式 和 需求规划</p><p>本机环境基本只依赖 Docker 的安装，Docker Desktop 的安装教程可参考我之前的<a href="https://mp.weixin.qq.com/s/zmkzhIdL7Da_sfNauhAGRQ">博客-Docker Desktop 安装方式和开发镜像分享</a>，当然，更详细的教程网上一搜有一堆</p><p><a href="https://blog.csdn.net/xiaoliizi/article/details/124838563">csdn 博客地址</a><br><a href="https://mp.weixin.qq.com/s/4wT_C4Qvywwmh1a9edktxA">公众号博客地址</a></p><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>之前已经大致将自己平时开发用到的服务和环境，都打包到了 Dockerfile 中，可在本机进行开发环境和基础组件的一键部署。后续自己也进行一些改进，减少了仓库中的shell 脚本文件，整体安装逻辑会更加直观</p><p><a href="https://mp.weixin.qq.com/s/BrtGVdtIhv1SoM-KZ1hZCQ">关于我为什么要封装自己的 Dockerfile</a></p><p>这个项目当时做到这里就感觉算是完成了一个不小的目标，但随着自己用这个项目的深入，总感觉还差点意思，比如 zk 只能部署一个节点，集群的话需要写三个（对应三个节点）很长的 docker run 指令，加一堆参数（主要是注入 zk 本身的配置），根本没法记，只能放到电脑笔记中，每次拷贝粘贴，非常不方便</p><p>给人的感觉，有点像微信的公众号，本来机制是很好的，实时的新闻也有，沉淀下来的技术博客也很多，但是用着用着就感觉没那么好用了，自己不想看的东西越来越多，想要的文章自己又看不到。<strong>好的工具却不能提升学习的效率，类似这种感觉</strong></p><p>另外还有一个小小的痛点: nacos 作为阿里开源的配置管理服务，官方仓库确实已经很完善了，代码在 <a href="https://github.com/alibaba/nacos">nacos 仓库</a>，容器化部署相关的配置文件放到 <a href="https://github.com/nacos-group/nacos-docker">nacos-docker</a>，分得很细。但是官方提供的 <a href="https://github.com/nacos-group/nacos-docker/blob/master/example/standalone-mysql-5.7.yaml">standalone-mysql-5.7.yaml</a> <strong>单机部署配置文件中使用的 nacos 和 mysql 镜像不兼容 Mac M1 系统</strong>。官方也有对应的 issue，但是到发这篇博客的时候，官方还未解决</p><p>直到有一天通过 k8s 接触到了 其他管理容器集群的工具，其中 <strong>swarm</strong> 就是通过 compose 管理集群的，突然意识到 <strong>docker-compose</strong> 这个工具应该是比较切合我的需求</p><p>主要的原因，就是 对比 <strong>Kubernetes</strong> 来说：k8s 自成一套体系，也牵扯到很多其他技术栈，对初学者来说需要花很多时间去掌握。但是 Compose 其实还是基于 Docker 的基本指令，它对应的配置文件，其实就对应了 Docker 的指令或者参数，对熟悉 Docker 指令的同学来说肯定非常好上手</p><p>那还多说什么呢？直接参考官方文档，实践起来</p><h2 id="最终效果"><a href="#最终效果" class="headerlink" title="最终效果"></a>最终效果</h2><p>Compose 这块实现了 zk 集群 和 nacos 服务（依赖 mysql），直接看效果</p><h3 id="启动-zk-集群"><a href="#启动-zk-集群" class="headerlink" title="启动 zk 集群"></a>启动 zk 集群</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 构建操作系统基础镜像</span></span><br><span class="line">make build_base</span><br><span class="line"></span><br><span class="line"><span class="comment"># 构建 java 开发镜像</span></span><br><span class="line">make build_dev_java</span><br><span class="line"></span><br><span class="line"><span class="comment"># 构建 zookeeper 镜像</span></span><br><span class="line">make build_zookeeper</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动 zk 集群</span></span><br><span class="line"><span class="comment">## 前面构建镜像都是一次性的，后面启动 zk 集群、启动 nacos 都不需要再重复构建</span></span><br><span class="line">make run_zookeeper_cluster</span><br></pre></td></tr></table></figure><p><img src="/2022/05/18/dockerfile-compose/compose01.png" alt="zk cluster"></p><h3 id="启动-nacos-服务"><a href="#启动-nacos-服务" class="headerlink" title="启动 nacos 服务"></a>启动 nacos 服务</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 构建 mysql 镜像</span></span><br><span class="line">make build_mysql</span><br><span class="line"></span><br><span class="line"><span class="comment"># 构建 nacos 镜像</span></span><br><span class="line">make build_nacos</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动 nacos 服务</span></span><br><span class="line">make run_nacos_mysql</span><br></pre></td></tr></table></figure><p><img src="/2022/05/18/dockerfile-compose/compose02.png" alt="nacos start"></p><p><img src="/2022/05/18/dockerfile-compose/compose03.png" alt="nacos web"></p><p>其中，nacos 服务启动 需要先构建 centos_base、centos_java、centos_nacos 和 centos_mysql 镜像，zk 集群启动需要先构建 centos_java、centos_zookeeper 镜像</p><p>第一次构建镜像的话，确实需要总的大概十几分钟的时间，比如 java 的基础镜像，需要先下载几百M 的 JDK，zookeeper 镜像的构建需要编译 zk，但是之后的开发过程就非常顺滑了，<strong>启动服务只需要几秒钟</strong>。这在之前直接使用 Docker 指令启动 zk 集群 还需要粘贴一堆指令，是无法想象的</p><h2 id="如何实现"><a href="#如何实现" class="headerlink" title="如何实现"></a>如何实现</h2><h3 id="技术栈"><a href="#技术栈" class="headerlink" title="技术栈"></a>技术栈</h3><p>容器技术：<strong>Docker、Docker Compose</strong></p><ul><li>熟悉 Docker 指令</li><li>了解和Docker 相关的术语，比如容器、镜像、Dockerfile 他们的用法</li><li>了解 Compose 基本用法</li></ul><p>后台开发：<strong>Java 语言，Zookeeper、Nacos、MySQL 等中间件</strong></p><ul><li>OpenJDK 安装</li><li>中间件安装</li></ul><p>脚本</p><ul><li>shell 基本语法</li></ul><h3 id="构建基础镜像"><a href="#构建基础镜像" class="headerlink" title="构建基础镜像"></a>构建基础镜像</h3><p>在通过 Compose 启动服务之前，我们需要把基础镜像先构建好<br>这里基础镜像可以分为三部分: </p><ul><li>操作系统基础镜像（centos_base）</li><li>开发环境基础镜像（如 Java 开发镜像）</li><li>组件镜像（centos_zookeeper）</li></ul><p>你可以理解为这是一个金字塔三角的结构，就好像你在电脑上安装各种软件，他们是最上层的服务（对应组件），然后软件需要运行在一些系统提供的基础环境中（比如红警在 win10 上跑就需要设置兼容性），最下面一层是操作系统</p><p>关于每个镜像里面安装的组件，我在项目的 <a href="https://github.com/smiecj/docker-centos/blob/main/README_zh.md">Readme</a> 文档中有具体说明</p><p><img src="/2022/05/18/dockerfile-compose/compose04.png" alt="一部分镜像"></p><h3 id="Compose-配置"><a href="#Compose-配置" class="headerlink" title="Compose 配置"></a>Compose 配置</h3><p>这里需要对 Compose 的使用方式有基本了解，对于熟悉 docker 的同学来说不会太难</p><p>举个例子：nacos+mysql 的 Compose 配置</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&quot;3.9&quot;</span></span><br><span class="line"><span class="comment"># 定义需要启动的服务，nacos 依赖 mysql, 因此需要定义nacos和mysql 两个服务</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">nacos:</span></span><br><span class="line">    <span class="comment"># 镜像名</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">centos_nacos</span></span><br><span class="line">    <span class="comment"># 启动容器的环境变量，对 nacos 来说，主要需要注入 mysql 的配置</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">MYSQL_HOST=mysql</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">MYSQL_PORT=3306</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">MYSQL_DB=d_nacos</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">MYSQL_USER=root</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">MYSQL_PASSWORD=root_NACOS_123</span></span><br><span class="line">    <span class="comment"># 暴露到主机的端口</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;8848:8848&quot;</span></span><br><span class="line">    <span class="comment"># 先启动 mysql 服务，再启动 nacos</span></span><br><span class="line">    <span class="attr">depends_on:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">mysql</span></span><br><span class="line">  <span class="attr">mysql:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">centos_mysql</span></span><br><span class="line">    <span class="comment"># 设置 mysql 登录密码，以及创建一个非默认DB</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">ROOT_PASSWORD=root_NACOS_123</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">USER_DB=d_nacos</span></span><br><span class="line">    <span class="comment"># 将当前路径挂载到 mysql 容器里面的特定目录(init_sql)</span></span><br><span class="line">    <span class="comment"># 这里有一个小功能实现: 让 mysql 在初始化的时候查找 init_sql 目录下所有 sql 文件 并 执行，为什么要这么实现在后面实现细节中会讲到</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;./:/home/modules/mysql/init_sql&quot;</span></span><br><span class="line"><span class="comment"># 创建一个 nacos 和 mysql 服务共用的网络环境</span></span><br><span class="line"><span class="attr">networks:</span></span><br><span class="line">  <span class="attr">my-nacos:</span></span><br></pre></td></tr></table></figure><h2 id="实现细节"><a href="#实现细节" class="headerlink" title="实现细节"></a>实现细节</h2><h3 id="s6"><a href="#s6" class="headerlink" title="s6"></a>s6</h3><p><a href="https://github.com/just-containers/s6-overlay">s6</a> 是为了适配容器化场景，针对各个芯片指令集平台都做了适配的 <strong>服务管理器</strong>，类似 systemctl</p><p>为什么要引入 s6，主要原因还是 systemctl 在 Mac M1 上不兼容，这个在git 上很多项目都有<a href="https://github.com/docker/for-mac/issues/6073">讨论</a>，其中使用 s6 就是一种解决方案，只是需要稍微做点适配</p><p>比如 mysql，不能使用 service mysql start 指令启动的情况下，就需要把服务启动指令以 s6 支持的方式，写好启动脚本，并在 Dockerfile 中增加注入 启动脚本 的逻辑了</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># centos_base.Dockerfile</span></span><br><span class="line"><span class="comment">## 设置系统启动后执行 /init 以启动 s6 进程</span></span><br><span class="line">ENTRYPOINT [<span class="string">&quot;/init&quot;</span>]</span><br></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># mysql.Dockerfile</span></span><br><span class="line">COPY s6/ /etc/</span><br></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># s6/services.d/mysql/run</span></span><br><span class="line"><span class="comment">#!/bin/bash</span></span><br><span class="line">/usr/sbin/mysqld --user=root</span><br></pre></td></tr></table></figure><h3 id="mysql-初始化时执行-sql"><a href="#mysql-初始化时执行-sql" class="headerlink" title="mysql 初始化时执行 sql"></a>mysql 初始化时执行 sql</h3><p>场景: 一开始我对 mysql Dockerfile 实现的功能只是一键启动，但是后面发现对 nacos 一键部署的场景，还需要支持 初始化时导入 nacos sql ，否则 nacos 无法正常启动</p><p>这其实也是 nacos 官方的 compose 配置所使用的 mysql 镜像是 nacos 官方仓库中的镜像的原因。<a href="https://hub.docker.com/r/mysql/mysql-server/dockerfile">mysql 官方 Dockerfile</a> 并不支持在初始化时执行 sql</p><p>所以这里对 mysql Dockerfile 实现了一个 加载并执行 指定目录下的 sql 文件的功能</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># init-mysql.sh</span></span><br><span class="line">......</span><br><span class="line"><span class="comment">## execute init sql</span></span><br><span class="line">sql_files=`ls -l &#123;mysql_init_sql_home&#125; | grep -E <span class="string">&quot;\.sql$&quot;</span> | sed <span class="string">&quot;s/.* //g&quot;</span> | tr <span class="string">&#x27;\n&#x27;</span> <span class="string">&#x27; &#x27;</span>`</span><br><span class="line"><span class="keyword">for</span> current_sql_file <span class="keyword">in</span> <span class="variable">$&#123;sql_files[@]&#125;</span></span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    mysql -uroot -p<span class="string">&quot;<span class="variable">$&#123;ROOT_PASSWORD&#125;</span>&quot;</span> -f -D<span class="variable">$&#123;USER_DB&#125;</span> &lt; &#123;mysql_init_sql_home&#125;/<span class="variable">$&#123;current_sql_file&#125;</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line">......</span><br></pre></td></tr></table></figure><h3 id="源替换"><a href="#源替换" class="headerlink" title="源替换"></a>源替换</h3><p>在国内网络条件下进行开发你需要解决的一个很基础的问题，就是代理服务器的问题，否则从外网下载开源组件安装包的速度，常常会让你抓狂<br>这里需要对两种场景分别解决:<br>对 yum 源、OpenJDK 下载等可以找到国内源 替换 国外地址 的话，直接替换下载地址就可以了</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># env_java.sh</span></span><br><span class="line"><span class="comment">## 使用清华源 mirrors.tuna.tsinghua.edu.cn，还是挺全的</span></span><br><span class="line">jdk_11_repo=<span class="string">&quot;https://mirrors.tuna.tsinghua.edu.cn/AdoptOpenJDK/11/jdk/x64/linux&quot;</span></span><br><span class="line">......</span><br><span class="line"></span><br><span class="line">jdk_8_repo=<span class="string">&quot;https://mirrors.tuna.tsinghua.edu.cn/AdoptOpenJDK/8/jdk/x64/linux&quot;</span></span><br><span class="line">......</span><br></pre></td></tr></table></figure><p>对不能找到国内源替换的情况，那就只能加快下载速度了，这里我本地有个代理，需要在镜像构建的时候配置到 环境变量 http_proxy 中去<br>默认 Docker 启动容器的网络模式（driver）下，内部识别到主机的代理地址一般是 host.docker.internal（Mac）或 172.26.16.1（Win10），对应容器内部网络的网关地址<br>所以做了一个循环逻辑，依次检测指定几个代理端口是否能通，通的话直接配置proxy的逻辑</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># init-system-proxy.sh, 构建 centos_base 镜像时会调用</span></span><br><span class="line"><span class="keyword">for</span> proxy_host <span class="keyword">in</span> <span class="variable">$&#123;proxy_host_array[@]&#125;</span></span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    <span class="keyword">for</span> proxy_port <span class="keyword">in</span> <span class="variable">$&#123;proxy_port_array[@]&#125;</span></span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">        <span class="comment">## telnet 一个通的地址很快，这里设置超时 1s</span></span><br><span class="line">        telnet_output=`timeout 1 telnet <span class="variable">$proxy_host</span> <span class="variable">$proxy_port</span> 2&gt;&amp;1` || <span class="literal">true</span></span><br><span class="line">        telnet_refused_msg=`<span class="built_in">echo</span> <span class="variable">$telnet_output</span> | grep <span class="string">&quot;Connection refused&quot;</span> || <span class="literal">true</span>`</span><br><span class="line">        telnet_host_unknown_msg=`<span class="built_in">echo</span> <span class="variable">$telnet_output</span> | grep <span class="string">&quot;Unknown host&quot;</span> || <span class="literal">true</span>`</span><br><span class="line">        <span class="keyword">if</span> [ -n <span class="string">&quot;<span class="variable">$telnet_output</span>&quot;</span> ] &amp;&amp; [ -z <span class="string">&quot;<span class="variable">$telnet_refused_msg</span>&quot;</span> ] &amp;&amp; [ -z <span class="string">&quot;<span class="variable">$telnet_host_unknown_msg</span>&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">            <span class="built_in">echo</span> <span class="string">&quot;export http_proxy=http://<span class="variable">$proxy_host</span>:<span class="variable">$proxy_port</span>&quot;</span> &gt;&gt; /etc/profile</span><br><span class="line">            <span class="built_in">echo</span> <span class="string">&quot;export https_proxy=http://<span class="variable">$proxy_host</span>:<span class="variable">$proxy_port</span>&quot;</span> &gt;&gt; /etc/profile</span><br><span class="line">            <span class="built_in">break</span></span><br><span class="line">        <span class="keyword">fi</span></span><br><span class="line">    <span class="keyword">done</span></span><br><span class="line">    current_proxy=`cat /etc/profile | grep http_proxy || <span class="literal">true</span>`</span><br><span class="line">    <span class="keyword">if</span> [ -n <span class="string">&quot;<span class="variable">$current_proxy</span>&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">        <span class="built_in">break</span></span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><h2 id="扩展-后面还可以做什么"><a href="#扩展-后面还可以做什么" class="headerlink" title="扩展: 后面还可以做什么"></a>扩展: 后面还可以做什么</h2><p>1、横向扩展<br><strong>支持更多服务的本地化集群</strong></p><p>大部分后台中间件，我们在公司里面实践的时候都会遇到部署集群和维护的场景。如果想在自己电脑上研究，当然是能够快速部署集群方便一点。</p><p>不过，要能够通过我上面所说的思路去搭集群，并不是容易事，你需要先设想 镜像如何构建，需要把哪些配置作为容器启动参数提供出来，这两步可能会花费大部分时间。不过如果能把这两步搞定，后面 compose 配置的编写就是顺理成章的事了</p><p>2、纵向扩展<br><strong>学习 K8S</strong></p><p>Compose 毕竟只是通过启动多个容器节点来实现集群 部署的效果，还不涉及到容器编排技术，资源调度这些。想要了解更多技术上的细节，还是最好通过 <strong>swarm、k8s</strong> 这类工具来实践</p><p>当然，想精通这两个工具，就没这么简单了，确实需要做好长期啃一门技术，却不一定有很快成效的心理准备</p><h2 id="资料"><a href="#资料" class="headerlink" title="资料"></a>资料</h2><p><a href="https://docs.docker.com/compose/gettingstarted/">Compose 官方文档</a></p><p><a href="https://github.com/eryajf/Thanks-Mirror">国内源替换仓库</a></p><p><a href="https://blog.chobon.top/posts/694278be/">s6 使用教程（基本是 git 官方 readme 的翻译版，不过作为入门教程还是不错）</a></p><p><a href="https://github.com/alibaba/nacos/issues/6340">nacos issue-Apple Mac M1 docker环境下nacos无法启动</a></p>]]></content>
    
    
    <summary type="html">提升生产效率是使用工具的最终目的</summary>
    
    
    
    <category term="开发工具" scheme="http://smiecj.github.io/categories/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"/>
    
    <category term="Docker" scheme="http://smiecj.github.io/categories/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/Docker/"/>
    
    
    <category term="Linux" scheme="http://smiecj.github.io/tags/Linux/"/>
    
    <category term="Docker" scheme="http://smiecj.github.io/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>树莓派通过 SSD 部署 和 配置内网穿透</title>
    <link href="http://smiecj.github.io/2022/03/12/rasp-ssd-frp/"/>
    <id>http://smiecj.github.io/2022/03/12/rasp-ssd-frp/</id>
    <published>2022-03-11T16:00:00.000Z</published>
    <updated>2022-03-11T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>之前一直有在家部署一个可以长期运行的 Linux 服务器的想法，但首先是自己没有一台 Linux 服务器，不是特别想一直开着台式机主机，其次是就算家里开着台式机，外网也访问不到，只能借助类似向日葵的软件远程操作桌面，所以一直没有实践<br>但最近把 树莓派 搞好之后发现其实搞起来也不是那么难，再加上有个大佬买了个云服务器，还一下买了几年，于是硬件条件都有满足了。终于找了个时间，先把树莓派通过 SSD 重新安装系统，再结合 内网穿透，后面可以在外网直接操作树莓派，算是有个可以经常跑，也能经常操作和维护的Linux服务器了</p><h2 id="树莓派和SSD"><a href="#树莓派和SSD" class="headerlink" title="树莓派和SSD"></a>树莓派和SSD</h2><p>一开始树莓派是需要通过 SD 卡初始化的，但是 显然 SD卡 无法承担更高的数据读写要求。于是把自己的一张不常用的 SSD 从台式机拿了出来，接到树莓派上并进行了下系统迁移</p><p><a href="https://www.tomshardware.com/how-to/boot-raspberry-pi-4-usb">How to Boot Raspberry Pi 4 / 400 From a USB SSD or Flash Drive</a></p><h3 id="系统写入SSD"><a href="#系统写入SSD" class="headerlink" title="系统写入SSD"></a>系统写入SSD</h3><p>这里我们通过 imager 将树莓派系统写入 SSD<br><a href="https://www.raspberrypi.com/software/">imager官方下载</a></p><p>选择一个官方镜像，32位和64位都可以<br><img src="/2022/03/12/rasp-ssd-frp/rasp03.png" alt="jupyter lab"></p><p>等待写入<br><img src="/2022/03/12/rasp-ssd-frp/rasp02.png" alt="jupyter lab"></p><h3 id="修改启动选项"><a href="#修改启动选项" class="headerlink" title="修改启动选项"></a>修改启动选项</h3><p>登录树莓派（这里还是用 SD卡 启动），安装 bootloader</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sudo apt update</span><br><span class="line">sudo apt full-upgrade</span><br><span class="line">sudo rpi-update</span><br><span class="line"></span><br><span class="line">sudo rpi-eeprom-update -d -a</span><br></pre></td></tr></table></figure><p>将启动选项修改成用 SSD 卡启动</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo raspi-config</span><br></pre></td></tr></table></figure><p>选择 <strong>6 Advanced Options -&gt; A6 Boot Order -&gt; B2 USB Boot</strong></p><h3 id="重启树莓派"><a href="#重启树莓派" class="headerlink" title="重启树莓派"></a>重启树莓派</h3><p>成功～</p><p><img src="/2022/03/12/rasp-ssd-frp/rasp04.png" alt="部署效果"></p><p>后面再安装了 docker，把一些后台服务部署到了树莓派上。除了受限于树莓派本身 CPU 和内存（4核4G），只能部署一些简单的服务，不过对自己的个人开发需求来说已经够用了</p><h2 id="内网穿透"><a href="#内网穿透" class="headerlink" title="内网穿透"></a>内网穿透</h2><h3 id="原理介绍"><a href="#原理介绍" class="headerlink" title="原理介绍"></a>原理介绍</h3><p>本质上就是在保证安全的前提下，建立从公网到内网的连接通道，使得内网机器能够通过一个可靠的公网地址访问<br>对应现实的例子，类似找香港的代购，代购相当于就是代理，能够按照我们的需求到香港购买一些面免关税的商品（公网发送请求到代理），再帮我们带回来（代理发送请求到内网服务，再将请求结果返回）<br>因此内网穿透的需求从架构上来看，主要包括三个元素：资源提供商、资源使用者 和 代理服务，如下:</p><p>frpc: fast forward proxy client, 内网代理服务<br>frps: fast forward proxy server, 外网代理服务</p><p><img src="/2022/03/12/rasp-ssd-frp/rasp05.png" alt="frp架构"></p><p><a href="https://github.com/fatedier/frp">git-frp</a></p><p>应用场景：</p><ul><li><p>​个人随时操作内网服务器<br>比如接下来要说的部署 frp 代理服务，就是实现这个需求</p></li><li><p>企业开启远程办公<br>国内的互联网公司基本都是通过 代理软件（如: easyConnect）+ 专用隧道 实现在外网对内网资源的访问，本质上就是内网穿透</p></li><li><p>将内网其他服务开启到外网（如个人博客站点）<br>比较大型的个人站点，一般会包含很多数据，需要一定的存储，也需要保证足够的并发访问能力。但是买一个高性能、高存储的云服务器对个人来说肯定成本也不少，这时就可以采用 站点依然部署在内网，只购买一台 主提供流量的 云服务器，通过内网穿透对外开启 HTTP 端口 提供服务的方式。相当于资源提供的压力还是主要在内网机器，外网云服务器只承担流量压力</p></li></ul><h3 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h3><ul><li>内网机器（Linux）</li><li>一台云服务器（Centos）</li></ul><h3 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h3><h4 id="frps（公网）"><a href="#frps（公网）" class="headerlink" title="frps（公网）"></a>frps（公网）</h4><p>下载</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https://github.com/fatedier/frp/releases/download/v0.40.0/frp_0.40.0_linux_amd64.tar.gz</span><br></pre></td></tr></table></figure><p>配置</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[common]</span></span><br><span class="line"><span class="comment"># frps 服务提供的端口</span></span><br><span class="line"><span class="attr">bind_port</span> = <span class="number">7001</span></span><br><span class="line"><span class="comment"># 是否每次网络连接的时候 都进行认证（访问速度 和 安全 方面的选择，并发不大的访问量来说影响不大）</span></span><br><span class="line"><span class="attr">authenticate_new_work_conns</span> = <span class="literal">true</span></span><br><span class="line"><span class="comment"># 是否对 frpc 和 frps 之间的心跳检查请求 都进行认证（默认心跳 30s 一次，所以开启认证影响不大）</span></span><br><span class="line"><span class="attr">authenticate_heartbeats</span> = <span class="literal">true</span></span><br><span class="line"><span class="comment"># 请求认证方式，可选 token/oidc</span></span><br><span class="line"><span class="attr">authentication_method</span> = token</span><br><span class="line"><span class="comment"># 用于请求信息 加密的 key</span></span><br><span class="line"><span class="comment">## 扩展：加密算法 主要用到了 MD5 和 AES，前者用于 Ping 包的校验，后者用于 TCP 请求的校验，具体实现可以参考 frp 作者的 golib 仓库 - git-golib-crypto</span></span><br><span class="line"><span class="attr">token</span> = <span class="number">123</span></span><br></pre></td></tr></table></figure><p>启动</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./frps -c ./frps.ini</span><br></pre></td></tr></table></figure><h4 id="frpc（内网）"><a href="#frpc（内网）" class="headerlink" title="frpc（内网）"></a>frpc（内网）</h4><p>下载</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https://github.com/fatedier/frp/releases/download/v0.40.0/frp_0.40.0_linux_arm64.tar.gz</span><br></pre></td></tr></table></figure><p>配置</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[common]</span></span><br><span class="line"><span class="comment"># 公网 ip 地址</span></span><br><span class="line"><span class="attr">server_addr</span> = x.x.x.x</span><br><span class="line"><span class="comment"># 公网 frps 服务端口，对应 frps.ini 的 bind_ip</span></span><br><span class="line"><span class="attr">server_port</span> = <span class="number">7001</span></span><br><span class="line"><span class="comment"># 校验相关的配置 和 frps 保持一致</span></span><br><span class="line"><span class="attr">authenticate_new_work_conns</span> = <span class="literal">true</span></span><br><span class="line"><span class="attr">authenticate_heartbeats</span> = <span class="literal">true</span></span><br><span class="line"><span class="attr">authentication_method</span> = token</span><br><span class="line"><span class="attr">token</span> = <span class="number">123</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 代理名称（可自行命名）</span></span><br><span class="line"><span class="section">[ssh]</span></span><br><span class="line"><span class="comment"># 代理协议</span></span><br><span class="line"><span class="attr">type</span> = tcp</span><br><span class="line"><span class="comment"># 内网 ssh 端口</span></span><br><span class="line"><span class="attr">local_port</span> = <span class="number">22</span></span><br><span class="line"><span class="comment"># 在公网开放的端口地址</span></span><br><span class="line"><span class="attr">remote_port</span> = <span class="number">6001</span></span><br></pre></td></tr></table></figure><p>启动</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./frpc -c ./frpc.ini</span><br></pre></td></tr></table></figure><h4 id="添加端口访问权限"><a href="#添加端口访问权限" class="headerlink" title="添加端口访问权限"></a>添加端口访问权限</h4><p>阿里云：管理控制台 -&gt; 云服务器 -&gt; ECS安全组 -&gt; 手动添加访问规则<br>分别将 frps 服务的端口 和 内网机器通过 frps 暴露的外网端口 设置访问权限</p><p><img src="/2022/03/12/rasp-ssd-frp/rasp06.png" alt="阿里云安全策略配置"></p><h4 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h4><p>直接通过ssh云服务器 连接内网服务器:<br>ssh pi@外网服务器ip -p6001</p><p><img src="/2022/03/12/rasp-ssd-frp/rasp07.png" alt="ssh"></p>]]></content>
    
    
    <summary type="html">基于 树莓派的实践</summary>
    
    
    
    <category term="生活" scheme="http://smiecj.github.io/categories/%E7%94%9F%E6%B4%BB/"/>
    
    <category term="技术实践" scheme="http://smiecj.github.io/categories/%E7%94%9F%E6%B4%BB/%E6%8A%80%E6%9C%AF%E5%AE%9E%E8%B7%B5/"/>
    
    
    <category term="Linux" scheme="http://smiecj.github.io/tags/Linux/"/>
    
    <category term="树莓派" scheme="http://smiecj.github.io/tags/%E6%A0%91%E8%8E%93%E6%B4%BE/"/>
    
  </entry>
  
  <entry>
    <title>2月份随便记记</title>
    <link href="http://smiecj.github.io/2022/02/28/life-202202/"/>
    <id>http://smiecj.github.io/2022/02/28/life-202202/</id>
    <published>2022-02-27T16:00:00.000Z</published>
    <updated>2022-02-27T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="充实的2月份"><a href="#充实的2月份" class="headerlink" title="充实的2月份"></a>充实的2月份</h2><p>2月份发生了各种事，从线下蔓延到了线上，一定程度让自己有一些关注新闻欲过高。月初看了看冬奥会盛况，感叹也许只有中国人办的奥运才会能这么美。月中关注国内一些“历史遗留”问题，也算是非常有中国特色了。最后月底就是大国之间的博弈，在哪个社交app几乎都能看到关于这件事的新闻<br>然而回头一看，自己忘记的事情也有很多，不仅仅是思考这些事背后到底代表着什么，还有记录点自己内心的想法。也许是时候，带着轻松点的态度，给自己写点总结了～</p><h2 id="开发相关的东西"><a href="#开发相关的东西" class="headerlink" title="开发相关的东西"></a>开发相关的东西</h2><p>首先就是继续把自己的 DockerFile 仓库更完善了下，虽然过程还是有些痛苦的，Centos7 在 Arm 上不能运行 dbus 服务，Centos8 官方 yum 源又不再支持，另外还有python 在两种架构下表现不太一致的问题。各种适配之后，终于把 开发镜像 做到了 x86 和 arm 架构都能够兼容了。总算是松了口气</p><p>除了开发镜像，还整理了最近了解的大数据相关服务：Jupyter，把它们的安装过程也整理到了 DockerFile 中。这两个组件都是数据开发过程必备的 IDE，或许有了这第一步，终于能够开始好好学习下 机器学习了？</p><p>Jupyter 效果:</p><p><img src="/2022/02/28/life-202202/02.png" alt="jupyter lab"></p><p><img src="/2022/02/28/life-202202/03.png" alt="mysql connector demo"></p><p><a href="https://github.com/smiecj/docker-centos">DockerFile 仓库</a></p><h2 id="新的想法"><a href="#新的想法" class="headerlink" title="新的想法"></a>新的想法</h2><p>除了日常做“正事”，也没忘记偶尔“胡思乱想”</p><h3 id="树莓派"><a href="#树莓派" class="headerlink" title="树莓派"></a>树莓派</h3><p>这个从买来就一直在吃灰的东西，在一次和同事的闲聊中，又有了搞起来的想法<br>也许确实没有很多时间去研究适合它的配件，不过至少在家一直开机，当一个服务器还是可以的吧？对于没有买云主机来说，有一个能长期运行的主机可太关键了，毕竟要台式机一直开着还是有点麻烦<br>但是在此之前，还需要稍微做一些准备工作，默认树莓派刚买到是需要先用 SD 卡刷好操作系统的，但是这显然不适合做需要更高写的服务了，甚至还有很高的把 SD 卡写坏的风险。需要换成 SSD<br>这里先记录一下之前搜的教程，等搞好之后“也许”自己会再发个踩坑记录吧，就是几时能写好就不一定了</p><p><a href="https://zhuanlan.zhihu.com/p/336932291">树莓派4 SSD 启动</a></p><h3 id="新闻过滤算法"><a href="#新闻过滤算法" class="headerlink" title="新闻过滤算法"></a>新闻过滤算法</h3><p>在国内外都在打各种信息战的时候，怎么才能过滤出对自己最有用的新闻呢？<br>毕竟人一天的精力终归有限，怎么样更高效的过滤自己想看的新闻，显然是可以借助一些算法实现的<br>但是现实情况往往很复杂，对每个人，每个时间段的需求可能也不一样，有人就更喜欢那种深入剖析，比较长篇的新闻，但是也可能会有想休息，想吸收点快餐类新闻放松的时候。这就意味着这个算法模型可能会有多种，而且还会因人而异<br>如何才能训练出这种更高效的算法，又是一个需要长时间检验的过程，哎，想了想，技术确实能改变人的生活，但是想和现实完美结合，还是很难啊。不知道猴年马月自己才能先做出一个适合自己的模型。。</p>]]></content>
    
    
    <summary type="html">一点随想</summary>
    
    
    
    <category term="生活" scheme="http://smiecj.github.io/categories/%E7%94%9F%E6%B4%BB/"/>
    
    <category term="记录" scheme="http://smiecj.github.io/categories/%E7%94%9F%E6%B4%BB/%E8%AE%B0%E5%BD%95/"/>
    
    
    <category term="生活" scheme="http://smiecj.github.io/tags/%E7%94%9F%E6%B4%BB/"/>
    
  </entry>
  
  <entry>
    <title>Mac 预装软件整理</title>
    <link href="http://smiecj.github.io/2022/01/10/mac-init-software/"/>
    <id>http://smiecj.github.io/2022/01/10/mac-init-software/</id>
    <published>2022-01-09T16:00:00.000Z</published>
    <updated>2022-01-09T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近发现在 mac 上装的软件是越来越多了，索性就整理一下自己装过的 mac 必备软件，方便后面用新机的时候直接参考教程无缝切换</p><h2 id="参考网站"><a href="#参考网站" class="headerlink" title="参考网站"></a>参考网站</h2><p><a href="https://www.v1tx.com/post/best-mac-apps/">博客-15款好用的Mac软件推荐</a></p><h2 id="效率工具"><a href="#效率工具" class="headerlink" title="效率工具"></a>效率工具</h2><h3 id="brew"><a href="#brew" class="headerlink" title="brew"></a>brew</h3><p>功能: 软件安装工具，一键安装指定软件，无需关注繁琐的安装配置，对于一些工具类软件，比如下面提到的性能测试软件，还是比较实用的<br><a href="https://docs.brew.sh/">官方文档</a></p><p><a href="https://github.com/Homebrew/brew">git-Homebrew/brew</a></p><p>安装方式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/bin/bash -c &quot;$(curl -fsSL https://cdn.jsdelivr.net/gh/ineo6/homebrew-install/install.sh)&quot;</span><br></pre></td></tr></table></figure><p>替换国内源</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># 替换 brew.git</span><br><span class="line">cd &quot;$(brew --repo)&quot;</span><br><span class="line">git remote set-url origin https://mirrors.tuna.tsinghua.edu.cn/git/homebrew/brew.git</span><br><span class="line"></span><br><span class="line"># 替换 homebrew-core.git</span><br><span class="line">cd &quot;$(brew --repo)/Library/Taps/homebrew/homebrew-core&quot;</span><br><span class="line">git remote set-url origin https://mirrors.tuna.tsinghua.edu.cn/git/homebrew/homebrew-core.git</span><br><span class="line"></span><br><span class="line"># 更新配置</span><br><span class="line">brew update</span><br></pre></td></tr></table></figure><p>扩展: 给其他软件自定义安装脚本<br><a href="https://www.jianshu.com/p/df351f34c160">博客-将软件发布到 Homebrew</a><br><a href="https://docs.brew.sh/Formula-Cookbook">博客-Formula Cookbook</a></p><h3 id="alfred"><a href="#alfred" class="headerlink" title="alfred"></a>alfred</h3><p>自带非常多快捷键工具，我用得比较多的就是粘贴板，可以帮我记住最近一段时间复制过的内容。主要功能有：</p><ul><li>Web Search 文件搜索</li><li>Clipboard History 剪贴板历史</li><li>Snippets 文本片段</li><li>System 系统（系统操作快捷键，如清空回收站）</li></ul><p>alfred 本身的快捷键配置<br><img src="/2022/01/10/mac-init-software/alfred01.png" alt="shortcut"></p><p>剪贴板历史配置<br><img src="/2022/01/10/mac-init-software/alfred02.png" alt="clipboard history"><br>（截图只是表示个人使用习惯）</p><p><a href="https://macwk.com/soft/alfred-4">下载地址</a></p><p><a href="https://michael728.github.io/2020/09/23/tools-dev-mac-alfred/">参考-Mac 效率工具必备神器 —— Alfred</a></p><h3 id="bartender"><a href="#bartender" class="headerlink" title="bartender"></a>bartender</h3><p>mac 的状态栏在右上角，但是不像 windows 那样有默认的隐藏功能，不方便管理<br>bartender 就是不错的状态栏管理工具</p><p><a href="https://macwk.com/soft/bartender-4">下载地址</a></p><p><img src="/2022/01/10/mac-init-software/bartender.png" alt="bartender"></p><h2 id="开发常用"><a href="#开发常用" class="headerlink" title="开发常用"></a>开发常用</h2><h3 id="zsh"><a href="#zsh" class="headerlink" title="zsh"></a>zsh</h3><p>zsh 本身不是 shell，它只是在终端基础上套了个壳，相当于穿了件外套，你可以换不同样式的外套，也可以给衣服加口袋</p><p>而其中 oh-my-zsh 又是扩展功能实现相对比较多的版本。虽然 mac 本身使用的是 zsh，但是版本可能比较旧，还是建议更新 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># 安装 zsh</span><br><span class="line">brew install zsh</span><br><span class="line"></span><br><span class="line"># 安装 oh-my-zsh</span><br><span class="line">sh -c &quot;$(curl -fsSL https://raw.githubusercontent.com/robbyrussell/oh-my-zsh/master/tools/install.sh)&quot;</span><br><span class="line"></span><br><span class="line"># 查看当前终端使用的shell</span><br><span class="line">echo $SHELL</span><br><span class="line"></span><br><span class="line"># 如果不是 zsh，修改成 zsh</span><br><span class="line">sudo echo &quot;$(which zsh)&quot; &gt;&gt; /etc/shells</span><br><span class="line">chsh -s $(which zsh)</span><br></pre></td></tr></table></figure><p>配置插件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># vim ~/.zshrc</span><br><span class="line">plugins=(git osx zsh-autosuggestions zsh-syntax-highlighting)</span><br><span class="line"></span><br><span class="line"># 自动提示插件</span><br><span class="line">git clone https://github.com/zsh-users/zsh-autosuggestions $ZSH_CUSTOM/plugins/zsh-autosuggestions</span><br><span class="line"># 语法高亮插件</span><br><span class="line">git clone https://github.com/zsh-users/zsh-syntax-highlighting $ZSH_CUSTOM/plugins/zsh-syntax-highlighting</span><br></pre></td></tr></table></figure><p>配置主题（根据需要配置，也可以设置其他主题）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 下载</span><br><span class="line">git clone --depth=1 https://gitee.com/romkatv/powerlevel10k.git $&#123;ZSH_CUSTOM:-$HOME/.oh-my-zsh/custom&#125;/themes/powerlevel10k</span><br><span class="line"></span><br><span class="line"># 配置: vim ~/.zshrc</span><br><span class="line">ZSH_THEME=&quot;powerlevel10k/powerlevel10k&quot;</span><br></pre></td></tr></table></figure><p><a href="https://a1049145827.github.io/2019/05/15/Mac-%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85%E5%B9%B6%E9%85%8D%E7%BD%AE%E7%BB%88%E7%AB%AF%E7%A5%9E%E5%99%A8-oh-my-zsh/">参考-Mac 环境安装并配置终端神器 oh-my-zsh</a></p><h3 id="iterm"><a href="#iterm" class="headerlink" title="iterm"></a>iterm</h3><p>一款比较好用的终端工具，支持多窗口<br><a href="https://iterm2.com/downloads.html">下载地址</a></p><h4 id="使用技巧-快速登录指定节点"><a href="#使用技巧-快速登录指定节点" class="headerlink" title="使用技巧 - 快速登录指定节点"></a>使用技巧 - 快速登录指定节点</h4><p>iterm 本身没有记录节点列表的功能，如果需要随时连接指定节点（在公司一般都会用到），我们可以通过shell 脚本 + host 配置文件的方式，来实现快速登录指定节点</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"># vim /etc/my_hosts</span><br><span class="line">## 我的配置方式是 节点名 + 环境名 + 实际 ssh 连接的地址 + 端口</span><br><span class="line">docker local root@localhost 22</span><br><span class="line">docker db root@localhost 23</span><br><span class="line">cloud dev root@云主机ip 22</span><br><span class="line">compile dev root@内网编译专用机ip 22</span><br><span class="line"></span><br><span class="line"># vim /usr/local/bin/goto</span><br><span class="line">#!/bin/sh</span><br><span class="line">set -euxo pipefail</span><br><span class="line"></span><br><span class="line">echo &quot;hello go!&quot;</span><br><span class="line"></span><br><span class="line">if [ $# -lt 2 ]; then</span><br><span class="line">        echo &quot;Invalid input!&quot;</span><br><span class="line">        exit</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">node_name=$1</span><br><span class="line">env_name=$2</span><br><span class="line"></span><br><span class="line">login_node_full_info=`cat /etc/my_hosts | grep &quot;$node_name $env_name&quot;`</span><br><span class="line">if [ -z &quot;$login_node_full_info&quot; ]; then</span><br><span class="line">        echo &quot;Node not found!&quot;</span><br><span class="line">        exit</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">IFS=&#x27; &#x27; read -r -a node_split_arr &lt;&lt;&lt; &quot;$login_node_full_info&quot;</span><br><span class="line">#ssh -p$&#123;node_split_arr[3]&#125; $&#123;node_split_arr[2]&#125;</span><br><span class="line">ssh -o &quot;IdentitiesOnly=yes&quot; -i ~/.ssh/自己生成的免密密钥，可将公钥加到想登录的节点上，不需要每次都输密码  -p$&#123;node_split_arr[3]&#125; $&#123;node_split_arr[2]&#125;</span><br></pre></td></tr></table></figure><p>这样直接输入 goto 节点名 环境名 即可登录指定节点</p><h4 id="扩展-支持-lrzsz（文件上传和下载工具）"><a href="#扩展-支持-lrzsz（文件上传和下载工具）" class="headerlink" title="扩展: 支持 lrzsz（文件上传和下载工具）"></a>扩展: 支持 lrzsz（文件上传和下载工具）</h4><p>默认iterm 是不支持rz、sz 的，执行后会卡住，需要设置适配的脚本，比如执行 rz 的时候，打开文件列表</p><p>下载适配脚本</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cd /usr/local/bin</span><br><span class="line">sudo wget https://raw.githubusercontent.com/RobberPhex/iterm2-zmodem/master/iterm2-recv-zmodem.sh</span><br><span class="line">sudo wget https://raw.githubusercontent.com/RobberPhex/iterm2-zmodem/master/iterm2-send-zmodem.sh</span><br><span class="line"></span><br><span class="line">sudo chmod 777 /usr/local/bin/iterm2-*</span><br></pre></td></tr></table></figure><p>修改配置<br><img src="/2022/01/10/mac-init-software/iterm01.png" alt="iterm config"></p><p><img src="/2022/01/10/mac-init-software/iterm02.png" alt="iterm config"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Regular expression      Action  Parameters</span><br><span class="line">\*\*B0100       Run Silent Coprocess    /usr/local/bin/iterm2-send-zmodem.sh</span><br><span class="line">\*\*B00000000000000     Run Silent Coprocess    /usr/local/bin/iterm2-recv-zmodem.sh</span><br></pre></td></tr></table></figure><h3 id="lrzsz"><a href="#lrzsz" class="headerlink" title="lrzsz"></a>lrzsz</h3><p>文件上传、下载工具<br>当然多文件上传/下载 不支持确实比较麻烦，单文件的操作还是比较方便的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install lrzsz</span><br></pre></td></tr></table></figure><h3 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h3><p>Docker 对于开发者的重要性我在前面<a href="https://mp.weixin.qq.com/s/zmkzhIdL7Da_sfNauhAGRQ">公众号文章</a>有提过，主要就是开发环境的模拟和隔离，比如现在需要在 Arm 版本的 Mac 上开发 X86 的程序，就需要模拟一个 X86 的环境，直接通过 Docker 启动一个 X86 的镜像是比较方便的</p><p>建议在官网下载最新版，使用 brew 安装的版本可能会稍微旧一点</p><p><a href="https://www.docker.com/products/docker-desktop">官网下载</a></p><p>mac 电脑建议根据本身芯片架构选择匹配的版本，比如如果在 M1 版本上安装 X86 的 docker desktop，虽然镜像能跑，但是能耗可能会比较高<br>这边我还整理了开发镜像的制作方式，<a href="https://smiecj.github.io/2021/12/18/dockerfile-centos-dev/">参考博客</a>，可一键搭建包含 java、go 等语言的开发镜像</p><h3 id="Conda"><a href="#Conda" class="headerlink" title="Conda"></a>Conda</h3><p>安装 Python 的最佳工具，对不同环境之间可进行较好的隔离</p><p><a href="https://docs.conda.io/en/latest/miniconda.html">下载地址</a></p><p>建议下载脚本，下载完成后通过 sh 执行即可，然后会有一些设置安装路径的操作，建议放在 <strong>/Users/用户名/miniconda</strong> 目录下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sh /Users/username/Downloads/Miniconda3-latest-MacOSX-arm64.sh</span><br></pre></td></tr></table></figure><p>安装完成后在环境变量中配置 conda 路径</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># vim ~/.zshrc</span><br><span class="line">export CONDA_HOME=/Users/username/miniconda</span><br><span class="line">export PATH=$PATH:$CONDA_HOME/bin</span><br></pre></td></tr></table></figure><h2 id="性能测试"><a href="#性能测试" class="headerlink" title="性能测试"></a>性能测试</h2><h3 id="glances"><a href="#glances" class="headerlink" title="glances"></a>glances</h3><p>支持各操作系统的性能指标查看工具，使用 python 编写</p><p><a href="https://nicolargo.github.io/glances/">官网</a><br><a href="https://github.com/nicolargo/glances">git-nicolargo/glances</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install glances</span><br></pre></td></tr></table></figure><p><img src="/2022/01/10/mac-init-software/glances.png" alt="glances"></p><h3 id="Speed-Test"><a href="#Speed-Test" class="headerlink" title="Speed Test"></a>Speed Test</h3><p>磁盘速度测试工具，在 app store 上直接搜索: blackmagic disk speed test 即可</p><p><img src="/2022/01/10/mac-init-software/speedtest.png" alt="speed test"></p>]]></content>
    
    
    <summary type="html">介绍 mac 的一些预装软件，包括开发工具</summary>
    
    
    
    <category term="开发工具" scheme="http://smiecj.github.io/categories/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"/>
    
    <category term="mac" scheme="http://smiecj.github.io/categories/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/mac/"/>
    
    
    <category term="开发工具" scheme="http://smiecj.github.io/tags/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"/>
    
    <category term="mac" scheme="http://smiecj.github.io/tags/mac/"/>
    
  </entry>
  
  <entry>
    <title>通过 DockerFile 搭建开发镜像</title>
    <link href="http://smiecj.github.io/2021/12/19/dockerfile-centos-dev/"/>
    <id>http://smiecj.github.io/2021/12/19/dockerfile-centos-dev/</id>
    <published>2021-12-18T16:00:00.000Z</published>
    <updated>2021-12-18T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>之前搭建过一个开发镜像，包含了 java、go 语言等基本的开发环境，结合 vscode remote 模式，可在本地直接进行开发，免去了安装各种基础环境和配置环境变量的麻烦<br><a href="https://mp.weixin.qq.com/s?__biz=MzU2MDkxMjkwMw==&mid=2247483773&idx=1&sn=a82edd0c3a8063348a7c325fe7f9773d">参考-Docker Desktop 安装方式和开发镜像分享</a></p><p>但是对于使用者来说，依然有两个并不方便的地方：</p><ul><li><p>易用性：对于使用 X86 系统来说，之前的开发镜像确实可以直接用，因为我的镜像就是基于 X86 系统的。但是对于arm 架构系统用户来说，可能就有适配问题了</p></li><li><p>开放性和扩展性：整个镜像的制作过程是封闭的，使用方只能拿到具体的镜像，无法了解到具体的构建过程，也无法对镜像在构建过程进行扩展</p></li><li><ul><li>比如我还想装其他开发语言，依然只能手动装，而且换台电脑之后可能还得这么来操作一次</li></ul></li></ul><p>综上，为了改进我们的开发镜像的这两点，通过 DockerFile 我们再构建一次之前的开发镜像</p><h2 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h2><p><a href="https://github.com/smiecj/docker-centos">项目git地址：docker-centos</a></p><p>先直接来看如何用新的开发镜像：直接下载工程 docker-centos，并通过 centos_dev 这个 Dockerfile 构建镜像</p><p>构建方法：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build --no-cache -f Dockerfiles/centos_dev -t centos_dev_test .</span><br></pre></td></tr></table></figure><p><img src="/2021/12/19/dockerfile-centos-dev/centos-dev_01.png" alt="code"></p><p>等待构建大约10分钟，构建完成后启动容器：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker images</span><br><span class="line"></span><br><span class="line">docker run -d --hostname code --name centos_dev_test --privileged=true -p 2222:22 centos_dev_test /usr/sbin/init</span><br></pre></td></tr></table></figure><p><img src="/2021/12/19/dockerfile-centos-dev/centos-dev_02.png" alt="code"></p><p>容器启动后，通过 Docker Desktop 打开命令行，检查相关依赖是否安装成功：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">source /etc/profile</span><br><span class="line">source ~/.bashrc</span><br><span class="line">java -version</span><br><span class="line">go version</span><br></pre></td></tr></table></figure><p><img src="/2021/12/19/dockerfile-centos-dev/centos-dev_03.png" alt="code"></p><h2 id="开发过程"><a href="#开发过程" class="headerlink" title="开发过程"></a>开发过程</h2><h3 id="DockerFile"><a href="#DockerFile" class="headerlink" title="DockerFile"></a>DockerFile</h3><p>目录：Dockerfiles/centos_dev</p><p>这里不需要做太多操作，只需要从 git 下载包含初始化系统脚本的仓库即可</p><p><img src="/2021/12/19/dockerfile-centos-dev/centos-dev_04.png" alt="code"></p><h3 id="初始化脚本"><a href="#初始化脚本" class="headerlink" title="初始化脚本"></a>初始化脚本</h3><p>目录：scripts/init-dev-system.sh</p><p>即初始化整个操作系统的脚本，大概就是下载 + 安装 + 配置环境变量的过程。笔者这里根据自己的开发需要，搭建了 java、go、python 和 nodejs 开发环境，具体版本如下：</p><ul><li>Java: OpenJDK 1.8</li><li>Go: 1.17</li><li>Python: Python3（MiniConda）</li><li>Nodejs: 14.17.0</li></ul><p>其他细节说明</p><ul><li>语言的可执行安装包统一放在 /usr/语言名 目录下，如: /usr/java</li><li>语言的下载依赖路径统一放在 /home/repo/语言名下，如: /usr/golang</li><li>Java 安装11 和 8 版本：8 用于编译，11 用于 vscode 的 java 插件顺利启动</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>用好工具就是提升开发效率的第一步～</p>]]></content>
    
    
    <summary type="html">一键搭建开发镜像，从此告别繁琐的各种开发环境的安装过程</summary>
    
    
    
    <category term="开发工具" scheme="http://smiecj.github.io/categories/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"/>
    
    <category term="docker" scheme="http://smiecj.github.io/categories/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/docker/"/>
    
    
    <category term="docker" scheme="http://smiecj.github.io/tags/docker/"/>
    
    <category term="开发工具" scheme="http://smiecj.github.io/tags/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>通过 Ambari 启动 Nebula Gateway 一段时间后会自动退出的问题解决</title>
    <link href="http://smiecj.github.io/2021/11/20/nebula-gateway-sigpipe/"/>
    <id>http://smiecj.github.io/2021/11/20/nebula-gateway-sigpipe/</id>
    <published>2021-11-19T16:00:00.000Z</published>
    <updated>2021-11-19T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="http://senlinzhan.github.io/2017/03/02/sigpipe/">网络编程中的 SIGPIPE 信号</a></p><p><a href="https://coderatwork.cn/posts/sigpipe-tragedy/">SIGPIPE 引发的悲剧</a></p><p><a href="https://www.cnblogs.com/lit10050528/p/5116566.html">SIGPIPE信号详解</a></p><h2 id="问题概述"><a href="#问题概述" class="headerlink" title="问题概述"></a>问题概述</h2><p>在 Ambari 中集成了 nebula studio 1.0 版本，启动的组件包括：</p><ul><li>Studio: 通过 node 启动的 前端服务</li><li>Importer: 数据导入工具，可以将本地的CSV 文件导入到 graph</li><li>Gateway: 连接 studio 和 graph 服务的网关服务</li></ul><p>然后gateway组件的启动脚本是这样的：<br><strong>nohup ./nebula-http-gateway &gt;&gt; /var/log/nebula/gateway.log &amp;</strong></p><p>启动过程集成到了 ambari 中，然后通过界面启动gateway 服务，一开始服务正常启动没问题，但是在 studio 上进行一些图搜索操作之后，就会自动退出，而且服务日志中没有任何报错信息</p><p>但是直接在命令行执行的时候，就不会有任何问题，一开始百思不得其解</p><h2 id="相关基础知识"><a href="#相关基础知识" class="headerlink" title="相关基础知识"></a>相关基础知识</h2><h3 id="操作系统-stdout、stderr"><a href="#操作系统-stdout、stderr" class="headerlink" title="操作系统: stdout、stderr"></a>操作系统: stdout、stderr</h3><p>标准输出和错误输出</p><p>在命令行通过 nohup 打印，默认输出位置:<br>stdout: nohup.out<br>stderr: 直接忽略</p><h3 id="nebula-gateway-查询图数据逻辑"><a href="#nebula-gateway-查询图数据逻辑" class="headerlink" title="nebula gateway: 查询图数据逻辑"></a>nebula gateway: 查询图数据逻辑</h3><p>这里我们看 执行 nebula查询语句的关键方法: Execute<br>（gateway 版本：1.0）</p><blockquote><p>service/dao/dao.go</p></blockquote><p><img src="/2021/11/20/nebula-gateway-sigpipe/nebula01.png" alt="code"></p><p><img src="/2021/11/20/nebula-gateway-sigpipe/nebula02.png" alt="code"></p><p>Request 发给了一个 channel，然后 等待 response channel 接收到回复，最后处理 response ，返回成功 或者是打印 错误信息</p><h3 id="golang-打印日志的目标"><a href="#golang-打印日志的目标" class="headerlink" title="golang 打印日志的目标"></a>golang 打印日志的目标</h3><h4 id="println-stderr"><a href="#println-stderr" class="headerlink" title="println: stderr"></a>println: stderr</h4><p><img src="/2021/11/20/nebula-gateway-sigpipe/nebula03.png" alt="code"></p><h4 id="fmt-Println-stdout"><a href="#fmt-Println-stdout" class="headerlink" title="fmt.Println: stdout"></a>fmt.Println: stdout</h4><p><img src="/2021/11/20/nebula-gateway-sigpipe/nebula04.png" alt="code"></p><h4 id="log-Printf-log-Println-stderr"><a href="#log-Printf-log-Println-stderr" class="headerlink" title="log.Printf / log.Println: stderr"></a>log.Printf / log.Println: stderr</h4><p><img src="/2021/11/20/nebula-gateway-sigpipe/nebula05.png" alt="code"></p><blockquote><p>func (l *Logger) Output(calldepth int, s string) error {</p></blockquote><p><img src="/2021/11/20/nebula-gateway-sigpipe/nebula06.png" alt="code"></p><p><img src="/2021/11/20/nebula-gateway-sigpipe/nebula07.png" alt="code"></p><h3 id="SIGPIPE"><a href="#SIGPIPE" class="headerlink" title="SIGPIPE"></a>SIGPIPE</h3><p><a href="https://man7.org/linux/man-pages/man7/signal.7.html">linux-signal</a></p><p>SIGPIPE 和 强制终止 kill -9 类似，都是一种发送程序终止的信号。它表示向一个已经终止的socket 通道中写数据</p><p>这种情况也是比较常见的，因为可能因为网络的不稳定，服务端向客户端成功发送 FIN 之后，一直没有收到客户端回复的RSP，客户端如果又自行退出，就会导致服务端再次向客户端发送请求时，收到一个 SIGPIPE 信号<br>对于C 程序，默认情况下是不会忽略这个信号的，收到这个信号就会直接退出。可通过执行 <strong>signal(SIGPIPE, SIG_IGN);</strong> 方法忽略之</p><h2 id="定位过程"><a href="#定位过程" class="headerlink" title="定位过程"></a>定位过程</h2><h3 id="打印进程详细日志"><a href="#打印进程详细日志" class="headerlink" title="打印进程详细日志"></a>打印进程详细日志</h3><p>strace：可打印进程的内核操作详细信息的工具<br>strace -p pid: 打印指定进程的详细信息</p><p><img src="/2021/11/20/nebula-gateway-sigpipe/nebula08.png" alt="strace"></p><p>这里很明显进程退出的原因 就是接收到了 SIGPIPE 信号</p><h3 id="原因分析"><a href="#原因分析" class="headerlink" title="原因分析"></a>原因分析</h3><p>结合前面的基本知识，可大致判断就是 <strong>Ambari 通过一个sub process 执行 gateway 的启动脚本，在执行完成之后，子进程退出了，但是 gateway 依然往子进程的标准输出中打印日志（写日志也是socket操作），就会导致 gateway 接收到 SIGPIPE 信号，并最后退出</strong></p><p>为了最终确定，我们再看一下 ambari 的Execute 方法实现，可看到它会把错误输出定位到标准输出，标准输出默认是和 进程 强绑定的，进程退出了，就无法再打印日志了</p><blockquote><p>ambari-common/src/main/python/resource_management/core/resources/system.py</p></blockquote><p>class Execute(Resource):</p><p>而 gateway 通过 log.Printf 打印 response 的错误信息，会将日志打印到stderr，印证了这个退出的原因</p><h2 id="问题解决"><a href="#问题解决" class="headerlink" title="问题解决"></a>问题解决</h2><p>修改gateway 启动脚本，将 stdout 和 stderr 都重定向到日志文件即可</p><p>nohup ./nebula-http-gateway <strong>&gt; /var/log/nebula/gateway.log 2&gt;&amp;1</strong> &amp;</p><p>再次操作 nebula studio，看到 gateway 打印的日志能正常在 nohup.out 中打印了</p><p><img src="/2021/11/20/nebula-gateway-sigpipe/nebula10.png" alt="log"></p><h2 id="小总结"><a href="#小总结" class="headerlink" title="小总结"></a>小总结</h2><p>虽然最后解决 也就是一行代码的事情，但是发现这个问题根因的过程还是挺有意思的</p>]]></content>
    
    
    <summary type="html">一个开发过程遇到的小bug的解决</summary>
    
    
    
    <category term="大数据" scheme="http://smiecj.github.io/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
    <category term="问题解决" scheme="http://smiecj.github.io/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/"/>
    
    
    <category term="大数据" scheme="http://smiecj.github.io/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
    <category term="nebula" scheme="http://smiecj.github.io/tags/nebula/"/>
    
  </entry>
  
  <entry>
    <title>Hexo 博客搭建教程</title>
    <link href="http://smiecj.github.io/2021/08/13/hexo-blog/"/>
    <id>http://smiecj.github.io/2021/08/13/hexo-blog/</id>
    <published>2021-08-12T16:00:00.000Z</published>
    <updated>2021-08-12T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h2><p><a href="https://smiecj.github.io/">博客首页</a><br><img src="/2021/08/13/hexo-blog/hexo_blog_01.png" alt="blog front page"></p><p><img src="/2021/08/13/hexo-blog/hexo_blog_12.png" alt="blog front page"></p><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>之前自己的博客都是放在csdn上，分类管理起来不是很方便，而且分类在左下角，不是特别显眼的地方<br><img src="/2021/08/13/hexo-blog/hexo_blog_03.png" alt="csdn page"></p><p>公众号的标签功能还可以，不过自己还是希望有个个人站点能专门管理写过的博客，主题最好是能一目了然，不仅仅是别人看着方便，以后自己整理资料的时候找得也方便</p><p>既然有这个需求，那就试试呗，看看个人站点怎么搭建，据说不难的</p><h2 id="踩坑记-hugo工具短暂的体验"><a href="#踩坑记-hugo工具短暂的体验" class="headerlink" title="踩坑记 - hugo工具短暂的体验"></a>踩坑记 - hugo工具短暂的体验</h2><p>hugo 是一个用golang 写的博客搭建工具，主要功能是可一键生成博客，我们自己只需要写markdown 格式的文章就行了，前端静态文件都是通过hugo 进行渲染生成的。方便是方便，但是一直没有找到特别满意的主题。<br>其实自己对主题的要求也没有说特别高，主要是要简洁、重点明了就好了，那种特别花哨、或者是基本功能欠缺的主题都是不考虑的<br>所以最后放弃了hugo。一次偶然的机会，和一个前端同学聊，知道了有hexo 这样一个工具，同样是生成博客的，那就试试呗</p><p><a href="https://jeshs.github.io/2019/01/hugo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E4%B8%80%E6%90%AD%E5%BB%BAhugo%E5%8D%9A%E5%AE%A2/">参考-hugo搭建教程</a></p><blockquote><p>hugo基本指令:</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">创建一篇博客:</span><br><span class="line">hugo new site myblog</span><br><span class="line">启动服务:</span><br><span class="line">hugo server -D --bind=&quot;0.0.0.0&quot;</span><br></pre></td></tr></table></figure><h2 id="hexo-主题介绍"><a href="#hexo-主题介绍" class="headerlink" title="hexo 主题介绍"></a>hexo 主题介绍</h2><p>hexo 和 hugo 最大的优势我觉得就是主题库了，这里介绍几个个人感觉还不错的：</p><table><thead><tr><th>主题</th><th>风格</th><th>demo</th></tr></thead><tbody><tr><td><a href="https://github.com/yscoder/hexo-theme-indigo">Indigo</a></td><td>蓝色主题、简洁</td><td><a href="https://wuyang910217.github.io/">wuyang的个人博客</a></td></tr><tr><td><a href="https://github.com/jerryc127/hexo-theme-butterfly">butterfly</a></td><td>首页展示大幅背景图，表现力强</td><td><a href="https://yunist.cn/">云玩家</a></td></tr><tr><td><a href="https://github.com/Molunerfinn/hexo-theme-melody">melody</a></td><td>白色主题、简洁</td><td><a href="https://molunerfinn.com/">MARKSZのBlog</a></td></tr></tbody></table><p>其实自己也是后面看了这些主题的样式，才发现原来好多大神的个人站点都是通过 hexo 搭建的，有些前端技术比较厉害的，还会尝试自己去魔改，希望自己也有一天可以尝试一下</p><h2 id="本地搭建方式"><a href="#本地搭建方式" class="headerlink" title="本地搭建方式"></a>本地搭建方式</h2><h3 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h3><p><a href="https://github.com/hexojs/hexo">hexo</a> 是 node 开发的框架，所以需要通过 npm 来安装</p><blockquote><p>安装hexo 框架</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g hexo-cli</span><br></pre></td></tr></table></figure><blockquote><p>创建博客工程</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo init myblog</span><br></pre></td></tr></table></figure><blockquote><p>工程结构简述</p></blockquote><p><img src="/2021/08/13/hexo-blog/hexo_blog_04.png" alt="hexo structure"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">_config.yml: 主配置文件，后续修改主题之类的就是改这里</span><br><span class="line">themes: 主题目录</span><br><span class="line">scaffolds: 博客模板，通过 hexo new page 生成的页面都以这里的md 文件为模板</span><br><span class="line">source: 存放用户资源</span><br><span class="line">package.json: 本质上 hexo 博客还是一个前端项目，所以在这里管理依赖</span><br></pre></td></tr></table></figure><h3 id="设置主题"><a href="#设置主题" class="headerlink" title="设置主题"></a>设置主题</h3><p>这一步主要是在 <strong>themes</strong> 目录下，存放主题代码目录，这样 hexo 启动博客主页的时候，就是以你放的主题来生成了<br>有两种下载主题的方式：你可以直接将主题git 代码下载下来，放到themes 目录，或者是fork 一份主题仓库，通过 git submodule clone 一份代码。如果有兴趣自己做主题魔改，更建议后者</p><p>通过 git submodule 下载：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git submodule add git@github.com:主题仓库.git themes/主题名称</span><br></pre></td></tr></table></figure><p>下载完成之后，将_config.yml 中的主题名称修改一下<br><img src="/2021/08/13/hexo-blog/hexo_blog_05.png" alt="hexo structure"></p><p>安装渲染工具</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-renderer-pug hexo-renderer-stylus --save</span><br><span class="line">npm install --save hexo-renderer-pug hexo-renderer-jade hexo-generator-feed hexo-generator-sitemap hexo-browsersync hexo-generator-archive hexo-renderer-stylus</span><br></pre></td></tr></table></figure><h3 id="启动博客"><a href="#启动博客" class="headerlink" title="启动博客"></a>启动博客</h3><blockquote><p>清理静态文件</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo clean</span><br></pre></td></tr></table></figure><blockquote><p>生成静态文件</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo g</span><br></pre></td></tr></table></figure><blockquote><p>启动服务</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">hexo server -w -p 3000</span><br><span class="line"></span><br><span class="line"># 启动服务</span><br><span class="line"># -w: watch，监听文件变化</span><br><span class="line"># -p: port，启动端口</span><br></pre></td></tr></table></figure><p>到这一步完成，博客基本框架就算搭建成功了~</p><h2 id="基本配置的介绍"><a href="#基本配置的介绍" class="headerlink" title="基本配置的介绍"></a>基本配置的介绍</h2><p>这里我们对一些博客配置做简单的了解，方便后续进行主题设置。当然博客部署完成之后，也可以直接部署到github 上，先不管这些配置。你也可以直接跳到下一节内容进行参考。<br>如果想了解大部分的配置，建议参考下面的官方教程<br><a href="https://butterfly.js.org/posts/4aa8abbe">参考-官方教程</a></p><h3 id="网站信息"><a href="#网站信息" class="headerlink" title="网站信息"></a>网站信息</h3><p>站点基本配置</p><p><img src="/2021/08/13/hexo-blog/hexo_blog_06.png" alt="blog config"></p><p>头像和首页背景图</p><p><img src="/2021/08/13/hexo-blog/hexo_blog_07.png" alt="head config"></p><h3 id="文章"><a href="#文章" class="headerlink" title="文章"></a>文章</h3><p>文章封面: 设置cover属性<br><img src="/2021/08/13/hexo-blog/hexo_blog_08.png" alt="blog top img config"></p><p>效果:<br><img src="/2021/08/13/hexo-blog/hexo_blog_09.png" alt="blog top img show"></p><h3 id="顶部栏"><a href="#顶部栏" class="headerlink" title="顶部栏"></a>顶部栏</h3><p><img src="/2021/08/13/hexo-blog/hexo_blog_10.png" alt="blog top config"></p><p>其中，标签、分类页面可通过下面的指令新建:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo new page tags</span><br><span class="line">hexo new page categories</span><br></pre></td></tr></table></figure><h2 id="部署到github站点"><a href="#部署到github站点" class="headerlink" title="部署到github站点"></a>部署到github站点</h2><h3 id="github-创建仓库"><a href="#github-创建仓库" class="headerlink" title="github 创建仓库"></a>github 创建仓库</h3><p>github 能够识别 用户名.github.io 的仓库名，并部署这个仓库的静态文件生成站点，站点地址就是 用户名.github.io<br><img src="/2021/08/13/hexo-blog/hexo_blog_11.png" alt="blog deploy config"></p><h3 id="配置准备"><a href="#配置准备" class="headerlink" title="配置准备"></a>配置准备</h3><p>修改博客根目录的 config.yml 文件:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repo: &lt;repository url&gt; #https://bitbucket.org/JohnSmith/johnsmith.bitbucket.io</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure><p>这样先执行 <strong>hexo g</strong> 生成静态文件之后，再执行 <strong>hexo d</strong> 就可以将静态文件 提交到站点仓库上了<br>如果是在本地开发，建议 repo 配置成 ssh 的地址，部署更方便</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>天下无难事 – 其实很早就看到过，这次尝试自己搭建，其实不麻烦<br>当然，要真正做成一个内容丰富的个人博客站点，还是要慢慢积累丰富的内容才行。有的大神就纯做技术博客（比如<a href="https://www.liaoxuefeng.com/">廖雪峰</a>），有的大神则搞一些炫酷的效果（如<a href="https://www.yunyoujun.cn/about/">云游君的小站</a>），最后都能做得很有知名度。当然，最重要的还是要有核心的技术，博客积累关键还是在于个人的技术积累。<br>所以，慢慢来吧，共勉</p>]]></content>
    
    
    <summary type="html">从0开始搭建个人博客</summary>
    
    
    
    <category term="开发工具" scheme="http://smiecj.github.io/categories/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"/>
    
    <category term="hexo" scheme="http://smiecj.github.io/categories/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/hexo/"/>
    
    
    <category term="个人博客" scheme="http://smiecj.github.io/tags/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"/>
    
    <category term="hexo" scheme="http://smiecj.github.io/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>Golang 常见的10种错误</title>
    <link href="http://smiecj.github.io/2021/07/18/golang-mistakes/"/>
    <id>http://smiecj.github.io/2021/07/18/golang-mistakes/</id>
    <published>2021-07-17T16:00:00.000Z</published>
    <updated>2021-07-17T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://itnext.io/the-top-10-most-common-mistakes-ive-seen-in-go-projects-4b79d4f6cd65#e9ba">原文链接</a></p><p>前言：这里提到的错误，并不是那种“致命错误”，而是业务中的使用习惯的问题。如果不够了解语言的设计方式，导致使用习惯不当，可能就会引入一些设计不够好的代码。因此学习这些前人对使用方式的总结是很有帮助的。<br>话不多说，一起来看看都有哪些常见易犯的错误：</p><h3 id="一、枚举默认值和json反序列化"><a href="#一、枚举默认值和json反序列化" class="headerlink" title="一、枚举默认值和json反序列化"></a>一、枚举默认值和json反序列化</h3><p>先来看一段枚举的定义：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">type Status uint32</span><br><span class="line"></span><br><span class="line">const (</span><br><span class="line">  StatusOpen Status = iota</span><br><span class="line">  StatusClosed</span><br><span class="line">  StatusUnknown</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>然后业务结构体 Request 引用了这个枚举</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">type Request struct &#123;</span><br><span class="line">  ID        int    `json:&quot;Id&quot;`</span><br><span class="line">  Timestamp int    `json:&quot;Timestamp&quot;`</span><br><span class="line">  Status    Status `json:&quot;Status&quot;`</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后就是常见的接口之后的反序列化过程了，如果是正常的接口返回，如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;Id&quot;: 1234,</span><br><span class="line">  &quot;Timestamp&quot;: 1563362390,</span><br><span class="line">  &quot;Status&quot;: 0</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么反序列化之后应该也是很正常的，调用方拿到了下游返回的状态信息，状态也都对得上。<br>但是如果下游有问题，没有返回这个状态：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;Id&quot;: 1235,</span><br><span class="line">  &quot;Timestamp&quot;: 1563362390</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个时候后台拿到的状态是什么？又应该是什么？可以直接写段代码测试一下。</p><p>最终：一个更健壮的枚举定义：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">type Status uint32</span><br><span class="line"></span><br><span class="line">const (</span><br><span class="line">  StatusUnknown Status = iota</span><br><span class="line">  StatusOpen</span><br><span class="line">  StatusClosed</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>别看是一个小问题，影响可不小，如果结构体设计阶段没有考虑到这个问题，需要发版之后再修复，可能要改的还有下游的结构体定义，而如果结构体是放在公共的pb 文件中，要改pb ，那么要影响到的服务可能就更多了。<br>所以元数据的定义永远是基础，牵一发而动全身。设计的时候还是要更考虑周全一些。需要从 业务逻辑转换成编程思维，考虑到更多的细节。<br><a href="https://github.com/smiecj/go_common_mistake/blob/master/error_test.go">参考测试代码-enum_test.go</a></p><h3 id="二、BenchMarking和内联"><a href="#二、BenchMarking和内联" class="headerlink" title="二、BenchMarking和内联"></a>二、BenchMarking和内联</h3><p><a href="https://segmentfault.com/a/1190000039146279">参考博客-详解Go内联优化</a></p><p>性能测试相关的代码，往往需要重复执行，如果写法不当，就很容易导致内联的问题：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">func clear(n uint64, i, j uint8) uint64 &#123;</span><br><span class="line">return (math.MaxUint64&lt;&lt;j | ((1 &lt;&lt; i) - 1)) &amp; n</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func BenchmarkCleanBit(b *testing.B) &#123;</span><br><span class="line">for i := 0; i &lt; b.N; i++ &#123;</span><br><span class="line">clear(1221892080809121, 10, 63)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里先说明一下 testing.B 这个类的功能：它表示基准测试，在测试结束之后将会输出一段性能测试的结果<br>测试方法必须是 BenchMark 开头，另外执行测试需要带上 bench 参数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go test -bench=. benchmark_test.go</span><br></pre></td></tr></table></figure><p>测试结果：</p><p>goos: windows<br>goarch: amd64<br>pkg: github.com/smiecj/go_common_mistake<br>BenchmarkCleanBit<br>BenchmarkCleanBit-8     1000000000           <strong>0.339 ns/op</strong><br>PASS</p><p>但是接下来要说到问题了：由于 clear 方法没有执行其他方法的调用，没有边际效应，所以会被内联，再加上其返回值也没有被外层接收，所以又会被进一步优化掉，直接不会执行。所以其实测试结果是不准的。<br>怎么确认 clear 方法被内联了呢？可以通过编译参数确认：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go test -gcflags=&quot;-m&quot; -bench=. benchmark_test.go</span><br></pre></td></tr></table></figure><blockquote><p>-gcflags=”-m”: 打印编译过程中 golang 解析产生内联的详细过程</p></blockquote><p>所以验证的方式也很简单，只要避免内联就可以了。结合这个性能测试的示例，大概有两种方式：<br>① 在 BenchMark 中设置一个局部变量去接收返回值</p><p>② clear 方法最上面设置取消内联</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//go:noinline</span><br><span class="line">func clear(n uint64, i, j uint8) uint64 &#123;</span><br><span class="line">  return (math.MaxUint64&lt;&lt;j | ((1 &lt;&lt; i) - 1)) &amp; n</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>新的测试结果：<br>goos: windows<br>goarch: amd64<br>pkg: github.com/smiecj/go_common_mistake<br>BenchmarkCleanBit<br>BenchmarkCleanBit-8     426727659          <strong>2.96 ns/op</strong><br>PASS</p><p>③ 设置编译参数 -l 禁止内联</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go test -gcflags=&quot;-N -l -m&quot; -bench=. benchmark_test.go</span><br></pre></td></tr></table></figure><blockquote><p>-N：禁止编译优化<br>-l：禁止内联</p></blockquote><p>测试结果：<br>goos: windows<br>goarch: amd64<br>BenchmarkCleanBit-8     376172835                <strong>3.13 ns/op</strong><br>PASS<br>ok      command-line-arguments  2.361s</p><p>扩展阅读：<br><a href="https://dave.cheney.net/high-performance-go-workshop/dotgo-paris.html">High Performance Go Workshop</a></p><h3 id="三、每次传参都应该用指针吗？"><a href="#三、每次传参都应该用指针吗？" class="headerlink" title="三、每次传参都应该用指针吗？"></a>三、每次传参都应该用指针吗？</h3><p>首先，就传递数据量来说，指针毫无疑问，在大多数时候还是更省空间的。（64位系统中是8个字节）</p><p>看起来似乎指针总比传值更好，对吧？其实不是的，我们可能只关注了参数本身的空间开销，却忽略了指针和值分别在栈和堆上的存储开销。<br>先从方法的返回值去理解返回参数和返回指针的区别，来看个例子: </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">func getFooValue() foo &#123;</span><br><span class="line">  var result foo</span><br><span class="line">  // Do something</span><br><span class="line">  return result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法内部新建了result对象，这个对象只可能被方法内部访问，所以这个对象分配的空间就在栈上，不会在堆上。<br>然后，方法直接返回了值本身，这个动作会生成一份result的拷贝，存储在调用方的栈上，原result因为不会再被访问，将等待被GC回收。</p><p>再来看返回指针的情况:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">func main()  &#123;</span><br><span class="line">  p := &amp;foo&#123;&#125;</span><br><span class="line">  f(p)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Go只有传值，所以对于指针p来说，它的空间申请和传递，都是和上一个例子一样的。但是对于foo对象本身，申请的时候必然不会在栈上申请，而会在堆上申请。这样才能让作用域扩大到调用方。</p><p>栈比堆更快的两个原因:</p><ul><li>栈上对象不需要GC，从上面的例子可以看到，除非返回指针，否则栈内的一切对象都跟调用方没有任何关系，都是拷贝后返回，因此可以在方法结束后直接被标记。</li><li>栈上对象只会在当前routine被使用，不需要和其他协程同步，也就不会在堆上记录任何状态信息</li></ul><p>总结来说，就是不管是传参还是返回，只要非共享的场景（当然，复合数据结构如map一般都是需要共享的），都建议传value，只有一定要传指针的时候才去传指针。</p><p>扩展阅读<br><a href="https://www.ardanlabs.com/blog/2017/05/language-mechanics-on-stacks-and-pointers.html">Language Mechanics On Stacks And Pointers</a></p><h3 id="四、break和条件控制语句"><a href="#四、break和条件控制语句" class="headerlink" title="四、break和条件控制语句"></a>四、break和条件控制语句</h3><p>如下面这段代码，break 真的能够跳出循环吗？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">for &#123;</span><br><span class="line">  switch f() &#123;</span><br><span class="line">  case true:</span><br><span class="line">    break</span><br><span class="line">  case false:</span><br><span class="line">    // Do something</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>答案：break 其实是跳出 switch 的循环。但是golang 的switch 执行完成一个分支之后其他分支也不会执行的，所以 switch 的 break 其实没有什么意义</p><p>但是select 的break 就有意义了。所以下面这种情况也是要特别注意的，break 跳出的也不是循环<br>for {<br>  select {<br>  case &lt;-ch:<br>  // Do something<br>  case &lt;-ctx.Done():<br>    break<br>  }<br>}</p><p>常见的退出循环+switch的方式：break + 代码块名称</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">OuterLoop:</span><br><span class="line">  for i = 0; i &lt; n; i++ &#123;</span><br><span class="line">    for j = 0; j &lt; m; j++ &#123;</span><br><span class="line">      switch a[i][j] &#123;</span><br><span class="line">      case nil:</span><br><span class="line">        state = Error</span><br><span class="line">        break OuterLoop</span><br><span class="line">      case item:</span><br><span class="line">        state = Found</span><br><span class="line">        break OuterLoop</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3 id="五、错误管理"><a href="#五、错误管理" class="headerlink" title="五、错误管理"></a>五、错误管理</h3><p>error的处理一般满足两个原则：处理了就不要再向上继续抛出，必须给上层返回不一样的信息；没处理就一定要继续向上抛出</p><p>而go1.13之前提供的error 管理方法其实很少，所以这里我们使用 pkg/errors 这个工具来帮我们更好地管理自定义错误：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">import &quot;github.com/pkg/errors&quot;</span><br><span class="line">......</span><br><span class="line">func postHandler(customer Customer) Status &#123;</span><br><span class="line">  err := insert(customer.Contract)</span><br><span class="line">  if err != nil &#123;</span><br><span class="line">    switch errors.Cause(err).(type) &#123;</span><br><span class="line">    default:</span><br><span class="line">      log.WithError(err).Errorf(&quot;unable to serve HTTP POST request for customer %s&quot;, customer.ID)</span><br><span class="line">      return Status&#123;ok: false&#125;</span><br><span class="line">    case *db.DBError:</span><br><span class="line">      return retry(customer)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">  return Status&#123;ok: true&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func insert(contract Contract) error &#123;</span><br><span class="line">  err := db.dbQuery(contract)</span><br><span class="line">  if err != nil &#123;</span><br><span class="line">    return errors.Wrapf(err, &quot;unable to insert customer contract %s&quot;, contract.ID)</span><br><span class="line">  &#125;</span><br><span class="line">  return nil</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意到判断错误类型使用对象的type判断就可以了，<strong>Cause</strong>和<strong>Wrapf</strong>需要配套使用</p><h3 id="六、数组初始化"><a href="#六、数组初始化" class="headerlink" title="六、数组初始化"></a>六、数组初始化</h3><h4 id="6-1-len-和-cap"><a href="#6-1-len-和-cap" class="headerlink" title="6.1 len 和 cap"></a>6.1 len 和 cap</h4><p>我们知道数组有两个初始化参数，分别表示len和cap，分别表示长度和初始化长度。<br>比如初始化一个空数组：<br>var bars []Bar<br>bars := make([]Bar, 0, 0)</p><p>和Java不同的是，go把 cap 设置也半交给用户了（当不配置cap 的时候，len 就是 cap）。但是这也<br>比如当我们把 cap 设置成负数，或者小于 len 的时候，会发生什么呢？<br>直接测试一下：<br><img src="https://img-blog.csdnimg.cn/20210718103648191.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3hpYW9saWl6aQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>可以看到编译期 就已经直接报错了，不会让你能够执行这样的代码。我们可以从types/expr.go 中找到具体报错信息打印的地方。</p><h4 id="6-2-设置len-还是-cap-的效率高"><a href="#6-2-设置len-还是-cap-的效率高" class="headerlink" title="6.2 设置len 还是 cap 的效率高"></a>6.2 设置len 还是 cap 的效率高</h4><p>来看一种比较常见的场景：需要把数据库的对象转换成对外接口传递的对象。对象数量是确定的，需要怎么做呢？<br>有两种实现方式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">func convert(foos []Foo) []Bar &#123;</span><br><span class="line">  bars := make([]Bar, len(foos))</span><br><span class="line">  for i, foo := range foos &#123;</span><br><span class="line">    bars[i] = fooToBar(foo)</span><br><span class="line">  &#125;</span><br><span class="line">  return bars</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">func convert(foos []Foo) []Bar &#123;</span><br><span class="line">  bars := make([]Bar, 0, len(foos))</span><br><span class="line">  for _, foo := range foos &#123;</span><br><span class="line">    bars = append(bars, fooToBar(foo))</span><br><span class="line">  &#125;</span><br><span class="line">  return bars</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实两种实现方式都可以，但是前者效率显然高一些，因为空间是已经分配好的，而后者虽然cap 设定了，但是随着 不断append 元素，底层也是要不断地进行数组的拷贝的。</p><blockquote><p>译者：文章这里基本没有从源码说明效率高的原因，后续考虑新开一篇，从makeslice 方法去分析两种方式真正的差异</p></blockquote><h3 id="七、context-管理"><a href="#七、context-管理" class="headerlink" title="七、context 管理"></a>七、context 管理</h3><h4 id="7-1-什么是context"><a href="#7-1-什么是context" class="headerlink" title="7.1 什么是context"></a>7.1 什么是context</h4><p>官方概念：<br>A Context carries a deadline, a cancelation signal, and other values across API boundaries.</p><p>这里说明了context可以带的三类信息：deadline（超时配置）、cancelation（终止动作）和values（键值对）</p><h4 id="7-2-什么时候应该用context"><a href="#7-2-什么时候应该用context" class="headerlink" title="7.2 什么时候应该用context"></a>7.2 什么时候应该用context</h4><p>前两个信息是context最常用的信息和功能，最常用的场景就是rpc调用，来看看一个grpc使用示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ctx, cancel := context.WithTimeout(parent, 100 * time.Millisecond)</span><br><span class="line">response, err := grpcClient.Send(ctx, request)</span><br></pre></td></tr></table></figure><p>WithTimeout 方法内部就是设置了 deadline，context 将会在超时时间到来的时候触发 Done 对应的channel close。这样我们可以通过 &lt;- context.Done) 来做一些提前结束的操作，比如释放资源，避免超时请求一直阻塞其他正常请求。</p><p>总结一下，凡是涉及到上下游关系的都应该用context来处理调用关系，下游不应该忽略上游传下来的context。</p><p>扩展阅读：<br><a href="http://p.agnihotry.com/post/understanding_the_context_package_in_golang/">Understanding the context package in golang</a></p><h3 id="八、从来不用-race-参数"><a href="#八、从来不用-race-参数" class="headerlink" title="八、从来不用 -race 参数"></a>八、从来不用 -race 参数</h3><p>根据 报告-Understanding real-world concurrency bugs in Go ，尽管go 的设计初衷是“更少错误的高并发”，但是现实中我们依然会遇到并发带来的问题<br>尽管 race 检测器不一定可以检测出每一种并发错误，但是它依然是有价值的，在测试程序的过程中我们应该始终打开它。</p><p>相对其余9个错误来说，竞态条件是能直接导致程序崩溃的，所以这一节应该是最重要的一部分，建议gopher 在平时开发中都尽量留意这一点，测试和调试工作要做好。<br>但是 开启race 也不代表 冲突能够马上检查出来，也是要有冲突的时候，才会有Warning信息。所以建议采用线上环境留一个节点用来开启竞态检查的方式。</p><p>扩展阅读：<br><a href="https://blog.acolyer.org/2019/05/17/understanding-real-world-concurrency-bugs-in-go/">Understanding real-world concurrency bugs in Go</a><br><a href="https://medium.com/@val_deleplace/does-the-race-detector-catch-all-data-races-1afed51d57fb">Does the Go race detector catch all data race bugs?</a><br><a href="https://github.com/smiecj/go_common_mistake/blob/master/race_test.go">自己写的示例-git-race_test.go</a></p><h3 id="九、使用文件名作为输入（方法设计不满足SOLID原则）"><a href="#九、使用文件名作为输入（方法设计不满足SOLID原则）" class="headerlink" title="九、使用文件名作为输入（方法设计不满足SOLID原则）"></a>九、使用文件名作为输入（方法设计不满足SOLID原则）</h3><h4 id="9-1-从问题出发"><a href="#9-1-从问题出发" class="headerlink" title="9.1 从问题出发"></a>9.1 从问题出发</h4><p>来看一个常见的go 工具类开发需求：需要开发一个通用的读取文件行数的方法。项目中肯定会把这个方法封装到公共包的。<br>一种比较直接的思路，就是设置文件名作为传参，如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">func count(filename string) (int, error) &#123;</span><br><span class="line">  file, err := os.Open(filename)</span><br><span class="line">  if err != nil &#123;</span><br><span class="line">    return 0, errors.Wrapf(err, &quot;unable to open %s&quot;, filename)</span><br><span class="line">  &#125;</span><br><span class="line">  defer file.Close()</span><br><span class="line"></span><br><span class="line">  scanner := bufio.NewScanner(file)</span><br><span class="line">  count := 0</span><br><span class="line">  for scanner.Scan() &#123;</span><br><span class="line">    if scanner.Text() == &quot;&quot; &#123;</span><br><span class="line">      count++</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return count, nil</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种方式看上去功能没有任何问题，但是忽略了具体使用场景。如：</p><ul><li>文件编码：当然你可以让方法增加一个传参，但是不符合接下来说到的开闭原则</li><li>单元测试：测试读取一个空文件场景。那么单测可能还需要先在本地创建一个空文件</li></ul><p>这些细节，都会导致这个方法看上去完美，实际使用起来限制却很多。</p><h4 id="9-2-SOLID-原则"><a href="#9-2-SOLID-原则" class="headerlink" title="9.2 SOLID 原则"></a>9.2 SOLID 原则</h4><p>SOLID 是面向对象编程中很重要的原则，由 总结而来。</p><ul><li>S 表示  Single Responsibility （单一原则）：一个方法只做一件事</li><li>O 表示 open-close principle （开闭原则）：方法对扩展开放，对修改封闭</li></ul><p>从这个例子就是很好的说明：S 和 O 它实际都不满足，方法做了读取文件和扫描文件行数两件事、方法可能还需要因为文件编码做格式 做适配修改</p><h4 id="9-3-优化版本"><a href="#9-3-优化版本" class="headerlink" title="9.3 优化版本"></a>9.3 优化版本</h4><p>借鉴 go 对 io.Reader 和 io.Writer 的实现思路，我们可以将传参改成这样：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">func count(reader *bufio.Reader) (int, error) &#123;</span><br><span class="line">  count := 0</span><br><span class="line">  for &#123;</span><br><span class="line">    line, _, err := reader.ReadLine()</span><br><span class="line">    if err != nil &#123;</span><br><span class="line">      switch err &#123;</span><br><span class="line">      default:</span><br><span class="line">        return 0, errors.Wrapf(err, &quot;unable to read&quot;)</span><br><span class="line">      case io.EOF:</span><br><span class="line">        return count, nil</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if len(line) == 0 &#123;</span><br><span class="line">      count++</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样不仅满足和 S 和 O，方法的扩展性其实也加强了：可以读取文件流或者 http 流等的输入</p><p>调用端：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">file, err := os.Open(filename)</span><br><span class="line">if err != nil &#123;</span><br><span class="line">  return errors.Wrapf(err, &quot;unable to open %s&quot;, filename)</span><br><span class="line">&#125;</span><br><span class="line">defer file.Close()</span><br><span class="line">count, err := count(bufio.NewReader(file))</span><br></pre></td></tr></table></figure><p>单测：读取一行字符串流</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">count, err := count(bufio.NewReader(strings.NewReader(&quot;input&quot;)))</span><br></pre></td></tr></table></figure><p>因此，设计思想也非常重要，尽管代码规范之类的问题并不会直接导致程序运行问题，但是显然它的影响更为深远。</p><h3 id="十、协程和循环中的局部变量"><a href="#十、协程和循环中的局部变量" class="headerlink" title="十、协程和循环中的局部变量"></a>十、协程和循环中的局部变量</h3><h4 id="10-1-协程共用循环的局部变量"><a href="#10-1-协程共用循环的局部变量" class="headerlink" title="10.1 协程共用循环的局部变量"></a>10.1 协程共用循环的局部变量</h4><p>下面这段示例，会输出什么？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">func TestRoutineRace(t *testing.T) &#123;</span><br><span class="line">ints := []int&#123;1, 2, 3&#125;</span><br><span class="line">waitGroup := sync.WaitGroup&#123;&#125;</span><br><span class="line">waitGroup.Add(len(ints))</span><br><span class="line"></span><br><span class="line">for _, i := range ints &#123;</span><br><span class="line">go func() &#123;</span><br><span class="line">fmt.Printf(&quot;%v\n&quot;, i)</span><br><span class="line">waitGroup.Done()</span><br><span class="line">&#125;()</span><br><span class="line">&#125;</span><br><span class="line">waitGroup.Wait()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>显然目的是想打印 1、2、3的，但是结果却都是3<br>这是因为 子协程中，打印用的都是同一个局部变量i，这个i 在循环结束之后会变成3，所以最终打印的结果就都是3 了（大部分时候）</p><p>利用刚才学的race，这种使用协程的错误方式也可以通过 -race 参数 提前检测出来。<br>go test -v <strong>-race</strong> routine_test.go<br>检测结果：<br>……<br>WARNING: DATA RACE<br><strong>Read at 0x00c000116140 by goroutine 8:</strong><br>  command-line-arguments.TestRoutine.func1()<br>      D:/coding/golang/go_common_mistake/routine_test.go:16 +0x44</p><p><strong>Previous write at 0x00c000116140 by goroutine 7:</strong><br>  command-line-arguments.TestRoutine()<br>      D:/coding/golang/go_common_mistake/routine_test.go:14 +0x104<br>  testing.tRunner()<br>      G:/Program Files/Go/src/testing/testing.go:1127 +0x202<br>……</p><p>从错误信息可以看到，省略的部分还有其他协程，同样的警告信息。仔细分析下来就可以得到协程用的都是同一个局部变量的结论了。<br>怎么样，马上就体验到 -race 参数的作用了，是不是很妙</p><h4 id="10-2-避免直接使用循环中的局部变量"><a href="#10-2-避免直接使用循环中的局部变量" class="headerlink" title="10.2 避免直接使用循环中的局部变量"></a>10.2 避免直接使用循环中的局部变量</h4><p>对于这种情况有两种解决方法：<br>1）go func 加上入参</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">for _, i := range ints &#123;</span><br><span class="line">go func(i int) &#123;</span><br><span class="line">fmt.Printf(&quot;%v\n&quot;, i)</span><br><span class="line">waitGroup.Done()</span><br><span class="line">&#125;(i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2）循环内使用单独的局部变量<br><img src="/img/20210718105358253.png" alt="在这里插入图片描述"></p><p>注意虽然这里的I 依然是局部变量，但是对每个开启的协程来说已经不是同一个了，每次进入循环的I 都是不一样的。<br>但是这里我更推荐第一种写法，逻辑更加清楚</p>]]></content>
    
    
    <summary type="html">都是干货</summary>
    
    
    
    <category term="编程语言" scheme="http://smiecj.github.io/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    <category term="golang" scheme="http://smiecj.github.io/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/golang/"/>
    
    
    <category term="golang" scheme="http://smiecj.github.io/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>Docker Desktop 安装教程，以及推荐Docker作为学习工具的理由</title>
    <link href="http://smiecj.github.io/2021/07/03/docker-desktop/"/>
    <id>http://smiecj.github.io/2021/07/03/docker-desktop/</id>
    <published>2021-07-02T16:00:00.000Z</published>
    <updated>2022-10-07T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://blog.csdn.net/xiaoliizi/article/details/118438413">本文csdn地址</a></p><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><a href="https://mp.weixin.qq.com/s/bmvELL89wtOqJuZjyv6bJw">博客-Docker-搭建可用SSH访问的centos镜像</a></p><p>2年前我写了一篇 关于如何在本地安装Docker 的教程），但是当时安装 Docker Desktop 还需要开启 hyper-v 或者是安装 toolbox 才能开启虚拟化。这两种情况下配置各有不同，而且也都需要配置环境变量，安装过程还是比较麻烦的。</p><p>但是现在有了 wsl2，在 windows 上使用 Docker 开发 更加方便了。本质上，wsl2 还是依赖hyper-v 技术，启动速度不慢，也不需要单独安装其他虚拟机，配置起来也更加方便。</p><p>不过wsl2 的方便性可以说是锦上添花，docker 最大的好处，我认为还是在相比虚拟机来说，它拥有和git 类似的<strong>仓库管理、版本</strong>等属性，有了这些基础，才有了作为开发工具的高效性。这才是我真正推荐它的原因。</p><p><strong>这篇博客主要就是帮大家避坑，把docker desktop 安装之后需要预设的配置尽量说明清楚，让大家可以安心地 在win10 系统上安装 Docker Desktop，以及提供一个基础开发镜像，帮助大家以后学习新技术能够更加方便。</strong></p><p><a href="https://docs.microsoft.com/zh-cn/windows/wsl/">wsl官网</a></p><h1 id="安装-docker-desktop"><a href="#安装-docker-desktop" class="headerlink" title="安装 docker desktop"></a>安装 docker desktop</h1><h2 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h2><h3 id="配置wsl"><a href="#配置wsl" class="headerlink" title="配置wsl"></a>配置wsl</h3><p>前提：本机已经安装了 wsl （参考<a href="https://learn.microsoft.com/en-us/windows/wsl/install-manual">官方教程</a>，使用docker 到第五步 Set WSL 2 as your default version完成就可以了。最新版本的win10 应该是自带的）<br>检查wsl 是否有安装：<br>到windows 功能中查找选项：适用于linux 的 windows 子系统</p><p>然后是限制 wsl 使用的资源：默认情况下，一旦你开启的镜像需要比较多资源，系统资源就会被直接吃满。<br>所以一定要记得设置wsl 占用资源配置，配置方式如下：<br>Win+R 然后输入 %UserProfile%  进入用户文件夹<br>然后编辑 .wslconfig 输入以下内容：(具体数值根据实际情况调整)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[wsl2]</span><br><span class="line">memory=4GB</span><br><span class="line">swap=5GB</span><br><span class="line">processors=5</span><br><span class="line">localhostForwarding=true</span><br></pre></td></tr></table></figure><p>memory: 内存<br>swap: 虚拟内存<br>processors: 处理器数量，当前电脑的processor 数量可以通过 wmic 指令获取<br>LocalhostForwarding: 允许本地通过 localhost 访问 wsl，默认就是开启<br><a href="https://docs.microsoft.com/en-us/windows/wsl/release-notes#build-18945">更多参数的说明</a></p><p>然后重启 lxss manager (即wsl服务)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">net stop LxssManager</span><br><span class="line">net start LxssManager</span><br></pre></td></tr></table></figure><p>最后是设置wsl 的数据存储路径，这个在安装 Docker Desktop 完成之后可以添加上去，参考下面的说明。</p><h3 id="注册一个-dockerhub-账号-和-国内云厂商-容器服务"><a href="#注册一个-dockerhub-账号-和-国内云厂商-容器服务" class="headerlink" title="注册一个 dockerhub 账号 和 国内云厂商 容器服务"></a>注册一个 dockerhub 账号 和 国内云厂商 容器服务</h3><p>账号本身 不影响 Docker Desktop  启动 ，但是还是建议体验一下容器镜像服务。容器镜像管理的方式类似git 代码，可以把自己后续学习其他技术的过程中 ，搭建好的镜像提交到云端，做备份用。也方便共享。<br>下面几个镜像服务提供商，个人版本都是免费的。不过主推还是国内的镜像服务，传输速度快一点。<br><a href="https://www.aliyun.com/product/acr">阿里云镜像服务</a>（前言中引的博客中有说明注册方式）<br><a href="https://cloud.tencent.com/document/product/1141">腾讯云镜像服务</a><br><a href="https://hub.docker.com/">dockerhub</a>（建议开启代理访问）</p><h2 id="安装-Desktop"><a href="#安装-Desktop" class="headerlink" title="安装 Desktop"></a>安装 Desktop</h2><p>首先从官网下载 最新版本，直接安装即可<br>安装完成之后，可以先测试是否能正常启动，其他配置可以慢慢来改，kubernetes 也不急着安装。</p><h2 id="2-3-Docker-Desktop-的配置"><a href="#2-3-Docker-Desktop-的配置" class="headerlink" title="2.3 Docker Desktop 的配置"></a>2.3 Docker Desktop 的配置</h2><h3 id="wsl-数据存储路径"><a href="#wsl-数据存储路径" class="headerlink" title="wsl 数据存储路径"></a>wsl 数据存储路径</h3><p>第一次成功启动 docker desktop 之后，你可以在 C:\Users\用户名\AppData\Local\Docker\wsl\data 这个目录下，找到ext4 文件，它就是 wsl 使用的虚拟机文件，我们使用docker 的所有操作和下载的所有文件，都会在这个目录中执行。<br>因此如果默认系统分了系统盘和数据盘，或者是我们有其他空间更大的硬盘可选，那么有必要将 这个ext4盘文件 进行迁移<br>注: 考虑到不管是在开发过程中，是轻量还是大量使用 docker desktop，最后 docker 都会占不小空间，建议第一次启动 docker desktop 之后就进行迁移，至少不要放在系统盘</p><p><img src="/2021/07/03/docker-desktop/desktop01.png" alt="wsl"></p><p>更新：20221008 发现一个工具可以帮我们快速迁移，比之前使用 wsl 指令，还需要先导出，再导入的操作稍微简单一些</p><p><a href="https://blog.csdn.net/qq_41601836/article/details/106610576">参考 - 如何修改WSL的安装路径</a></p><p><a href="https://github.com/DDoSolitary/LxRunOffline/releases/tag/v3.5.0">工具下载地址</a></p><p>迁移方式：先确认需要迁移的 wsl 名称：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./LxRunOffline.exe list</span><br></pre></td></tr></table></figure><p><img src="/2021/07/03/docker-desktop/desktop02.png" alt="wsl list"></p><p>然后执行迁移：（需要先关闭 docker desktop, 迁移需要一定时间）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./LxRunOffline.exe move -n docker-desktop-data -d &#x27;D:\wsl&#x27;</span><br></pre></td></tr></table></figure><p>== 以下是旧的迁移方式 ==</p><p>迁移步骤：首先退出 docker desktop ，并检查docker desktop 对应的虚拟机的状态，应该都要是关闭状态</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wsl --list -v</span><br></pre></td></tr></table></figure><p><img src="/2021/07/03/docker-desktop/desktop03.png" alt="查看wsl 状态"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wsl --export docker-desktop-data &quot;C:\Users\用户名\AppData\Local\Docker\wsl\data\docker-desktop-data.tar&quot;</span><br></pre></td></tr></table></figure><p>将目前的wsl 磁盘文件导出到指定压缩文件中</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wsl --unregister docker-desktop-data</span><br></pre></td></tr></table></figure><p>卸载docker-desktop-data服务</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wsl --import docker-desktop-data &quot;D:\docker\wsl\data&quot; &quot;D:\docker\wsl\docker-desktop-data.tar&quot; --version 2</span><br></pre></td></tr></table></figure><p>导入刚才导出的 wsl 磁盘文件<br>最后，重启 docker desktop，正常来说：<br>① docker 可以正常启动<br>② 原目录的 ext4 文件没有了（Distro 下面也有一个 ext4 文件，这个没关系）</p><h3 id="配置代理"><a href="#配置代理" class="headerlink" title="配置代理"></a>配置代理</h3><p>代理基本是开发过程中必备的，但是如果你使用的镜像服务是国内的，那么提交、下载镜像的时候又不应该走代理，所以需要在代理上额外配置一下：<br><img src="https://img-blog.csdnimg.cn/20210703230104617.png" alt="proxy"></p><p>如：使用阿里云镜像的代理配置<br>localhost,127.0.0.1,*.aliyuncs.com</p><h3 id="测试拉取并运行镜像"><a href="#测试拉取并运行镜像" class="headerlink" title="测试拉取并运行镜像"></a>测试拉取并运行镜像</h3><p>这里我们测试一个可直接通过 ssh 连接的镜像：jdeathe/centos-ssh<br><a href="https://github.com/jdeathe/centos-ssh">Git地址</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker pull jdeathe/centos-ssh</span><br><span class="line"></span><br><span class="line">docker run -d --env &quot;SSH_PASSWORD_AUTHENTICATION=true&quot; --env &quot;SSH_USER=centos&quot; --env &quot;SSH_USER_PASSWORD=test123&quot; --name ssh.1 -p 30022:22 jdeathe/centos-ssh</span><br></pre></td></tr></table></figure><p>除了启动命令的学习，这个仓库提供的Dockefile 非常标准化，是直接基于centos 原生镜像 在其基础上改的，从Dockerfile中也能看到非常多标准化的操作，想要学习 centos 原生镜像初始化细节的可以从这个项目的Dockerfile中了解更多细节。</p><h1 id="搭建自己的开发服务器"><a href="#搭建自己的开发服务器" class="headerlink" title="搭建自己的开发服务器"></a>搭建自己的开发服务器</h1><p>这里提供一个自己平时开发用的镜像，里面安装了一些开发语言的基本环境，如 ：java<br>其中，语言下载的依赖（比如 maven、gopath）都统一放在 /home/path 目录下，安装的组件都放在 /home/modules 下。</p><p><a href="https://github.com/smiecj/docker-centos">项目git地址（smiecj/docker-centos）</a><br>镜像下载和启动方式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># dockerfiles 中添加项目中的 Dockerfile 文件</span><br><span class="line">docker build dockerfiles/</span><br><span class="line"></span><br><span class="line">docker run -e &quot;ROOT_PWD=设定root密码&quot; --name centos_dev -d --privileged -p 设定本地ssh端口:22 mzsmieli/centos_dev</span><br></pre></td></tr></table></figure><p>ROOT_PWD 可以设置 root 登录密码，也可以不设置，默认密码参考 init-system.sh脚本中的定义<br>-p 后面可以自行设置暴露的 ssh 端口，容器成功启动后，可通过该端口访问容器内部</p><p>启动成功后，就可以进行自由的开发了。如果需要在容器内部编写代码，这里再推荐 vscode + ssh + 本地免密登录配置的开发模式。修改之后，在容器内部代码变更可以立刻生效，也可以在 vscode 中直接通过 命令行 执行操作<br><img src="https://img-blog.csdnimg.cn/20210703234447634.png" alt="ssh remote"></p><p>如果需要启动其他服务，开启更多端口映射，修改 Dockerfile 和 docker run 启动命令即可</p><p><a href="https://smiecj.com/2022/05/31/vscode-tools">扩展: vscode 使用技巧</a></p><h1 id="后言：Docker-在现在开发的重要性"><a href="#后言：Docker-在现在开发的重要性" class="headerlink" title="后言：Docker 在现在开发的重要性"></a>后言：Docker 在现在开发的重要性</h1><p>现在不仅是信息爆炸的时代，更是技术爆炸的时代。底层技术虽然没有太大的变化，但是上层应用技术基本是2-3年一更新。<br>伴随而来的，不仅仅是我们自己知识库的更新，还有日益膨胀的操作系统。是的，有的时候我们需要在电脑上跑后台前端服务，有的时候也要学习其他基础组件，可能还要顺应潮流学一点机器学习。各种技术都需要安装一些依赖。不管是 mac 还是  windows，一旦你换一台电脑，迁移这些环境都是很费成本的。</p><p>因此 现在项目都推崇 协同开发的模式，所有代码、文档 都在云端统一管理。但是对个人来说，这种模式也慢慢变得必要起来。</p><p>所以我推荐 Docker 的原因就这么简单，只是镜像管理和环境管理的方便性，对于程序员来说就足够爱上它了。而且它也远不止这些内容，它的原理，以及 k8s 的实现，也是值得我们去学习的。共勉。</p>]]></content>
    
    
    <summary type="html">帮助大家快速安装 docker desktop 和避坑</summary>
    
    
    
    <category term="开发工具" scheme="http://smiecj.github.io/categories/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"/>
    
    <category term="Docker" scheme="http://smiecj.github.io/categories/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/Docker/"/>
    
    
    <category term="Docker" scheme="http://smiecj.github.io/tags/Docker/"/>
    
  </entry>
  
</feed>
