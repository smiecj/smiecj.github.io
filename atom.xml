<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Smiecj的小窝</title>
  <icon>https://www.gravatar.com/avatar/8b59dee7e59ad63ca309edd9effc2618</icon>
  <subtitle>tech make life better</subtitle>
  <link href="http://smiecj.github.io/atom.xml" rel="self"/>
  
  <link href="http://smiecj.github.io/"/>
  <updated>2022-03-11T16:00:00.000Z</updated>
  <id>http://smiecj.github.io/</id>
  
  <author>
    <name>smiecj</name>
    <email>xxx@gmail.com</email>
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>树莓派通过 SSD 部署 和 配置内网穿透</title>
    <link href="http://smiecj.github.io/2022/03/12/rasp-ssd-frp/"/>
    <id>http://smiecj.github.io/2022/03/12/rasp-ssd-frp/</id>
    <published>2022-03-11T16:00:00.000Z</published>
    <updated>2022-03-11T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>之前一直有在家部署一个可以长期运行的 Linux 服务器的想法，但首先是自己没有一台 Linux 服务器，不是特别想一直开着台式机主机，其次是就算家里开着台式机，外网也访问不到，只能借助类似向日葵的软件远程操作桌面，所以一直没有实践<br>但最近把 树莓派 搞好之后发现其实搞起来也不是那么难，再加上有个大佬买了个云服务器，还一下买了几年，于是硬件条件都有满足了。终于找了个时间，先把树莓派通过 SSD 重新安装系统，再结合 内网穿透，后面可以在外网直接操作树莓派，算是有个可以经常跑，也能经常操作和维护的Linux服务器了</p><h2 id="树莓派和SSD"><a href="#树莓派和SSD" class="headerlink" title="树莓派和SSD"></a>树莓派和SSD</h2><p>一开始树莓派是需要通过 SD 卡初始化的，但是 显然 SD卡 无法承担更高的数据读写要求。于是把自己的一张不常用的 SSD 从台式机拿了出来，接到树莓派上并进行了下系统迁移</p><p><a href="https://www.tomshardware.com/how-to/boot-raspberry-pi-4-usb">How to Boot Raspberry Pi 4 / 400 From a USB SSD or Flash Drive</a></p><h3 id="系统写入SSD"><a href="#系统写入SSD" class="headerlink" title="系统写入SSD"></a>系统写入SSD</h3><p>这里我们通过 imager 将树莓派系统写入 SSD<br><a href="https://www.raspberrypi.com/software/">imager官方下载</a></p><p>选择一个官方镜像，32位和64位都可以<br><img src="/2022/03/12/rasp-ssd-frp/rasp03.png" alt="jupyter lab"></p><p>等待写入<br><img src="/2022/03/12/rasp-ssd-frp/rasp02.png" alt="jupyter lab"></p><h3 id="修改启动选项"><a href="#修改启动选项" class="headerlink" title="修改启动选项"></a>修改启动选项</h3><p>登录树莓派（这里还是用 SD卡 启动），安装 bootloader</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sudo apt update</span><br><span class="line">sudo apt full-upgrade</span><br><span class="line">sudo rpi-update</span><br><span class="line"></span><br><span class="line">sudo rpi-eeprom-update -d -a</span><br></pre></td></tr></table></figure><p>将启动选项修改成用 SSD 卡启动</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo raspi-config</span><br></pre></td></tr></table></figure><p>选择 <strong>6 Advanced Options -&gt; A6 Boot Order -&gt; B2 USB Boot</strong></p><h3 id="重启树莓派"><a href="#重启树莓派" class="headerlink" title="重启树莓派"></a>重启树莓派</h3><p>成功～</p><p><img src="/2022/03/12/rasp-ssd-frp/rasp04.png" alt="部署效果"></p><p>后面再安装了 docker，把一些后台服务部署到了树莓派上。除了受限于树莓派本身 CPU 和内存（4核4G），只能部署一些简单的服务，不过对自己的个人开发需求来说已经够用了</p><h2 id="内网穿透"><a href="#内网穿透" class="headerlink" title="内网穿透"></a>内网穿透</h2><h3 id="原理介绍"><a href="#原理介绍" class="headerlink" title="原理介绍"></a>原理介绍</h3><p>本质上就是在保证安全的前提下，建立从公网到内网的连接通道，使得内网机器能够通过一个可靠的公网地址访问<br>对应现实的例子，类似找香港的代购，代购相当于就是代理，能够按照我们的需求到香港购买一些面免关税的商品（公网发送请求到代理），再帮我们带回来（代理发送请求到内网服务，再将请求结果返回）<br>因此内网穿透的需求从架构上来看，主要包括三个元素：资源提供商、资源使用者 和 代理服务，如下:</p><p>frpc: fast forward proxy client, 内网代理服务<br>frps: fast forward proxy server, 外网代理服务</p><p><img src="/2022/03/12/rasp-ssd-frp/rasp05.png" alt="frp架构"></p><p><a href="https://github.com/fatedier/frp">git-frp</a></p><p>应用场景：</p><ul><li><p>​个人随时操作内网服务器<br>比如接下来要说的部署 frp 代理服务，就是实现这个需求</p></li><li><p>企业开启远程办公<br>国内的互联网公司基本都是通过 代理软件（如: easyConnect）+ 专用隧道 实现在外网对内网资源的访问，本质上就是内网穿透</p></li><li><p>将内网其他服务开启到外网（如个人博客站点）<br>比较大型的个人站点，一般会包含很多数据，需要一定的存储，也需要保证足够的并发访问能力。但是买一个高性能、高存储的云服务器对个人来说肯定成本也不少，这时就可以采用 站点依然部署在内网，只购买一台 主提供流量的 云服务器，通过内网穿透对外开启 HTTP 端口 提供服务的方式。相当于资源提供的压力还是主要在内网机器，外网云服务器只承担流量压力</p></li></ul><h3 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h3><ul><li>内网机器（Linux）</li><li>一台云服务器（Centos）</li></ul><h3 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h3><h4 id="frps（公网）"><a href="#frps（公网）" class="headerlink" title="frps（公网）"></a>frps（公网）</h4><p>下载</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https://github.com/fatedier/frp/releases/download/v0.40.0/frp_0.40.0_linux_amd64.tar.gz</span><br></pre></td></tr></table></figure><p>配置</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[common]</span></span><br><span class="line"><span class="comment"># frps 服务提供的端口</span></span><br><span class="line"><span class="attr">bind_port</span> = <span class="number">7001</span></span><br><span class="line"><span class="comment"># 是否每次网络连接的时候 都进行认证（访问速度 和 安全 方面的选择，并发不大的访问量来说影响不大）</span></span><br><span class="line"><span class="attr">authenticate_new_work_conns</span> = <span class="literal">true</span></span><br><span class="line"><span class="comment"># 是否对 frpc 和 frps 之间的心跳检查请求 都进行认证（默认心跳 30s 一次，所以开启认证影响不大）</span></span><br><span class="line"><span class="attr">authenticate_heartbeats</span> = <span class="literal">true</span></span><br><span class="line"><span class="comment"># 请求认证方式，可选 token/oidc</span></span><br><span class="line"><span class="attr">authentication_method</span> = token</span><br><span class="line"><span class="comment"># 用于请求信息 加密的 key</span></span><br><span class="line"><span class="comment">## 扩展：加密算法 主要用到了 MD5 和 AES，前者用于 Ping 包的校验，后者用于 TCP 请求的校验，具体实现可以参考 frp 作者的 golib 仓库 - git-golib-crypto</span></span><br><span class="line"><span class="attr">token</span> = <span class="number">123</span></span><br></pre></td></tr></table></figure><p>启动</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./frps -c ./frps.ini</span><br></pre></td></tr></table></figure><h4 id="frpc（内网）"><a href="#frpc（内网）" class="headerlink" title="frpc（内网）"></a>frpc（内网）</h4><p>下载</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https://github.com/fatedier/frp/releases/download/v0.40.0/frp_0.40.0_linux_arm64.tar.gz</span><br></pre></td></tr></table></figure><p>配置</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[common]</span></span><br><span class="line"><span class="comment"># 公网 ip 地址</span></span><br><span class="line"><span class="attr">server_addr</span> = x.x.x.x</span><br><span class="line"><span class="comment"># 公网 frps 服务端口，对应 frps.ini 的 bind_ip</span></span><br><span class="line"><span class="attr">server_port</span> = <span class="number">7001</span></span><br><span class="line"><span class="comment"># 校验相关的配置 和 frps 保持一致</span></span><br><span class="line"><span class="attr">authenticate_new_work_conns</span> = <span class="literal">true</span></span><br><span class="line"><span class="attr">authenticate_heartbeats</span> = <span class="literal">true</span></span><br><span class="line"><span class="attr">authentication_method</span> = token</span><br><span class="line"><span class="attr">token</span> = <span class="number">123</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 代理名称（可自行命名）</span></span><br><span class="line"><span class="section">[ssh]</span></span><br><span class="line"><span class="comment"># 代理协议</span></span><br><span class="line"><span class="attr">type</span> = tcp</span><br><span class="line"><span class="comment"># 内网 ssh 端口</span></span><br><span class="line"><span class="attr">local_port</span> = <span class="number">22</span></span><br><span class="line"><span class="comment"># 在公网开放的端口地址</span></span><br><span class="line"><span class="attr">remote_port</span> = <span class="number">6001</span></span><br></pre></td></tr></table></figure><p>启动</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./frpc -c ./frpc.ini</span><br></pre></td></tr></table></figure><h4 id="添加端口访问权限"><a href="#添加端口访问权限" class="headerlink" title="添加端口访问权限"></a>添加端口访问权限</h4><p>阿里云：管理控制台 -&gt; 云服务器 -&gt; ECS安全组 -&gt; 手动添加访问规则<br>分别将 frps 服务的端口 和 内网机器通过 frps 暴露的外网端口 设置访问权限</p><p>![阿里云安全策略配置]](rasp06.png)</p><h4 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h4><p>直接通过ssh云服务器 连接内网服务器:<br>ssh pi@外网服务器ip -p6001</p><p><img src="/2022/03/12/rasp-ssd-frp/rasp07.png" alt="ssh"></p>]]></content>
    
    
    <summary type="html">基于 树莓派的实践</summary>
    
    
    
    <category term="生活" scheme="http://smiecj.github.io/categories/%E7%94%9F%E6%B4%BB/"/>
    
    <category term="技术实践" scheme="http://smiecj.github.io/categories/%E7%94%9F%E6%B4%BB/%E6%8A%80%E6%9C%AF%E5%AE%9E%E8%B7%B5/"/>
    
    
    <category term="Linux" scheme="http://smiecj.github.io/tags/Linux/"/>
    
    <category term="树莓派" scheme="http://smiecj.github.io/tags/%E6%A0%91%E8%8E%93%E6%B4%BE/"/>
    
  </entry>
  
  <entry>
    <title>2月份随便记记</title>
    <link href="http://smiecj.github.io/2022/02/28/life-202202/"/>
    <id>http://smiecj.github.io/2022/02/28/life-202202/</id>
    <published>2022-02-27T16:00:00.000Z</published>
    <updated>2022-02-27T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="充实的2月份"><a href="#充实的2月份" class="headerlink" title="充实的2月份"></a>充实的2月份</h2><p>2月份发生了各种事，从线下蔓延到了线上，一定程度让自己有一些关注新闻欲过高。月初看了看冬奥会盛况，感叹也许只有中国人办的奥运才会能这么美。月中关注国内一些“历史遗留”问题，也算是非常有中国特色了。最后月底就是大国之间的博弈，在哪个社交app几乎都能看到关于这件事的新闻<br>然而回头一看，自己忘记的事情也有很多，不仅仅是思考这些事背后到底代表着什么，还有记录点自己内心的想法。也许是时候，带着轻松点的态度，给自己写点总结了～</p><h2 id="开发相关的东西"><a href="#开发相关的东西" class="headerlink" title="开发相关的东西"></a>开发相关的东西</h2><p>首先就是继续把自己的 DockerFile 仓库更完善了下，虽然过程还是有些痛苦的，Centos7 在 Arm 上不能运行 dbus 服务，Centos8 官方 yum 源又不再支持，另外还有python 在两种架构下表现不太一致的问题。各种适配之后，终于把 开发镜像 做到了 x86 和 arm 架构都能够兼容了。总算是松了口气</p><p>除了开发镜像，还整理了最近了解的大数据相关服务：Jupyter，把它们的安装过程也整理到了 DockerFile 中。这两个组件都是数据开发过程必备的 IDE，或许有了这第一步，终于能够开始好好学习下 机器学习了？</p><p>Jupyter 效果:</p><p><img src="/2022/02/28/life-202202/02.png" alt="jupyter lab"></p><p><img src="/2022/02/28/life-202202/03.png" alt="mysql connector demo"></p><p><a href="https://github.com/smiecj/docker-centos">DockerFile 仓库</a></p><h2 id="新的想法"><a href="#新的想法" class="headerlink" title="新的想法"></a>新的想法</h2><p>除了日常做“正事”，也没忘记偶尔“胡思乱想”</p><h3 id="树莓派"><a href="#树莓派" class="headerlink" title="树莓派"></a>树莓派</h3><p>这个从买来就一直在吃灰的东西，在一次和同事的闲聊中，又有了搞起来的想法<br>也许确实没有很多时间去研究适合它的配件，不过至少在家一直开机，当一个服务器还是可以的吧？对于没有买云主机来说，有一个能长期运行的主机可太关键了，毕竟要台式机一直开着还是有点麻烦<br>但是在此之前，还需要稍微做一些准备工作，默认树莓派刚买到是需要先用 SD 卡刷好操作系统的，但是这显然不适合做需要更高写的服务了，甚至还有很高的把 SD 卡写坏的风险。需要换成 SSD<br>这里先记录一下之前搜的教程，等搞好之后“也许”自己会再发个踩坑记录吧，就是几时能写好就不一定了</p><p><a href="https://zhuanlan.zhihu.com/p/336932291">树莓派4 SSD 启动</a></p><h3 id="新闻过滤算法"><a href="#新闻过滤算法" class="headerlink" title="新闻过滤算法"></a>新闻过滤算法</h3><p>在国内外都在打各种信息战的时候，怎么才能过滤出对自己最有用的新闻呢？<br>毕竟人一天的精力终归有限，怎么样更高效的过滤自己想看的新闻，显然是可以借助一些算法实现的<br>但是现实情况往往很复杂，对每个人，每个时间段的需求可能也不一样，有人就更喜欢那种深入剖析，比较长篇的新闻，但是也可能会有想休息，想吸收点快餐类新闻放松的时候。这就意味着这个算法模型可能会有多种，而且还会因人而异<br>如何才能训练出这种更高效的算法，又是一个需要长时间检验的过程，哎，想了想，技术确实能改变人的生活，但是想和现实完美结合，还是很难啊。不知道猴年马月自己才能先做出一个适合自己的模型。。</p>]]></content>
    
    
    <summary type="html">一点随想</summary>
    
    
    
    <category term="生活" scheme="http://smiecj.github.io/categories/%E7%94%9F%E6%B4%BB/"/>
    
    <category term="记录" scheme="http://smiecj.github.io/categories/%E7%94%9F%E6%B4%BB/%E8%AE%B0%E5%BD%95/"/>
    
    
    <category term="生活" scheme="http://smiecj.github.io/tags/%E7%94%9F%E6%B4%BB/"/>
    
  </entry>
  
  <entry>
    <title>Mac 预装软件整理</title>
    <link href="http://smiecj.github.io/2022/01/10/mac-init-software/"/>
    <id>http://smiecj.github.io/2022/01/10/mac-init-software/</id>
    <published>2022-01-09T16:00:00.000Z</published>
    <updated>2022-01-09T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近发现在 mac 上装的软件是越来越多了，索性就整理一下自己装过的 mac 必备软件，方便后面用新机的时候直接参考教程无缝切换</p><h2 id="参考网站"><a href="#参考网站" class="headerlink" title="参考网站"></a>参考网站</h2><p><a href="https://www.v1tx.com/post/best-mac-apps/">博客-15款好用的Mac软件推荐</a></p><h2 id="效率工具"><a href="#效率工具" class="headerlink" title="效率工具"></a>效率工具</h2><h3 id="brew"><a href="#brew" class="headerlink" title="brew"></a>brew</h3><p>功能: 软件安装工具，一键安装指定软件，无需关注繁琐的安装配置，对于一些工具类软件，比如下面提到的性能测试软件，还是比较实用的<br><a href="https://docs.brew.sh/">官方文档</a></p><p><a href="https://github.com/Homebrew/brew">git-Homebrew/brew</a></p><p>安装方式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/bin/bash -c &quot;$(curl -fsSL https://cdn.jsdelivr.net/gh/ineo6/homebrew-install/install.sh)&quot;</span><br></pre></td></tr></table></figure><p>替换国内源</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># 替换 brew.git</span><br><span class="line">cd &quot;$(brew --repo)&quot;</span><br><span class="line">git remote set-url origin https://mirrors.tuna.tsinghua.edu.cn/git/homebrew/brew.git</span><br><span class="line"></span><br><span class="line"># 替换 homebrew-core.git</span><br><span class="line">cd &quot;$(brew --repo)/Library/Taps/homebrew/homebrew-core&quot;</span><br><span class="line">git remote set-url origin https://mirrors.tuna.tsinghua.edu.cn/git/homebrew/homebrew-core.git</span><br><span class="line"></span><br><span class="line"># 更新配置</span><br><span class="line">brew update</span><br></pre></td></tr></table></figure><p>扩展: 给其他软件自定义安装脚本<br><a href="https://www.jianshu.com/p/df351f34c160">博客-将软件发布到 Homebrew</a><br><a href="https://docs.brew.sh/Formula-Cookbook">博客-Formula Cookbook</a></p><h3 id="alfred"><a href="#alfred" class="headerlink" title="alfred"></a>alfred</h3><p>自带非常多快捷键工具，我用得比较多的就是粘贴板，可以帮我记住最近一段时间复制过的内容。主要功能有：</p><ul><li>Web Search 文件搜索</li><li>Clipboard History 剪贴板历史</li><li>Snippets 文本片段</li><li>System 系统（系统操作快捷键，如清空回收站）</li></ul><p>alfred 本身的快捷键配置<br><img src="/2022/01/10/mac-init-software/alfred01.png" alt="shortcut"></p><p>剪贴板历史配置<br><img src="/2022/01/10/mac-init-software/alfred02.png" alt="clipboard history"><br>（截图只是表示个人使用习惯）</p><p><a href="https://macwk.com/soft/alfred-4">下载地址</a></p><p><a href="https://michael728.github.io/2020/09/23/tools-dev-mac-alfred/">参考-Mac 效率工具必备神器 —— Alfred</a></p><h3 id="bartender"><a href="#bartender" class="headerlink" title="bartender"></a>bartender</h3><p>mac 的状态栏在右上角，但是不像 windows 那样有默认的隐藏功能，不方便管理<br>bartender 就是不错的状态栏管理工具</p><p><a href="https://macwk.com/soft/bartender-4">下载地址</a></p><p><img src="/2022/01/10/mac-init-software/bartender.png" alt="bartender"></p><h2 id="开发常用"><a href="#开发常用" class="headerlink" title="开发常用"></a>开发常用</h2><h3 id="zsh"><a href="#zsh" class="headerlink" title="zsh"></a>zsh</h3><p>zsh 本身不是 shell，它只是在终端基础上套了个壳，相当于穿了件外套，你可以换不同样式的外套，也可以给衣服加口袋</p><p>而其中 oh-my-zsh 又是扩展功能实现相对比较多的版本。虽然 mac 本身使用的是 zsh，但是版本可能比较旧，还是建议更新 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># 安装 zsh</span><br><span class="line">brew install zsh</span><br><span class="line"></span><br><span class="line"># 安装 oh-my-zsh</span><br><span class="line">sh -c &quot;$(curl -fsSL https://raw.githubusercontent.com/robbyrussell/oh-my-zsh/master/tools/install.sh)&quot;</span><br><span class="line"></span><br><span class="line"># 查看当前终端使用的shell</span><br><span class="line">echo $SHELL</span><br><span class="line"></span><br><span class="line"># 如果不是 zsh，修改成 zsh</span><br><span class="line">sudo echo &quot;$(which zsh)&quot; &gt;&gt; /etc/shells</span><br><span class="line">chsh -s $(which zsh)</span><br></pre></td></tr></table></figure><p>配置插件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># vim ~/.zshrc</span><br><span class="line">plugins=(git osx zsh-autosuggestions zsh-syntax-highlighting)</span><br><span class="line"></span><br><span class="line"># 自动提示插件</span><br><span class="line">git clone https://github.com/zsh-users/zsh-autosuggestions $ZSH_CUSTOM/plugins/zsh-autosuggestions</span><br><span class="line"># 语法高亮插件</span><br><span class="line">git clone https://github.com/zsh-users/zsh-syntax-highlighting $ZSH_CUSTOM/plugins/zsh-syntax-highlighting</span><br></pre></td></tr></table></figure><p>配置主题（根据需要配置，也可以设置其他主题）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 下载</span><br><span class="line">git clone --depth=1 https://gitee.com/romkatv/powerlevel10k.git $&#123;ZSH_CUSTOM:-$HOME/.oh-my-zsh/custom&#125;/themes/powerlevel10k</span><br><span class="line"></span><br><span class="line"># 配置: vim ~/.zshrc</span><br><span class="line">ZSH_THEME=&quot;powerlevel10k/powerlevel10k&quot;</span><br></pre></td></tr></table></figure><p><a href="https://a1049145827.github.io/2019/05/15/Mac-%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85%E5%B9%B6%E9%85%8D%E7%BD%AE%E7%BB%88%E7%AB%AF%E7%A5%9E%E5%99%A8-oh-my-zsh/">参考-Mac 环境安装并配置终端神器 oh-my-zsh</a></p><h3 id="iterm"><a href="#iterm" class="headerlink" title="iterm"></a>iterm</h3><p>一款比较好用的终端工具，支持多窗口<br><a href="https://iterm2.com/downloads.html">下载地址</a></p><h4 id="使用技巧-快速登录指定节点"><a href="#使用技巧-快速登录指定节点" class="headerlink" title="使用技巧 - 快速登录指定节点"></a>使用技巧 - 快速登录指定节点</h4><p>iterm 本身没有记录节点列表的功能，如果需要随时连接指定节点（在公司一般都会用到），我们可以通过shell 脚本 + host 配置文件的方式，来实现快速登录指定节点</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"># vim /etc/my_hosts</span><br><span class="line">## 我的配置方式是 节点名 + 环境名 + 实际 ssh 连接的地址 + 端口</span><br><span class="line">docker local root@localhost 22</span><br><span class="line">docker db root@localhost 23</span><br><span class="line">cloud dev root@云主机ip 22</span><br><span class="line">compile dev root@内网编译专用机ip 22</span><br><span class="line"></span><br><span class="line"># vim /usr/local/bin/goto</span><br><span class="line">#!/bin/sh</span><br><span class="line">set -euxo pipefail</span><br><span class="line"></span><br><span class="line">echo &quot;hello go!&quot;</span><br><span class="line"></span><br><span class="line">if [ $# -lt 2 ]; then</span><br><span class="line">        echo &quot;Invalid input!&quot;</span><br><span class="line">        exit</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">node_name=$1</span><br><span class="line">env_name=$2</span><br><span class="line"></span><br><span class="line">login_node_full_info=`cat /etc/my_hosts | grep &quot;$node_name $env_name&quot;`</span><br><span class="line">if [ -z &quot;$login_node_full_info&quot; ]; then</span><br><span class="line">        echo &quot;Node not found!&quot;</span><br><span class="line">        exit</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">IFS=&#x27; &#x27; read -r -a node_split_arr &lt;&lt;&lt; &quot;$login_node_full_info&quot;</span><br><span class="line">#ssh -p$&#123;node_split_arr[3]&#125; $&#123;node_split_arr[2]&#125;</span><br><span class="line">ssh -o &quot;IdentitiesOnly=yes&quot; -i ~/.ssh/自己生成的免密密钥，可将公钥加到想登录的节点上，不需要每次都输密码  -p$&#123;node_split_arr[3]&#125; $&#123;node_split_arr[2]&#125;</span><br></pre></td></tr></table></figure><p>这样直接输入 goto 节点名 环境名 即可登录指定节点</p><h4 id="扩展-支持-lrzsz（文件上传和下载工具）"><a href="#扩展-支持-lrzsz（文件上传和下载工具）" class="headerlink" title="扩展: 支持 lrzsz（文件上传和下载工具）"></a>扩展: 支持 lrzsz（文件上传和下载工具）</h4><p>默认iterm 是不支持rz、sz 的，执行后会卡住，需要设置适配的脚本，比如执行 rz 的时候，打开文件列表</p><p>下载适配脚本</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cd /usr/local/bin</span><br><span class="line">sudo wget https://raw.githubusercontent.com/RobberPhex/iterm2-zmodem/master/iterm2-recv-zmodem.sh</span><br><span class="line">sudo wget https://raw.githubusercontent.com/RobberPhex/iterm2-zmodem/master/iterm2-send-zmodem.sh</span><br><span class="line"></span><br><span class="line">sudo chmod 777 /usr/local/bin/iterm2-*</span><br></pre></td></tr></table></figure><p>修改配置<br><img src="/2022/01/10/mac-init-software/iterm01.png" alt="iterm config"></p><p><img src="/2022/01/10/mac-init-software/iterm02.png" alt="iterm config"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Regular expression      Action  Parameters</span><br><span class="line">\*\*B0100       Run Silent Coprocess    /usr/local/bin/iterm2-send-zmodem.sh</span><br><span class="line">\*\*B00000000000000     Run Silent Coprocess    /usr/local/bin/iterm2-recv-zmodem.sh</span><br></pre></td></tr></table></figure><h3 id="lrzsz"><a href="#lrzsz" class="headerlink" title="lrzsz"></a>lrzsz</h3><p>文件上传、下载工具<br>当然多文件上传/下载 不支持确实比较麻烦，单文件的操作还是比较方便的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install lrzsz</span><br></pre></td></tr></table></figure><h3 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h3><p>Docker 对于开发者的重要性我在前面<a href="https://mp.weixin.qq.com/s/zmkzhIdL7Da_sfNauhAGRQ">公众号文章</a>有提过，主要就是开发环境的模拟和隔离，比如现在需要在 Arm 版本的 Mac 上开发 X86 的程序，就需要模拟一个 X86 的环境，直接通过 Docker 启动一个 X86 的镜像是比较方便的</p><p>建议在官网下载最新版，使用 brew 安装的版本可能会稍微旧一点</p><p><a href="https://www.docker.com/products/docker-desktop">官网下载</a></p><p>mac 电脑建议根据本身芯片架构选择匹配的版本，比如如果在 M1 版本上安装 X86 的 docker desktop，虽然镜像能跑，但是能耗可能会比较高<br>这边我还整理了开发镜像的制作方式，<a href="https://smiecj.github.io/2021/12/18/dockerfile-centos-dev/">参考博客</a>，可一键搭建包含 java、go 等语言的开发镜像</p><h3 id="Conda"><a href="#Conda" class="headerlink" title="Conda"></a>Conda</h3><p>安装 Python 的最佳工具，对不同环境之间可进行较好的隔离</p><p><a href="https://docs.conda.io/en/latest/miniconda.html">下载地址</a></p><p>建议下载脚本，下载完成后通过 sh 执行即可，然后会有一些设置安装路径的操作，建议放在 <strong>/Users/用户名/miniconda</strong> 目录下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sh /Users/username/Downloads/Miniconda3-latest-MacOSX-arm64.sh</span><br></pre></td></tr></table></figure><p>安装完成后在环境变量中配置 conda 路径</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># vim ~/.zshrc</span><br><span class="line">export CONDA_HOME=/Users/username/miniconda</span><br><span class="line">export PATH=$PATH:$CONDA_HOME/bin</span><br></pre></td></tr></table></figure><h2 id="性能测试"><a href="#性能测试" class="headerlink" title="性能测试"></a>性能测试</h2><h3 id="glances"><a href="#glances" class="headerlink" title="glances"></a>glances</h3><p>支持各操作系统的性能指标查看工具，使用 python 编写</p><p><a href="https://nicolargo.github.io/glances/">官网</a><br><a href="https://github.com/nicolargo/glances">git-nicolargo/glances</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install glances</span><br></pre></td></tr></table></figure><p><img src="/2022/01/10/mac-init-software/glances.png" alt="glances"></p><h3 id="Speed-Test"><a href="#Speed-Test" class="headerlink" title="Speed Test"></a>Speed Test</h3><p>磁盘速度测试工具，在 app store 上直接搜索: blackmagic disk speed test 即可</p><p><img src="/2022/01/10/mac-init-software/speedtest.png" alt="speed test"></p>]]></content>
    
    
    <summary type="html">介绍 mac 的一些预装软件，包括开发工具</summary>
    
    
    
    <category term="开发工具" scheme="http://smiecj.github.io/categories/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"/>
    
    <category term="mac" scheme="http://smiecj.github.io/categories/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/mac/"/>
    
    
    <category term="开发工具" scheme="http://smiecj.github.io/tags/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"/>
    
    <category term="mac" scheme="http://smiecj.github.io/tags/mac/"/>
    
  </entry>
  
  <entry>
    <title>通过 DockerFile 搭建开发镜像</title>
    <link href="http://smiecj.github.io/2021/12/19/dockerfile-centos-dev/"/>
    <id>http://smiecj.github.io/2021/12/19/dockerfile-centos-dev/</id>
    <published>2021-12-18T16:00:00.000Z</published>
    <updated>2021-12-18T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>之前搭建过一个开发镜像，包含了 java、go 语言等基本的开发环境，结合 vscode remote 模式，可在本地直接进行开发，免去了安装各种基础环境和配置环境变量的麻烦<br><a href="https://mp.weixin.qq.com/s?__biz=MzU2MDkxMjkwMw==&mid=2247483773&idx=1&sn=a82edd0c3a8063348a7c325fe7f9773d">参考-Docker Desktop 安装方式和开发镜像分享</a></p><p>但是对于使用者来说，依然有两个并不方便的地方：</p><ul><li><p>易用性：对于使用 X86 系统来说，之前的开发镜像确实可以直接用，因为我的镜像就是基于 X86 系统的。但是对于arm 架构系统用户来说，可能就有适配问题了</p></li><li><p>开放性和扩展性：整个镜像的制作过程是封闭的，使用方只能拿到具体的镜像，无法了解到具体的构建过程，也无法对镜像在构建过程进行扩展</p></li><li><ul><li>比如我还想装其他开发语言，依然只能手动装，而且换台电脑之后可能还得这么来操作一次</li></ul></li></ul><p>综上，为了改进我们的开发镜像的这两点，通过 DockerFile 我们再构建一次之前的开发镜像</p><h2 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h2><p><a href="https://github.com/smiecj/docker-centos">项目git地址：docker-centos</a></p><p>先直接来看如何用新的开发镜像：直接下载工程 docker-centos，并通过 centos_dev 这个 Dockerfile 构建镜像</p><p>构建方法：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build --no-cache -f Dockerfiles/centos_dev -t centos_dev_test .</span><br></pre></td></tr></table></figure><p><img src="/2021/12/19/dockerfile-centos-dev/centos-dev_01.png" alt="code"></p><p>等待构建大约10分钟，构建完成后启动容器：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker images</span><br><span class="line"></span><br><span class="line">docker run -d --hostname code --name centos_dev_test --privileged=true -p 2222:22 centos_dev_test /usr/sbin/init</span><br></pre></td></tr></table></figure><p><img src="/2021/12/19/dockerfile-centos-dev/centos-dev_02.png" alt="code"></p><p>容器启动后，通过 Docker Desktop 打开命令行，检查相关依赖是否安装成功：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">source /etc/profile</span><br><span class="line">source ~/.bashrc</span><br><span class="line">java -version</span><br><span class="line">go version</span><br></pre></td></tr></table></figure><p><img src="/2021/12/19/dockerfile-centos-dev/centos-dev_03.png" alt="code"></p><h2 id="开发过程"><a href="#开发过程" class="headerlink" title="开发过程"></a>开发过程</h2><h3 id="DockerFile"><a href="#DockerFile" class="headerlink" title="DockerFile"></a>DockerFile</h3><p>目录：Dockerfiles/centos_dev</p><p>这里不需要做太多操作，只需要从 git 下载包含初始化系统脚本的仓库即可</p><p><img src="/2021/12/19/dockerfile-centos-dev/centos-dev_04.png" alt="code"></p><h3 id="初始化脚本"><a href="#初始化脚本" class="headerlink" title="初始化脚本"></a>初始化脚本</h3><p>目录：scripts/init-dev-system.sh</p><p>即初始化整个操作系统的脚本，大概就是下载 + 安装 + 配置环境变量的过程。笔者这里根据自己的开发需要，搭建了 java、go、python 和 nodejs 开发环境，具体版本如下：</p><ul><li>Java: OpenJDK 1.8</li><li>Go: 1.17</li><li>Python: Python3（MiniConda）</li><li>Nodejs: 14.17.0</li></ul><p>其他细节说明</p><ul><li>语言的可执行安装包统一放在 /usr/语言名 目录下，如: /usr/java</li><li>语言的下载依赖路径统一放在 /home/repo/语言名下，如: /usr/golang</li><li>Java 安装11 和 8 版本：8 用于编译，11 用于 vscode 的 java 插件顺利启动</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>用好工具就是提升开发效率的第一步～</p>]]></content>
    
    
    <summary type="html">一键搭建开发镜像，从此告别繁琐的各种开发环境的安装过程</summary>
    
    
    
    <category term="开发工具" scheme="http://smiecj.github.io/categories/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"/>
    
    <category term="docker" scheme="http://smiecj.github.io/categories/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/docker/"/>
    
    
    <category term="docker" scheme="http://smiecj.github.io/tags/docker/"/>
    
    <category term="开发工具" scheme="http://smiecj.github.io/tags/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>通过 Ambari 启动 Nebula Gateway 一段时间后会自动退出的问题解决</title>
    <link href="http://smiecj.github.io/2021/11/20/nebula-gateway-sigpipe/"/>
    <id>http://smiecj.github.io/2021/11/20/nebula-gateway-sigpipe/</id>
    <published>2021-11-19T16:00:00.000Z</published>
    <updated>2021-11-19T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="http://senlinzhan.github.io/2017/03/02/sigpipe/">网络编程中的 SIGPIPE 信号</a></p><p><a href="https://coderatwork.cn/posts/sigpipe-tragedy/">SIGPIPE 引发的悲剧</a></p><p><a href="https://www.cnblogs.com/lit10050528/p/5116566.html">SIGPIPE信号详解</a></p><h2 id="问题概述"><a href="#问题概述" class="headerlink" title="问题概述"></a>问题概述</h2><p>在 Ambari 中集成了 nebula studio 1.0 版本，启动的组件包括：</p><ul><li>Studio: 通过 node 启动的 前端服务</li><li>Importer: 数据导入工具，可以将本地的CSV 文件导入到 graph</li><li>Gateway: 连接 studio 和 graph 服务的网关服务</li></ul><p>然后gateway组件的启动脚本是这样的：<br><strong>nohup ./nebula-http-gateway &gt;&gt; /var/log/nebula/gateway.log &amp;</strong></p><p>启动过程集成到了 ambari 中，然后通过界面启动gateway 服务，一开始服务正常启动没问题，但是在 studio 上进行一些图搜索操作之后，就会自动退出，而且服务日志中没有任何报错信息</p><p>但是直接在命令行执行的时候，就不会有任何问题，一开始百思不得其解</p><h2 id="相关基础知识"><a href="#相关基础知识" class="headerlink" title="相关基础知识"></a>相关基础知识</h2><h3 id="操作系统-stdout、stderr"><a href="#操作系统-stdout、stderr" class="headerlink" title="操作系统: stdout、stderr"></a>操作系统: stdout、stderr</h3><p>标准输出和错误输出</p><p>在命令行通过 nohup 打印，默认输出位置:<br>stdout: nohup.out<br>stderr: 直接忽略</p><h3 id="nebula-gateway-查询图数据逻辑"><a href="#nebula-gateway-查询图数据逻辑" class="headerlink" title="nebula gateway: 查询图数据逻辑"></a>nebula gateway: 查询图数据逻辑</h3><p>这里我们看 执行 nebula查询语句的关键方法: Execute<br>（gateway 版本：1.0）</p><blockquote><p>service/dao/dao.go</p></blockquote><p><img src="/2021/11/20/nebula-gateway-sigpipe/nebula01.png" alt="code"></p><p><img src="/2021/11/20/nebula-gateway-sigpipe/nebula02.png" alt="code"></p><p>Request 发给了一个 channel，然后 等待 response channel 接收到回复，最后处理 response ，返回成功 或者是打印 错误信息</p><h3 id="golang-打印日志的目标"><a href="#golang-打印日志的目标" class="headerlink" title="golang 打印日志的目标"></a>golang 打印日志的目标</h3><h4 id="println-stderr"><a href="#println-stderr" class="headerlink" title="println: stderr"></a>println: stderr</h4><p><img src="/2021/11/20/nebula-gateway-sigpipe/nebula03.png" alt="code"></p><h4 id="fmt-Println-stdout"><a href="#fmt-Println-stdout" class="headerlink" title="fmt.Println: stdout"></a>fmt.Println: stdout</h4><p><img src="/2021/11/20/nebula-gateway-sigpipe/nebula04.png" alt="code"></p><h4 id="log-Printf-log-Println-stderr"><a href="#log-Printf-log-Println-stderr" class="headerlink" title="log.Printf / log.Println: stderr"></a>log.Printf / log.Println: stderr</h4><p><img src="/2021/11/20/nebula-gateway-sigpipe/nebula05.png" alt="code"></p><blockquote><p>func (l *Logger) Output(calldepth int, s string) error {</p></blockquote><p><img src="/2021/11/20/nebula-gateway-sigpipe/nebula06.png" alt="code"></p><p><img src="/2021/11/20/nebula-gateway-sigpipe/nebula07.png" alt="code"></p><h3 id="SIGPIPE"><a href="#SIGPIPE" class="headerlink" title="SIGPIPE"></a>SIGPIPE</h3><p><a href="https://man7.org/linux/man-pages/man7/signal.7.html">linux-signal</a></p><p>SIGPIPE 和 强制终止 kill -9 类似，都是一种发送程序终止的信号。它表示向一个已经终止的socket 通道中写数据</p><p>这种情况也是比较常见的，因为可能因为网络的不稳定，服务端向客户端成功发送 FIN 之后，一直没有收到客户端回复的RSP，客户端如果又自行退出，就会导致服务端再次向客户端发送请求时，收到一个 SIGPIPE 信号<br>对于C 程序，默认情况下是不会忽略这个信号的，收到这个信号就会直接退出。可通过执行 <strong>signal(SIGPIPE, SIG_IGN);</strong> 方法忽略之</p><h2 id="定位过程"><a href="#定位过程" class="headerlink" title="定位过程"></a>定位过程</h2><h3 id="打印进程详细日志"><a href="#打印进程详细日志" class="headerlink" title="打印进程详细日志"></a>打印进程详细日志</h3><p>strace：可打印进程的内核操作详细信息的工具<br>strace -p pid: 打印指定进程的详细信息</p><p><img src="/2021/11/20/nebula-gateway-sigpipe/nebula08.png" alt="strace"></p><p>这里很明显进程退出的原因 就是接收到了 SIGPIPE 信号</p><h3 id="原因分析"><a href="#原因分析" class="headerlink" title="原因分析"></a>原因分析</h3><p>结合前面的基本知识，可大致判断就是 <strong>Ambari 通过一个sub process 执行 gateway 的启动脚本，在执行完成之后，子进程退出了，但是 gateway 依然往子进程的标准输出中打印日志（写日志也是socket操作），就会导致 gateway 接收到 SIGPIPE 信号，并最后退出</strong></p><p>为了最终确定，我们再看一下 ambari 的Execute 方法实现，可看到它会把错误输出定位到标准输出，标准输出默认是和 进程 强绑定的，进程退出了，就无法再打印日志了</p><blockquote><p>ambari-common/src/main/python/resource_management/core/resources/system.py</p></blockquote><p>class Execute(Resource):</p><p>而 gateway 通过 log.Printf 打印 response 的错误信息，会将日志打印到stderr，印证了这个退出的原因</p><h2 id="问题解决"><a href="#问题解决" class="headerlink" title="问题解决"></a>问题解决</h2><p>修改gateway 启动脚本，将 stdout 和 stderr 都重定向到日志文件即可</p><p>nohup ./nebula-http-gateway <strong>&gt; /var/log/nebula/gateway.log 2&gt;&amp;1</strong> &amp;</p><p>再次操作 nebula studio，看到 gateway 打印的日志能正常在 nohup.out 中打印了</p><p><img src="/2021/11/20/nebula-gateway-sigpipe/nebula10.png" alt="log"></p><h2 id="小总结"><a href="#小总结" class="headerlink" title="小总结"></a>小总结</h2><p>虽然最后解决 也就是一行代码的事情，但是发现这个问题根因的过程还是挺有意思的</p>]]></content>
    
    
    <summary type="html">一个开发过程遇到的小bug的解决</summary>
    
    
    
    <category term="大数据" scheme="http://smiecj.github.io/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
    <category term="问题解决" scheme="http://smiecj.github.io/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/"/>
    
    
    <category term="nebula" scheme="http://smiecj.github.io/tags/nebula/"/>
    
    <category term="大数据" scheme="http://smiecj.github.io/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
  </entry>
  
  <entry>
    <title>Hexo 博客搭建教程</title>
    <link href="http://smiecj.github.io/2021/08/13/hexo-blog/"/>
    <id>http://smiecj.github.io/2021/08/13/hexo-blog/</id>
    <published>2021-08-12T16:00:00.000Z</published>
    <updated>2021-08-12T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h2><p><a href="https://smiecj.github.io/">博客首页</a><br><img src="/2021/08/13/hexo-blog/hexo_blog_01.png" alt="blog front page"></p><p><img src="/2021/08/13/hexo-blog/hexo_blog_12.png" alt="blog front page"></p><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>之前自己的博客都是放在csdn上，分类管理起来不是很方便，而且分类在左下角，不是特别显眼的地方<br><img src="/2021/08/13/hexo-blog/hexo_blog_03.png" alt="csdn page"></p><p>公众号的标签功能还可以，不过自己还是希望有个个人站点能专门管理写过的博客，主题最好是能一目了然，不仅仅是别人看着方便，以后自己整理资料的时候找得也方便</p><p>既然有这个需求，那就试试呗，看看个人站点怎么搭建，据说不难的</p><h2 id="踩坑记-hugo工具短暂的体验"><a href="#踩坑记-hugo工具短暂的体验" class="headerlink" title="踩坑记 - hugo工具短暂的体验"></a>踩坑记 - hugo工具短暂的体验</h2><p>hugo 是一个用golang 写的博客搭建工具，主要功能是可一键生成博客，我们自己只需要写markdown 格式的文章就行了，前端静态文件都是通过hugo 进行渲染生成的。方便是方便，但是一直没有找到特别满意的主题。<br>其实自己对主题的要求也没有说特别高，主要是要简洁、重点明了就好了，那种特别花哨、或者是基本功能欠缺的主题都是不考虑的<br>所以最后放弃了hugo。一次偶然的机会，和一个前端同学聊，知道了有hexo 这样一个工具，同样是生成博客的，那就试试呗</p><p><a href="https://jeshs.github.io/2019/01/hugo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E4%B8%80%E6%90%AD%E5%BB%BAhugo%E5%8D%9A%E5%AE%A2/">参考-hugo搭建教程</a></p><blockquote><p>hugo基本指令:</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">创建一篇博客:</span><br><span class="line">hugo new site myblog</span><br><span class="line">启动服务:</span><br><span class="line">hugo server -D --bind=&quot;0.0.0.0&quot;</span><br></pre></td></tr></table></figure><h2 id="hexo-主题介绍"><a href="#hexo-主题介绍" class="headerlink" title="hexo 主题介绍"></a>hexo 主题介绍</h2><p>hexo 和 hugo 最大的优势我觉得就是主题库了，这里介绍几个个人感觉还不错的：</p><table><thead><tr><th>主题</th><th>风格</th><th>demo</th></tr></thead><tbody><tr><td><a href="https://github.com/yscoder/hexo-theme-indigo">Indigo</a></td><td>蓝色主题、简洁</td><td><a href="https://wuyang910217.github.io/">wuyang的个人博客</a></td></tr><tr><td><a href="https://github.com/jerryc127/hexo-theme-butterfly">butterfly</a></td><td>首页展示大幅背景图，表现力强</td><td><a href="https://yunist.cn/">云玩家</a></td></tr><tr><td><a href="https://github.com/Molunerfinn/hexo-theme-melody">melody</a></td><td>白色主题、简洁</td><td><a href="https://molunerfinn.com/">MARKSZのBlog</a></td></tr></tbody></table><p>其实自己也是后面看了这些主题的样式，才发现原来好多大神的个人站点都是通过 hexo 搭建的，有些前端技术比较厉害的，还会尝试自己去魔改，希望自己也有一天可以尝试一下</p><h2 id="本地搭建方式"><a href="#本地搭建方式" class="headerlink" title="本地搭建方式"></a>本地搭建方式</h2><h3 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h3><p><a href="https://github.com/hexojs/hexo">hexo</a> 是 node 开发的框架，所以需要通过 npm 来安装</p><blockquote><p>安装hexo 框架</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g hexo-cli</span><br></pre></td></tr></table></figure><blockquote><p>创建博客工程</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo init myblog</span><br></pre></td></tr></table></figure><blockquote><p>工程结构简述</p></blockquote><p><img src="/2021/08/13/hexo-blog/hexo_blog_04.png" alt="hexo structure"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">_config.yml: 主配置文件，后续修改主题之类的就是改这里</span><br><span class="line">themes: 主题目录</span><br><span class="line">scaffolds: 博客模板，通过 hexo new page 生成的页面都以这里的md 文件为模板</span><br><span class="line">source: 存放用户资源</span><br><span class="line">package.json: 本质上 hexo 博客还是一个前端项目，所以在这里管理依赖</span><br></pre></td></tr></table></figure><h3 id="设置主题"><a href="#设置主题" class="headerlink" title="设置主题"></a>设置主题</h3><p>这一步主要是在 <strong>themes</strong> 目录下，存放主题代码目录，这样 hexo 启动博客主页的时候，就是以你放的主题来生成了<br>有两种下载主题的方式：你可以直接将主题git 代码下载下来，放到themes 目录，或者是fork 一份主题仓库，通过 git submodule clone 一份代码。如果有兴趣自己做主题魔改，更建议后者</p><p>通过 git submodule 下载：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git submodule add git@github.com:主题仓库.git themes/主题名称</span><br></pre></td></tr></table></figure><p>下载完成之后，将_config.yml 中的主题名称修改一下<br><img src="/2021/08/13/hexo-blog/hexo_blog_05.png" alt="hexo structure"></p><p>安装渲染工具</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-renderer-pug hexo-renderer-stylus --save</span><br><span class="line">npm install --save hexo-renderer-pug hexo-renderer-jade hexo-generator-feed hexo-generator-sitemap hexo-browsersync hexo-generator-archive hexo-renderer-stylus</span><br></pre></td></tr></table></figure><h3 id="启动博客"><a href="#启动博客" class="headerlink" title="启动博客"></a>启动博客</h3><blockquote><p>清理静态文件</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo clean</span><br></pre></td></tr></table></figure><blockquote><p>生成静态文件</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo g</span><br></pre></td></tr></table></figure><blockquote><p>启动服务</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">hexo server -w -p 3000</span><br><span class="line"></span><br><span class="line"># 启动服务</span><br><span class="line"># -w: watch，监听文件变化</span><br><span class="line"># -p: port，启动端口</span><br></pre></td></tr></table></figure><p>到这一步完成，博客基本框架就算搭建成功了~</p><h2 id="基本配置的介绍"><a href="#基本配置的介绍" class="headerlink" title="基本配置的介绍"></a>基本配置的介绍</h2><p>这里我们对一些博客配置做简单的了解，方便后续进行主题设置。当然博客部署完成之后，也可以直接部署到github 上，先不管这些配置。你也可以直接跳到下一节内容进行参考。<br>如果想了解大部分的配置，建议参考下面的官方教程<br><a href="https://butterfly.js.org/posts/4aa8abbe">参考-官方教程</a></p><h3 id="网站信息"><a href="#网站信息" class="headerlink" title="网站信息"></a>网站信息</h3><p>站点基本配置</p><p><img src="/2021/08/13/hexo-blog/hexo_blog_06.png" alt="blog config"></p><p>头像和首页背景图</p><p><img src="/2021/08/13/hexo-blog/hexo_blog_07.png" alt="head config"></p><h3 id="文章"><a href="#文章" class="headerlink" title="文章"></a>文章</h3><p>文章封面: 设置cover属性<br><img src="/2021/08/13/hexo-blog/hexo_blog_08.png" alt="blog top img config"></p><p>效果:<br><img src="/2021/08/13/hexo-blog/hexo_blog_09.png" alt="blog top img show"></p><h3 id="顶部栏"><a href="#顶部栏" class="headerlink" title="顶部栏"></a>顶部栏</h3><p><img src="/2021/08/13/hexo-blog/hexo_blog_10.png" alt="blog top config"></p><p>其中，标签、分类页面可通过下面的指令新建:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo new page tags</span><br><span class="line">hexo new page categories</span><br></pre></td></tr></table></figure><h2 id="部署到github站点"><a href="#部署到github站点" class="headerlink" title="部署到github站点"></a>部署到github站点</h2><h3 id="github-创建仓库"><a href="#github-创建仓库" class="headerlink" title="github 创建仓库"></a>github 创建仓库</h3><p>github 能够识别 用户名.github.io 的仓库名，并部署这个仓库的静态文件生成站点，站点地址就是 用户名.github.io<br><img src="/2021/08/13/hexo-blog/hexo_blog_11.png" alt="blog deploy config"></p><h3 id="配置准备"><a href="#配置准备" class="headerlink" title="配置准备"></a>配置准备</h3><p>修改博客根目录的 config.yml 文件:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repo: &lt;repository url&gt; #https://bitbucket.org/JohnSmith/johnsmith.bitbucket.io</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure><p>这样先执行 <strong>hexo g</strong> 生成静态文件之后，再执行 <strong>hexo d</strong> 就可以将静态文件 提交到站点仓库上了<br>如果是在本地开发，建议 repo 配置成 ssh 的地址，部署更方便</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>天下无难事 – 其实很早就看到过，这次尝试自己搭建，其实不麻烦<br>当然，要真正做成一个内容丰富的个人博客站点，还是要慢慢积累丰富的内容才行。有的大神就纯做技术博客（比如<a href="https://www.liaoxuefeng.com/">廖雪峰</a>），有的大神则搞一些炫酷的效果（如<a href="https://www.yunyoujun.cn/about/">云游君的小站</a>），最后都能做得很有知名度。当然，最重要的还是要有核心的技术，博客积累关键还是在于个人的技术积累。<br>所以，慢慢来吧，共勉</p>]]></content>
    
    
    <summary type="html">从0开始搭建个人博客</summary>
    
    
    
    <category term="开发工具" scheme="http://smiecj.github.io/categories/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"/>
    
    <category term="hexo" scheme="http://smiecj.github.io/categories/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/hexo/"/>
    
    
    <category term="个人博客" scheme="http://smiecj.github.io/tags/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"/>
    
    <category term="hexo" scheme="http://smiecj.github.io/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>Golang 常见的10种错误</title>
    <link href="http://smiecj.github.io/2021/07/18/golang-mistakes/"/>
    <id>http://smiecj.github.io/2021/07/18/golang-mistakes/</id>
    <published>2021-07-17T16:00:00.000Z</published>
    <updated>2021-07-17T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://itnext.io/the-top-10-most-common-mistakes-ive-seen-in-go-projects-4b79d4f6cd65#e9ba">原文链接</a></p><p>前言：这里提到的错误，并不是那种“致命错误”，而是业务中的使用习惯的问题。如果不够了解语言的设计方式，导致使用习惯不当，可能就会引入一些设计不够好的代码。因此学习这些前人对使用方式的总结是很有帮助的。<br>话不多说，一起来看看都有哪些常见易犯的错误：</p><h3 id="一、枚举默认值和json反序列化"><a href="#一、枚举默认值和json反序列化" class="headerlink" title="一、枚举默认值和json反序列化"></a>一、枚举默认值和json反序列化</h3><p>先来看一段枚举的定义：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">type Status uint32</span><br><span class="line"></span><br><span class="line">const (</span><br><span class="line">  StatusOpen Status = iota</span><br><span class="line">  StatusClosed</span><br><span class="line">  StatusUnknown</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>然后业务结构体 Request 引用了这个枚举</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">type Request struct &#123;</span><br><span class="line">  ID        int    `json:&quot;Id&quot;`</span><br><span class="line">  Timestamp int    `json:&quot;Timestamp&quot;`</span><br><span class="line">  Status    Status `json:&quot;Status&quot;`</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后就是常见的接口之后的反序列化过程了，如果是正常的接口返回，如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;Id&quot;: 1234,</span><br><span class="line">  &quot;Timestamp&quot;: 1563362390,</span><br><span class="line">  &quot;Status&quot;: 0</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么反序列化之后应该也是很正常的，调用方拿到了下游返回的状态信息，状态也都对得上。<br>但是如果下游有问题，没有返回这个状态：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;Id&quot;: 1235,</span><br><span class="line">  &quot;Timestamp&quot;: 1563362390</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个时候后台拿到的状态是什么？又应该是什么？可以直接写段代码测试一下。</p><p>最终：一个更健壮的枚举定义：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">type Status uint32</span><br><span class="line"></span><br><span class="line">const (</span><br><span class="line">  StatusUnknown Status = iota</span><br><span class="line">  StatusOpen</span><br><span class="line">  StatusClosed</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>别看是一个小问题，影响可不小，如果结构体设计阶段没有考虑到这个问题，需要发版之后再修复，可能要改的还有下游的结构体定义，而如果结构体是放在公共的pb 文件中，要改pb ，那么要影响到的服务可能就更多了。<br>所以元数据的定义永远是基础，牵一发而动全身。设计的时候还是要更考虑周全一些。需要从 业务逻辑转换成编程思维，考虑到更多的细节。<br><a href="https://github.com/smiecj/go_common_mistake/blob/master/error_test.go">参考测试代码-enum_test.go</a></p><h3 id="二、BenchMarking和内联"><a href="#二、BenchMarking和内联" class="headerlink" title="二、BenchMarking和内联"></a>二、BenchMarking和内联</h3><p><a href="https://segmentfault.com/a/1190000039146279">参考博客-详解Go内联优化</a></p><p>性能测试相关的代码，往往需要重复执行，如果写法不当，就很容易导致内联的问题：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">func clear(n uint64, i, j uint8) uint64 &#123;</span><br><span class="line">return (math.MaxUint64&lt;&lt;j | ((1 &lt;&lt; i) - 1)) &amp; n</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func BenchmarkCleanBit(b *testing.B) &#123;</span><br><span class="line">for i := 0; i &lt; b.N; i++ &#123;</span><br><span class="line">clear(1221892080809121, 10, 63)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里先说明一下 testing.B 这个类的功能：它表示基准测试，在测试结束之后将会输出一段性能测试的结果<br>测试方法必须是 BenchMark 开头，另外执行测试需要带上 bench 参数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go test -bench=. benchmark_test.go</span><br></pre></td></tr></table></figure><p>测试结果：</p><p>goos: windows<br>goarch: amd64<br>pkg: github.com/smiecj/go_common_mistake<br>BenchmarkCleanBit<br>BenchmarkCleanBit-8     1000000000           <strong>0.339 ns/op</strong><br>PASS</p><p>但是接下来要说到问题了：由于 clear 方法没有执行其他方法的调用，没有边际效应，所以会被内联，再加上其返回值也没有被外层接收，所以又会被进一步优化掉，直接不会执行。所以其实测试结果是不准的。<br>怎么确认 clear 方法被内联了呢？可以通过编译参数确认：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go test -gcflags=&quot;-m&quot; -bench=. benchmark_test.go</span><br></pre></td></tr></table></figure><blockquote><p>-gcflags=”-m”: 打印编译过程中 golang 解析产生内联的详细过程</p></blockquote><p>所以验证的方式也很简单，只要避免内联就可以了。结合这个性能测试的示例，大概有两种方式：<br>① 在 BenchMark 中设置一个局部变量去接收返回值</p><p>② clear 方法最上面设置取消内联</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//go:noinline</span><br><span class="line">func clear(n uint64, i, j uint8) uint64 &#123;</span><br><span class="line">  return (math.MaxUint64&lt;&lt;j | ((1 &lt;&lt; i) - 1)) &amp; n</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>新的测试结果：<br>goos: windows<br>goarch: amd64<br>pkg: github.com/smiecj/go_common_mistake<br>BenchmarkCleanBit<br>BenchmarkCleanBit-8     426727659          <strong>2.96 ns/op</strong><br>PASS</p><p>③ 设置编译参数 -l 禁止内联</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go test -gcflags=&quot;-N -l -m&quot; -bench=. benchmark_test.go</span><br></pre></td></tr></table></figure><blockquote><p>-N：禁止编译优化<br>-l：禁止内联</p></blockquote><p>测试结果：<br>goos: windows<br>goarch: amd64<br>BenchmarkCleanBit-8     376172835                <strong>3.13 ns/op</strong><br>PASS<br>ok      command-line-arguments  2.361s</p><p>扩展阅读：<br><a href="https://dave.cheney.net/high-performance-go-workshop/dotgo-paris.html">High Performance Go Workshop</a></p><h3 id="三、每次传参都应该用指针吗？"><a href="#三、每次传参都应该用指针吗？" class="headerlink" title="三、每次传参都应该用指针吗？"></a>三、每次传参都应该用指针吗？</h3><p>首先，就传递数据量来说，指针毫无疑问，在大多数时候还是更省空间的。（64位系统中是8个字节）</p><p>看起来似乎指针总比传值更好，对吧？其实不是的，我们可能只关注了参数本身的空间开销，却忽略了指针和值分别在栈和堆上的存储开销。<br>先从方法的返回值去理解返回参数和返回指针的区别，来看个例子: </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">func getFooValue() foo &#123;</span><br><span class="line">  var result foo</span><br><span class="line">  // Do something</span><br><span class="line">  return result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法内部新建了result对象，这个对象只可能被方法内部访问，所以这个对象分配的空间就在栈上，不会在堆上。<br>然后，方法直接返回了值本身，这个动作会生成一份result的拷贝，存储在调用方的栈上，原result因为不会再被访问，将等待被GC回收。</p><p>再来看返回指针的情况:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">func main()  &#123;</span><br><span class="line">  p := &amp;foo&#123;&#125;</span><br><span class="line">  f(p)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Go只有传值，所以对于指针p来说，它的空间申请和传递，都是和上一个例子一样的。但是对于foo对象本身，申请的时候必然不会在栈上申请，而会在堆上申请。这样才能让作用域扩大到调用方。</p><p>栈比堆更快的两个原因:</p><ul><li>栈上对象不需要GC，从上面的例子可以看到，除非返回指针，否则栈内的一切对象都跟调用方没有任何关系，都是拷贝后返回，因此可以在方法结束后直接被标记。</li><li>栈上对象只会在当前routine被使用，不需要和其他协程同步，也就不会在堆上记录任何状态信息</li></ul><p>总结来说，就是不管是传参还是返回，只要非共享的场景（当然，复合数据结构如map一般都是需要共享的），都建议传value，只有一定要传指针的时候才去传指针。</p><p>扩展阅读<br><a href="https://www.ardanlabs.com/blog/2017/05/language-mechanics-on-stacks-and-pointers.html">Language Mechanics On Stacks And Pointers</a></p><h3 id="四、break和条件控制语句"><a href="#四、break和条件控制语句" class="headerlink" title="四、break和条件控制语句"></a>四、break和条件控制语句</h3><p>如下面这段代码，break 真的能够跳出循环吗？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">for &#123;</span><br><span class="line">  switch f() &#123;</span><br><span class="line">  case true:</span><br><span class="line">    break</span><br><span class="line">  case false:</span><br><span class="line">    // Do something</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>答案：break 其实是跳出 switch 的循环。但是golang 的switch 执行完成一个分支之后其他分支也不会执行的，所以 switch 的 break 其实没有什么意义</p><p>但是select 的break 就有意义了。所以下面这种情况也是要特别注意的，break 跳出的也不是循环<br>for {<br>  select {<br>  case &lt;-ch:<br>  // Do something<br>  case &lt;-ctx.Done():<br>    break<br>  }<br>}</p><p>常见的退出循环+switch的方式：break + 代码块名称</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">OuterLoop:</span><br><span class="line">  for i = 0; i &lt; n; i++ &#123;</span><br><span class="line">    for j = 0; j &lt; m; j++ &#123;</span><br><span class="line">      switch a[i][j] &#123;</span><br><span class="line">      case nil:</span><br><span class="line">        state = Error</span><br><span class="line">        break OuterLoop</span><br><span class="line">      case item:</span><br><span class="line">        state = Found</span><br><span class="line">        break OuterLoop</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3 id="五、错误管理"><a href="#五、错误管理" class="headerlink" title="五、错误管理"></a>五、错误管理</h3><p>error的处理一般满足两个原则：处理了就不要再向上继续抛出，必须给上层返回不一样的信息；没处理就一定要继续向上抛出</p><p>而go1.13之前提供的error 管理方法其实很少，所以这里我们使用 pkg/errors 这个工具来帮我们更好地管理自定义错误：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">import &quot;github.com/pkg/errors&quot;</span><br><span class="line">......</span><br><span class="line">func postHandler(customer Customer) Status &#123;</span><br><span class="line">  err := insert(customer.Contract)</span><br><span class="line">  if err != nil &#123;</span><br><span class="line">    switch errors.Cause(err).(type) &#123;</span><br><span class="line">    default:</span><br><span class="line">      log.WithError(err).Errorf(&quot;unable to serve HTTP POST request for customer %s&quot;, customer.ID)</span><br><span class="line">      return Status&#123;ok: false&#125;</span><br><span class="line">    case *db.DBError:</span><br><span class="line">      return retry(customer)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">  return Status&#123;ok: true&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func insert(contract Contract) error &#123;</span><br><span class="line">  err := db.dbQuery(contract)</span><br><span class="line">  if err != nil &#123;</span><br><span class="line">    return errors.Wrapf(err, &quot;unable to insert customer contract %s&quot;, contract.ID)</span><br><span class="line">  &#125;</span><br><span class="line">  return nil</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意到判断错误类型使用对象的type判断就可以了，<strong>Cause</strong>和<strong>Wrapf</strong>需要配套使用</p><h3 id="六、数组初始化"><a href="#六、数组初始化" class="headerlink" title="六、数组初始化"></a>六、数组初始化</h3><h4 id="6-1-len-和-cap"><a href="#6-1-len-和-cap" class="headerlink" title="6.1 len 和 cap"></a>6.1 len 和 cap</h4><p>我们知道数组有两个初始化参数，分别表示len和cap，分别表示长度和初始化长度。<br>比如初始化一个空数组：<br>var bars []Bar<br>bars := make([]Bar, 0, 0)</p><p>和Java不同的是，go把 cap 设置也半交给用户了（当不配置cap 的时候，len 就是 cap）。但是这也<br>比如当我们把 cap 设置成负数，或者小于 len 的时候，会发生什么呢？<br>直接测试一下：<br><img src="https://img-blog.csdnimg.cn/20210718103648191.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3hpYW9saWl6aQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>可以看到编译期 就已经直接报错了，不会让你能够执行这样的代码。我们可以从types/expr.go 中找到具体报错信息打印的地方。</p><h4 id="6-2-设置len-还是-cap-的效率高"><a href="#6-2-设置len-还是-cap-的效率高" class="headerlink" title="6.2 设置len 还是 cap 的效率高"></a>6.2 设置len 还是 cap 的效率高</h4><p>来看一种比较常见的场景：需要把数据库的对象转换成对外接口传递的对象。对象数量是确定的，需要怎么做呢？<br>有两种实现方式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">func convert(foos []Foo) []Bar &#123;</span><br><span class="line">  bars := make([]Bar, len(foos))</span><br><span class="line">  for i, foo := range foos &#123;</span><br><span class="line">    bars[i] = fooToBar(foo)</span><br><span class="line">  &#125;</span><br><span class="line">  return bars</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">func convert(foos []Foo) []Bar &#123;</span><br><span class="line">  bars := make([]Bar, 0, len(foos))</span><br><span class="line">  for _, foo := range foos &#123;</span><br><span class="line">    bars = append(bars, fooToBar(foo))</span><br><span class="line">  &#125;</span><br><span class="line">  return bars</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实两种实现方式都可以，但是前者效率显然高一些，因为空间是已经分配好的，而后者虽然cap 设定了，但是随着 不断append 元素，底层也是要不断地进行数组的拷贝的。</p><blockquote><p>译者：文章这里基本没有从源码说明效率高的原因，后续考虑新开一篇，从makeslice 方法去分析两种方式真正的差异</p></blockquote><h3 id="七、context-管理"><a href="#七、context-管理" class="headerlink" title="七、context 管理"></a>七、context 管理</h3><h4 id="7-1-什么是context"><a href="#7-1-什么是context" class="headerlink" title="7.1 什么是context"></a>7.1 什么是context</h4><p>官方概念：<br>A Context carries a deadline, a cancelation signal, and other values across API boundaries.</p><p>这里说明了context可以带的三类信息：deadline（超时配置）、cancelation（终止动作）和values（键值对）</p><h4 id="7-2-什么时候应该用context"><a href="#7-2-什么时候应该用context" class="headerlink" title="7.2 什么时候应该用context"></a>7.2 什么时候应该用context</h4><p>前两个信息是context最常用的信息和功能，最常用的场景就是rpc调用，来看看一个grpc使用示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ctx, cancel := context.WithTimeout(parent, 100 * time.Millisecond)</span><br><span class="line">response, err := grpcClient.Send(ctx, request)</span><br></pre></td></tr></table></figure><p>WithTimeout 方法内部就是设置了 deadline，context 将会在超时时间到来的时候触发 Done 对应的channel close。这样我们可以通过 &lt;- context.Done) 来做一些提前结束的操作，比如释放资源，避免超时请求一直阻塞其他正常请求。</p><p>总结一下，凡是涉及到上下游关系的都应该用context来处理调用关系，下游不应该忽略上游传下来的context。</p><p>扩展阅读：<br><a href="http://p.agnihotry.com/post/understanding_the_context_package_in_golang/">Understanding the context package in golang</a></p><h3 id="八、从来不用-race-参数"><a href="#八、从来不用-race-参数" class="headerlink" title="八、从来不用 -race 参数"></a>八、从来不用 -race 参数</h3><p>根据 报告-Understanding real-world concurrency bugs in Go ，尽管go 的设计初衷是“更少错误的高并发”，但是现实中我们依然会遇到并发带来的问题<br>尽管 race 检测器不一定可以检测出每一种并发错误，但是它依然是有价值的，在测试程序的过程中我们应该始终打开它。</p><p>相对其余9个错误来说，竞态条件是能直接导致程序崩溃的，所以这一节应该是最重要的一部分，建议gopher 在平时开发中都尽量留意这一点，测试和调试工作要做好。<br>但是 开启race 也不代表 冲突能够马上检查出来，也是要有冲突的时候，才会有Warning信息。所以建议采用线上环境留一个节点用来开启竞态检查的方式。</p><p>扩展阅读：<br><a href="https://blog.acolyer.org/2019/05/17/understanding-real-world-concurrency-bugs-in-go/">Understanding real-world concurrency bugs in Go</a><br><a href="https://medium.com/@val_deleplace/does-the-race-detector-catch-all-data-races-1afed51d57fb">Does the Go race detector catch all data race bugs?</a><br><a href="https://github.com/smiecj/go_common_mistake/blob/master/race_test.go">自己写的示例-git-race_test.go</a></p><h3 id="九、使用文件名作为输入（方法设计不满足SOLID原则）"><a href="#九、使用文件名作为输入（方法设计不满足SOLID原则）" class="headerlink" title="九、使用文件名作为输入（方法设计不满足SOLID原则）"></a>九、使用文件名作为输入（方法设计不满足SOLID原则）</h3><h4 id="9-1-从问题出发"><a href="#9-1-从问题出发" class="headerlink" title="9.1 从问题出发"></a>9.1 从问题出发</h4><p>来看一个常见的go 工具类开发需求：需要开发一个通用的读取文件行数的方法。项目中肯定会把这个方法封装到公共包的。<br>一种比较直接的思路，就是设置文件名作为传参，如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">func count(filename string) (int, error) &#123;</span><br><span class="line">  file, err := os.Open(filename)</span><br><span class="line">  if err != nil &#123;</span><br><span class="line">    return 0, errors.Wrapf(err, &quot;unable to open %s&quot;, filename)</span><br><span class="line">  &#125;</span><br><span class="line">  defer file.Close()</span><br><span class="line"></span><br><span class="line">  scanner := bufio.NewScanner(file)</span><br><span class="line">  count := 0</span><br><span class="line">  for scanner.Scan() &#123;</span><br><span class="line">    if scanner.Text() == &quot;&quot; &#123;</span><br><span class="line">      count++</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return count, nil</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种方式看上去功能没有任何问题，但是忽略了具体使用场景。如：</p><ul><li>文件编码：当然你可以让方法增加一个传参，但是不符合接下来说到的开闭原则</li><li>单元测试：测试读取一个空文件场景。那么单测可能还需要先在本地创建一个空文件</li></ul><p>这些细节，都会导致这个方法看上去完美，实际使用起来限制却很多。</p><h4 id="9-2-SOLID-原则"><a href="#9-2-SOLID-原则" class="headerlink" title="9.2 SOLID 原则"></a>9.2 SOLID 原则</h4><p>SOLID 是面向对象编程中很重要的原则，由 总结而来。</p><ul><li>S 表示  Single Responsibility （单一原则）：一个方法只做一件事</li><li>O 表示 open-close principle （开闭原则）：方法对扩展开放，对修改封闭</li></ul><p>从这个例子就是很好的说明：S 和 O 它实际都不满足，方法做了读取文件和扫描文件行数两件事、方法可能还需要因为文件编码做格式 做适配修改</p><h4 id="9-3-优化版本"><a href="#9-3-优化版本" class="headerlink" title="9.3 优化版本"></a>9.3 优化版本</h4><p>借鉴 go 对 io.Reader 和 io.Writer 的实现思路，我们可以将传参改成这样：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">func count(reader *bufio.Reader) (int, error) &#123;</span><br><span class="line">  count := 0</span><br><span class="line">  for &#123;</span><br><span class="line">    line, _, err := reader.ReadLine()</span><br><span class="line">    if err != nil &#123;</span><br><span class="line">      switch err &#123;</span><br><span class="line">      default:</span><br><span class="line">        return 0, errors.Wrapf(err, &quot;unable to read&quot;)</span><br><span class="line">      case io.EOF:</span><br><span class="line">        return count, nil</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if len(line) == 0 &#123;</span><br><span class="line">      count++</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样不仅满足和 S 和 O，方法的扩展性其实也加强了：可以读取文件流或者 http 流等的输入</p><p>调用端：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">file, err := os.Open(filename)</span><br><span class="line">if err != nil &#123;</span><br><span class="line">  return errors.Wrapf(err, &quot;unable to open %s&quot;, filename)</span><br><span class="line">&#125;</span><br><span class="line">defer file.Close()</span><br><span class="line">count, err := count(bufio.NewReader(file))</span><br></pre></td></tr></table></figure><p>单测：读取一行字符串流</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">count, err := count(bufio.NewReader(strings.NewReader(&quot;input&quot;)))</span><br></pre></td></tr></table></figure><p>因此，设计思想也非常重要，尽管代码规范之类的问题并不会直接导致程序运行问题，但是显然它的影响更为深远。</p><h3 id="十、协程和循环中的局部变量"><a href="#十、协程和循环中的局部变量" class="headerlink" title="十、协程和循环中的局部变量"></a>十、协程和循环中的局部变量</h3><h4 id="10-1-协程共用循环的局部变量"><a href="#10-1-协程共用循环的局部变量" class="headerlink" title="10.1 协程共用循环的局部变量"></a>10.1 协程共用循环的局部变量</h4><p>下面这段示例，会输出什么？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">func TestRoutineRace(t *testing.T) &#123;</span><br><span class="line">ints := []int&#123;1, 2, 3&#125;</span><br><span class="line">waitGroup := sync.WaitGroup&#123;&#125;</span><br><span class="line">waitGroup.Add(len(ints))</span><br><span class="line"></span><br><span class="line">for _, i := range ints &#123;</span><br><span class="line">go func() &#123;</span><br><span class="line">fmt.Printf(&quot;%v\n&quot;, i)</span><br><span class="line">waitGroup.Done()</span><br><span class="line">&#125;()</span><br><span class="line">&#125;</span><br><span class="line">waitGroup.Wait()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>显然目的是想打印 1、2、3的，但是结果却都是3<br>这是因为 子协程中，打印用的都是同一个局部变量i，这个i 在循环结束之后会变成3，所以最终打印的结果就都是3 了（大部分时候）</p><p>利用刚才学的race，这种使用协程的错误方式也可以通过 -race 参数 提前检测出来。<br>go test -v <strong>-race</strong> routine_test.go<br>检测结果：<br>……<br>WARNING: DATA RACE<br><strong>Read at 0x00c000116140 by goroutine 8:</strong><br>  command-line-arguments.TestRoutine.func1()<br>      D:/coding/golang/go_common_mistake/routine_test.go:16 +0x44</p><p><strong>Previous write at 0x00c000116140 by goroutine 7:</strong><br>  command-line-arguments.TestRoutine()<br>      D:/coding/golang/go_common_mistake/routine_test.go:14 +0x104<br>  testing.tRunner()<br>      G:/Program Files/Go/src/testing/testing.go:1127 +0x202<br>……</p><p>从错误信息可以看到，省略的部分还有其他协程，同样的警告信息。仔细分析下来就可以得到协程用的都是同一个局部变量的结论了。<br>怎么样，马上就体验到 -race 参数的作用了，是不是很妙</p><h4 id="10-2-避免直接使用循环中的局部变量"><a href="#10-2-避免直接使用循环中的局部变量" class="headerlink" title="10.2 避免直接使用循环中的局部变量"></a>10.2 避免直接使用循环中的局部变量</h4><p>对于这种情况有两种解决方法：<br>1）go func 加上入参</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">for _, i := range ints &#123;</span><br><span class="line">go func(i int) &#123;</span><br><span class="line">fmt.Printf(&quot;%v\n&quot;, i)</span><br><span class="line">waitGroup.Done()</span><br><span class="line">&#125;(i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2）循环内使用单独的局部变量<br><img src="/img/20210718105358253.png" alt="在这里插入图片描述"></p><p>注意虽然这里的I 依然是局部变量，但是对每个开启的协程来说已经不是同一个了，每次进入循环的I 都是不一样的。<br>但是这里我更推荐第一种写法，逻辑更加清楚</p>]]></content>
    
    
    <summary type="html">都是干货</summary>
    
    
    
    <category term="编程语言" scheme="http://smiecj.github.io/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    <category term="golang" scheme="http://smiecj.github.io/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/golang/"/>
    
    
    <category term="golang" scheme="http://smiecj.github.io/tags/golang/"/>
    
  </entry>
  
</feed>
