<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>flink cdc 3.0 &quot;尝鲜&quot;</title>
      <link href="/2024/06/19/flink-cdc-3.0/"/>
      <url>/2024/06/19/flink-cdc-3.0/</url>
      
        <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>在大数据实时同步的场景中，一个常见场景是从 mysql OLTP 数据库同步到 doris OLAP 数据库，前者属于业务系统通常情况下使用的数据库，后者提供给业务的同事进行高并发、大批量的数据计算和分析</p><p>今年年初时，我们这里的部署方案还是 flink cdc 2.4 + flink sql，任务在 yarn 上运行，架构如下:</p><p><img src="/2024/06/19/flink-cdc-3.0/flink-cdc-2.4.png" alt="flink cdc 2.4 structure"></p><p>这个架构在需要同步的表不多的情况下，维护起来不算麻烦，不过也有两个实践中很关键的问题: 通过 SQL 提交后每张表都会单独拉取 binlog，造成资源浪费，以及频繁拉取造成 MySQL 压力较大；其次是不支持表结构同步，比如 mysql 新增了字段，虽然不会直接导致同步任务报错（修改字段类型除外），但是一旦业务说需要用到这个字段，那我就需要在 flink sql 中加上这个字段，下游的 doris 手动执行 alter 去添加字段，再把 flink 任务重启，这些操作，比创建一个新的任务还要麻烦</p><p>于是在看到 flink 3.0 对 schema evolution 和批量表同步支持之后，我也是第一时间去尝鲜，根据官方文档: <a href="https://nightlies.apache.org/flink/flink-cdc-docs-release-3.2/zh/docs/get-started/quickstart/mysql-to-doris">Streaming ELT 同步 MySQL 到 Doris</a>，在本地运行了整套 mysql 、 doris 、 flink 以及 flink cdc 任务。本文总结了整套服务部署过程，也提示一些遇到的小坑，希望助大家丝滑体验 flink cdc</p><p>flink cdc 3.0 之后的任务架构如下:<br><img src="/2024/06/19/flink-cdc-3.0/flink-cdc-3.0.png" alt="flink cdc 3.0 structure"></p><!--[Introduction](https://nightlies.apache.org/flink/flink-cdc-docs-release-3.2/zh/docs/deployment/standalone)--><h2 id="flink-cdc-功能速览"><a href="#flink-cdc-功能速览" class="headerlink" title="flink cdc 功能速览"></a>flink cdc 功能速览</h2><p><a href="https://github.com/apache/flink-cdc">flink cdc</a> 是一个支持实时同步的数据流框架，相比其他第三方实现的实时同步框架，如 seatunnel、chunjun 等，它的优势在于 flink 社区原生支持，版本迭代和新功能发布更快，不足点在于缺少任务管理功能，需要自己做好任务监控和自动恢复机制</p><p>3.0 架构:<br><img src="/2024/06/19/flink-cdc-3.0/flink-cdc-3.0-structure.png" alt="flink cdc 3.0 structure"></p><p><a href="https://medium.com/@ipolyzos_/a-glimpse-into-flink-cdc-3-0-a985fb5895a5">图片来源-A Glimpse into Flink CDC 3.0</a></p><p>3.0 之后 cdc 整体的架构就很清晰了，架构中几个比较重要的概念如下：</p><p>CDC Client: 新的用于提交任务的客户端封装</p><p>Data Pipeline: 整个 flink cdc 数据流称为 pipeline，内部包括必须配置的 Data Source 和 Data Sink，以及可选的 router</p><p>Pipeline Connector: 支持 schema evolution 的数据源，目前有 mysql ( <a href="https://github.com/debezium/debezium">debezium</a> ) 、 paimon ( <a href="https://github.com/apache/paimon/tree/master/paimon-flink">paimon flink conector</a> ) 、 kafka ( <a href="https://github.com/apache/flink-connector-kafka">kafka flink connector</a> ) 、doris ( <a href="https://github.com/apache/doris-flink-connector">doris flink connector</a> ) 、 starrocks ( <a href="https://github.com/StarRocks/starrocks-connector-for-apache-flink">starrocks flink connector</a> ) 和 elasticsearch ( <a href="https://github.com/apache/flink-connector-elasticsearch">elasticsearch flink connector</a> )</p><p>Source Connector: 包括 pipeline connector 以及其他暂不支持 pipeline 的其他数据源，如 pgsql (debezium) 和 tidb ( <a href="https://github.com/tikv/client-java">tikv client java</a> ) 等，可直接引用或通过 flink sql 使用</p><p>Data Source: 数据读取端封装</p><p>Data Sink: 数据写入端封装</p><p>Table ID: 标识同步数据源时需要指定的表标识，如 mysql 就是表名，kafka 就是 topic</p><p>Transform: 通过 SQL 或者 UDF 注入字段转换的特殊逻辑</p><p>Route: 路由，支持设置不同表名映射、多表对单表映射等</p><h2 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h2><p>需要部署的 mysql, doris 和 flink 都可以单点模式运行，因此接下来的所有部署操作都在一个 centos8 容器内执行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 3306: mysql</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 9030: doris fe</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 8081: flink web</span></span><br><span class="line">docker run -it -p 3306:3306 -p 9030:9030 -p 8081:8081 -d --name test_flink centos8</span><br></pre></td></tr></table></figure><h3 id="flink-local-singleton"><a href="#flink-local-singleton" class="headerlink" title="flink local singleton"></a>flink local singleton</h3><p>flink 选择 1.18 版本, 本地启动 jobmanager 和 taskmanager</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 下载安装包</span></span><br><span class="line">wget https://dlcdn.apache.org/flink/flink-1.18.1/flink-1.18.1-bin-scala_2.12.tgz</span><br><span class="line">tar -xvf flink-1.18.1-bin-scala_2.12.tgz</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 设置默认配置</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> web ui port</span></span><br><span class="line">rest.port: 24001</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> web ui <span class="built_in">bind</span> address</span></span><br><span class="line">rest.bind-address: 0.0.0.0</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># 其他和内存相关的配置，在生产环境需要考虑扩容的: taskmanager.memory.process.size、jobmanager.memory.process.size 等</span></span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 启动 jobmanager 和 taskmanager</span></span><br><span class="line"></span><br><span class="line">bash /opt/modules/flink/bin/jobmanager.sh start</span><br><span class="line">bash /opt/modules/flink/bin/taskmanager.sh start</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 运行 wordcount example</span></span><br><span class="line">/opt/modules/flink/bin/flink run /opt/modules/flink/examples/batch/WordCount.jar</span><br></pre></td></tr></table></figure><h3 id="flink-cdc-3-0"><a href="#flink-cdc-3-0" class="headerlink" title="flink cdc 3.0"></a>flink cdc 3.0</h3><!--3.0 版本后，cdc 可以直接通过，相比之前需要通过类似 starrocks smt 的工具生成 flink sql 任务的方式要方便很多尤其是使用具备 pipeline 能力的数据源，支持在一个任务中配置多个数据库表，配置起来更加方便--><p>3.0 之后的 flink cdc 可以直接通过它自己封装的 Client 提交任务了，因此除了和 2.4 同样的要下载数据源对应的 jar 包外，还需用到官方提供的客户端</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 从 release 中下载并安装 flink cdc</span></span><br><span class="line">wget https://dlcdn.apache.org/flink/flink-cdc-3.1.1/flink-cdc-3.1.1-bin.tar.gz</span><br><span class="line">tar -xzvf flink-cdc-3.1.1-bin.tar.gz</span><br><span class="line">mv flink-cdc-3.1.1 flink-cdc</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 注意: lib 下面只有 cdc 本身的依赖，数据库相关的依赖包需要自行下载</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 运行创建 flink jdbc connector 的任务需要以下依赖</span></span><br><span class="line">wget https://repo1.maven.org/maven2/mysql/mysql-connector-java/8.0.30/mysql-connector-java-8.0.30.jar -O lib/mysql-connector-java-8.0.30.jar</span><br><span class="line"></span><br><span class="line">wget https://repo1.maven.org/maven2/org/apache/flink/flink-connector-jdbc/3.1.2-1.18/flink-connector-jdbc-3.1.2-1.18.jar -O lib/flink-connector-jdbc-3.1.2-1.18.jar</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 运行从 mysql 同步到 doris 的 CDC 任务还需要以下依赖</span></span><br><span class="line">wget https://repo.maven.apache.org/maven2/org/apache/flink/flink-cdc-pipeline-connector-mysql/3.1.1/flink-cdc-pipeline-connector-mysql-3.1.1.jar -O lib/flink-cdc-pipeline-connector-mysql-3.1.1.jar</span><br><span class="line"></span><br><span class="line">wget https://repo.maven.apache.org/maven2/org/apache/flink/flink-cdc-pipeline-connector-doris/3.1.1/flink-cdc-pipeline-connector-doris-3.1.1.jar -O lib/flink-cdc-pipeline-connector-doris-3.1.1.jar</span><br></pre></td></tr></table></figure><ul><li>注意: flink cdc 的版本要和 connector 的版本对应，否则可能会在提交任务时报 Cannot find factory with identifier “mysql” in the classpath</li></ul><!-- 编译: mvn clean package -DskipTests -Dspotless.apply.skip --><h3 id="mysql"><a href="#mysql" class="headerlink" title="mysql"></a>mysql</h3><p>这里我们部署 8.0.39 版本，作为数据源</p><blockquote><p>注: 一开始部署 8.4.3 最新版本 mysql ，发现读取 binlog 信息的 SHOW MASTER STATUS 竟然执行不了，替换成了 SHOW BINARY LOG STATUS ，而 flink cdc 还没有做适配，因此只能把 mysql 回退重装了。看来什么都用社区最新版还是有一些踩坑的风险的😂</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 从官网下载安装包，注意下载适配系统架构的版本</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> https://dev.mysql.com/downloads/mysql</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 注意: 系统若已有 mariadb 相关的安装包，安装会报冲突，需要先卸载 mariadb 相关包</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 下载 arm 的 mysql 官方安装包</span></span><br><span class="line"></span><br><span class="line">wget https://dev.mysql.com/get/Downloads/MySQL-8.4/mysql-community-common-8.0.39-1.el8.aarch64.rpm</span><br><span class="line">wget https://dev.mysql.com/get/Downloads/MySQL-8.0/mysql-community-client-plugins-8.0.39-1.el8.aarch64.rpm</span><br><span class="line">wget https://dev.mysql.com/get/Downloads/MySQL-8.0/mysql-community-libs-8.0.39-1.el8.aarch64.rpm</span><br><span class="line">wget https://dev.mysql.com/get/Downloads/MySQL-8.0/mysql-community-client-8.0.39-1.el8.aarch64.rpm</span><br><span class="line">wget https://dev.mysql.com/get/Downloads/MySQL-8.0/mysql-community-icu-data-files-8.0.39-1.el8.aarch64.rpm</span><br><span class="line">wget https://dev.mysql.com/get/Downloads/MySQL-8.0/mysql-community-server-8.0.39-1.el8.aarch64.rpm</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> x86</span></span><br><span class="line">wget https://dev.mysql.com/get/Downloads/MySQL-8.4/mysql-community-common-8.0.39-1.el8.x86_64.rpm</span><br><span class="line">wget https://dev.mysql.com/get/Downloads/MySQL-8.4/mysql-community-client-plugins-8.0.39-1.el8.x86_64.rpm</span><br><span class="line">wget https://dev.mysql.com/get/Downloads/MySQL-8.4/mysql-community-libs-8.0.39-1.el8.x86_64.rpm</span><br><span class="line">wget https://dev.mysql.com/get/Downloads/MySQL-8.4/mysql-community-client-8.0.39-1.el8.x86_64.rpm</span><br><span class="line">wget https://dev.mysql.com/get/Downloads/MySQL-8.4/mysql-community-icu-data-files-8.0.39-1.el8.x86_64.rpm</span><br><span class="line">wget https://dev.mysql.com/get/Downloads/MySQL-8.4/mysql-community-server-8.0.39-1.el8.x86_64.rpm</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 安装</span></span><br><span class="line">rpm -ivh mysql-community-common-8.0.39-1.el8.aarch64.rpm</span><br><span class="line">rpm -ivh mysql-community-client-plugins-8.0.39-1.el8.aarch64.rpm</span><br><span class="line">rpm -ivh mysql-community-libs-8.0.39-1.el8.aarch64.rpm</span><br><span class="line">rpm -ivh mysql-community-client-8.0.39-1.el8.aarch64.rpm</span><br><span class="line">rpm -ivh mysql-community-icu-data-files-8.0.39-1.el8.aarch64.rpm</span><br><span class="line">rpm -ivh mysql-community-server-8.0.39-1.el8.aarch64.rpm</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 初始化、首次启动 mysql</span></span><br><span class="line">mysqld --initialize</span><br><span class="line">mysqld --user=root</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 从 /var/<span class="built_in">log</span>/mysqld.log 中获得 mysql 初始密码</span></span><br><span class="line">cat /var/log/mysqld.log | grep &quot;A temporary password&quot;</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 从另一个窗口登录 mysql</span></span><br><span class="line">mysql -h127.0.0.1 -P3306 -uroot -p&#123;mysql初始密码&#125;</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 修改 root 密码</span></span><br><span class="line">SET PASSWORD = &#x27;&#123;mysql密码&#125;&#x27;;</span><br></pre></td></tr></table></figure><h3 id="doris"><a href="#doris" class="headerlink" title="doris"></a>doris</h3><p><a href="https://doris.apache.org/docs/dev/gettingStarted/what-is-apache-doris">doris</a> 是一个具备高性能实时计算和查询性能的OLAP数据库，经常用于从业务数据库实时同步数据后，进行海量数据分析、高并发即席查询、日志分析、用户画像分析等。在企业内最常用的场景是制作各种业务报表，提供给数据分析师和管理者。相关技术主要有存储模型、物化视图、向量化引擎、CBO优化等</p><p>doris 的基本组件为 fe 和 be，fe 负责管理集群，接收和处理用户请求，分析并得到SQL执行计划，be 负责数据存储和SQL的具体计算逻辑执行</p><p><img src="/2024/06/19/flink-cdc-3.0/doris-01.png" alt="doris structure"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> doris 3.0 版本需要用 jdk 17</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> adoptium 版本的开源 openjdk 可以从这里下载</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> https://github.com/adoptium/temurin17-binaries/releases</span></span><br><span class="line"></span><br><span class="line">wget https://github.com/adoptium/temurin17-binaries/releases/download/jdk-17.0.9%2B9/OpenJDK17U-jdk_aarch64_linux_hotspot_17.0.9_9.tar.gz</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 设置环境变量</span></span><br><span class="line">export JAVA_HOME=/opt/modules/java/jdk-17.0.9+9</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 下载 doris</span></span><br><span class="line">wget https://apache-doris-releases.oss-accelerate.aliyuncs.com/apache-doris-3.0.2-bin-arm64.tar.gz</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 修改配置</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> fe: http_port: frontend 界面地址，默认 9030</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> fe: meta_dir: frontend 元数据存储路径</span></span><br><span class="line">vim /opt/modules/doris/fe/conf/fe.conf</span><br><span class="line"></span><br><span class="line">meta_dir = /opt/modules/doris/fe/meta</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> be: storage_root_path: 存储路径</span></span><br><span class="line">vim /opt/modules/doris/be/conf/be.conf</span><br><span class="line">storage_root_path = /opt/modules/doris/be/data</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 启动 fe</span></span><br><span class="line">mkdir -p /opt/modules/doris/fe/meta</span><br><span class="line">/opt/modules/doris/fe/bin/start_fe.sh --daemon</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看启动日志</span></span><br><span class="line">tail -f /opt/modules/doris/fe/log/fe.log</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 启动 be</span></span><br><span class="line">mkdir -p /opt/modules/doris/be/data</span><br><span class="line">/opt/modules/doris/be/bin/start_be.sh --daemon</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看启动日志</span></span><br><span class="line">tail -f /opt/modules/doris/be/log/be.INFO</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 启动后，首次登录 fe 不需要密码，设置 root 密码并添加 be</span></span><br><span class="line">mysql -h127.0.0.1 -P9030 -uroot</span><br><span class="line"></span><br><span class="line">SET PASSWORD FOR &#x27;root&#x27; = PASSWORD(&#x27;&#123;Doris密码&#125;&#x27;);</span><br><span class="line"></span><br><span class="line">ALTER SYSTEM ADD BACKEND &quot;localhost:9050&quot;;</span><br></pre></td></tr></table></figure><blockquote><p>注: 容器内启动可能会遇到报错 Please set vm.max_map_count to be 2000000 under root using ‘sysctl -w vm.max_map_count=2000000’ ，为了测试可以先注释掉这段判断逻辑，在 /opt/modules/doris/be/bin/start_be.sh 中</p></blockquote><h2 id="任务配置与运行"><a href="#任务配置与运行" class="headerlink" title="任务配置与运行"></a>任务配置与运行</h2><p>前面的环境安装都是为了这里的任务运行做铺垫</p><h3 id="mysql-模拟表"><a href="#mysql-模拟表" class="headerlink" title="mysql 模拟表"></a>mysql 模拟表</h3><p>在 mysql 创建一张“业务”表</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 专辑</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `d_music`.`album` (</span><br><span class="line">  `id` <span class="type">varchar</span>(<span class="number">255</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `create_time` datetime <span class="keyword">DEFAULT</span> <span class="built_in">CURRENT_TIMESTAMP</span>,</span><br><span class="line">  `name` <span class="type">varchar</span>(<span class="number">255</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">  `album_artist` <span class="type">varchar</span>(<span class="number">255</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">  `<span class="keyword">year</span>` <span class="type">int</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;0&#x27;</span>,</span><br><span class="line">  `song_count` <span class="type">int</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;0&#x27;</span></span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8mb4;</span><br></pre></td></tr></table></figure><h3 id="通过-dagagen-实时向-mysql-写入数据"><a href="#通过-dagagen-实时向-mysql-写入数据" class="headerlink" title="通过 dagagen 实时向 mysql 写入数据"></a>通过 dagagen 实时向 mysql 写入数据</h3><p><a href="https://nightlies.apache.org/flink/flink-docs-master/docs/dev/python/table/python_table_api_connectors">flink connector</a> 数据源有各种连接器，其中 <a href="https://nightlies.apache.org/flink/flink-docs-master/docs/connectors/table/datagen">datagen</a> 是可以随机生成数据的 connector</p><p>针对刚才 mysql 创建的测试表，我们创建一个定时写入数据的任务:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- /opt/modules/flink/album.sql</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> TEMPORARY <span class="keyword">TABLE</span> album_datagen (</span><br><span class="line">    id STRING,</span><br><span class="line">    name STRING,</span><br><span class="line">    album_artist STRING,</span><br><span class="line">    `<span class="keyword">year</span>` <span class="type">INT</span>,</span><br><span class="line">    song_count <span class="type">INT</span></span><br><span class="line">) <span class="keyword">WITH</span> (</span><br><span class="line">    <span class="string">&#x27;connector&#x27;</span> <span class="operator">=</span> <span class="string">&#x27;datagen&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;rows-per-second&#x27;</span> <span class="operator">=</span> <span class="string">&#x27;3&#x27;</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> album_mysql (</span><br><span class="line">    id STRING,</span><br><span class="line">    name STRING,</span><br><span class="line">    album_artist STRING,</span><br><span class="line">    `<span class="keyword">year</span>` <span class="type">INT</span>,</span><br><span class="line">    song_count <span class="type">INT</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (id) <span class="keyword">NOT</span> ENFORCED</span><br><span class="line">) <span class="keyword">WITH</span> (</span><br><span class="line">   <span class="string">&#x27;connector&#x27;</span> <span class="operator">=</span> <span class="string">&#x27;jdbc&#x27;</span>,</span><br><span class="line">   <span class="string">&#x27;url&#x27;</span> <span class="operator">=</span> <span class="string">&#x27;jdbc:mysql://localhost:3306/d_music&#x27;</span>,</span><br><span class="line">   <span class="string">&#x27;username&#x27;</span> <span class="operator">=</span> <span class="string">&#x27;root&#x27;</span>,</span><br><span class="line">   <span class="string">&#x27;password&#x27;</span> <span class="operator">=</span> <span class="string">&#x27;&#123;mysql密码&#125;&#x27;</span>,</span><br><span class="line">   <span class="string">&#x27;table-name&#x27;</span> <span class="operator">=</span> <span class="string">&#x27;album&#x27;</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> `album_mysql` <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> album_datagen;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>注: 这里 flink sql 的表没有设置 create_time 字段，为了让其能使用 mysql 表的默认值</p></blockquote><blockquote><p>注: rows-per-second 配置为datagen每秒产生的数据量，默认为1w</p></blockquote><p>提交 flink sql:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/opt/modules/flink/bin/sql-client.sh -f /opt/modules/flink/album.sql</span><br></pre></td></tr></table></figure><p>提交后可以在 flink 界面看到 datagen 任务正常运行，并在 mysql 中查询到每秒写入的随机数据</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql -hlocalhost -P3306 -uroot -p<span class="string">&#x27;&#123;mysql密码&#125;&#x27;</span> -e <span class="string">&quot;select * from d_music.artist order by create_time desc limit 10&quot;</span></span><br></pre></td></tr></table></figure><p><img src="/2024/06/19/flink-cdc-3.0/flink-datagen-01.png" alt="flink datagen job"></p><p><img src="/2024/06/19/flink-cdc-3.0/flink-datagen-02.png" alt="flink datagen data"></p><h3 id="flink-cdc-任务配置与提交"><a href="#flink-cdc-任务配置与提交" class="headerlink" title="flink cdc 任务配置与提交"></a>flink cdc 任务配置与提交</h3><p>按照官方教程，修改 mysql 地址和 doris 地址、需要同步的库表即可</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># /opt/modules/flink-cdc/album.yaml</span></span><br><span class="line"><span class="attr">source:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">mysql</span></span><br><span class="line">  <span class="attr">hostname:</span> <span class="string">localhost</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">3306</span></span><br><span class="line">  <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">  <span class="attr">password:</span> &#123;<span class="string">mysql密码</span>&#125;</span><br><span class="line">  <span class="attr">tables:</span> <span class="string">d_music.album</span></span><br><span class="line">  <span class="attr">scan.incremental.snapshot.chunk.size:</span> <span class="number">1000</span></span><br><span class="line">  <span class="attr">scan.snapshot.fetch.size:</span> <span class="number">1000</span></span><br><span class="line">  <span class="attr">scan.startup.mode:</span> <span class="string">initial</span></span><br><span class="line">  <span class="attr">server-time-zone:</span> <span class="string">UTC+8</span></span><br><span class="line"></span><br><span class="line"><span class="attr">sink:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">doris</span></span><br><span class="line">  <span class="attr">fenodes:</span> <span class="string">localhost:8030</span></span><br><span class="line">  <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">  <span class="attr">password:</span> &#123;<span class="string">doris密码</span>&#125;</span><br><span class="line">  <span class="attr">table.create.properties.light_schema_change:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">table.create.properties.replication_num:</span> <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="attr">pipeline:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">sr_cdc_sink_doris_example</span></span><br><span class="line">  <span class="attr">parallelism:</span> <span class="number">1</span></span><br></pre></td></tr></table></figure><blockquote><p>注: 若任务运行的本地时区和 mysql 服务器时区不一致，server-time-zone 需要指定为本地时区</p></blockquote><blockquote><p>注: fenodes 对应 doris fe 的 http_port</p></blockquote><blockquote><p>注: scan.startup.mode: 类似 canal 的同步模式配置，initial 表示从头同步所有数据，还支持从指定时间戳同步</p></blockquote><p>然后我们提交这个任务, 正常等待个几秒，在 doris 就能查到从 mysql 同步过来的数据了</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 注意需要显式声明 FLINK_HOME 即 flink 安装路径，在 flink-cdc.sh 脚本中用到</span></span><br><span class="line">export FLINK_HOME=/opt/modules/flink</span><br><span class="line"></span><br><span class="line">/opt/modules/flink-cdc/bin/flink-cdc.sh /opt/modules/flink-cdc/album.yaml</span><br></pre></td></tr></table></figure><p><img src="/2024/06/19/flink-cdc-3.0/flink-cdc-job-01.png" alt="flink cdc job"></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查询 doris 最近写入的数据</span></span><br><span class="line">mysql <span class="operator">-</span>h127<span class="number">.0</span><span class="number">.0</span><span class="number">.1</span> <span class="operator">-</span>P9030 <span class="operator">-</span>uroot <span class="operator">-</span>p&#123;Doris密码&#125; <span class="operator">-</span>e &quot;select * from d_music.album order by create_time desc limit 10&quot;</span><br></pre></td></tr></table></figure><p><img src="/2024/06/19/flink-cdc-3.0/flink-cdc-job-02.png" alt="flink cdc job"></p><p>我们还能发现，Doris 这边是不需要提前建表的，flink cdc 已经帮我们建好了一张主键表，其中副本数之类的基本配置根据cdc 任务中的 table.create.properties.replication_num 来设置</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">create</span> <span class="keyword">table</span> d_music.album;</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `album` (</span><br><span class="line">  `id` <span class="type">varchar</span>(<span class="number">765</span>) <span class="keyword">NULL</span>,</span><br><span class="line">  `create_time` datetime <span class="keyword">NULL</span>,</span><br><span class="line">  `name` <span class="type">varchar</span>(<span class="number">765</span>) <span class="keyword">NULL</span>,</span><br><span class="line">  `album_artist` <span class="type">varchar</span>(<span class="number">765</span>) <span class="keyword">NULL</span>,</span><br><span class="line">  `<span class="keyword">year</span>` <span class="type">int</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `song_count` <span class="type">int</span> <span class="keyword">NULL</span></span><br><span class="line">) ENGINE<span class="operator">=</span>OLAP</span><br><span class="line"><span class="keyword">UNIQUE</span> KEY(`id`)</span><br><span class="line">DISTRIBUTED <span class="keyword">BY</span> HASH(`id`) BUCKETS AUTO</span><br><span class="line">PROPERTIES (</span><br><span class="line">&quot;replication_allocation&quot; <span class="operator">=</span> &quot;tag.location.default: 1&quot;,</span><br><span class="line">&quot;min_load_replica_num&quot; <span class="operator">=</span> &quot;-1&quot;,</span><br><span class="line">&quot;is_being_synced&quot; <span class="operator">=</span> &quot;false&quot;,</span><br><span class="line">&quot;storage_medium&quot; <span class="operator">=</span> &quot;hdd&quot;,</span><br><span class="line">&quot;storage_format&quot; <span class="operator">=</span> &quot;V2&quot;,</span><br><span class="line">&quot;inverted_index_storage_format&quot; <span class="operator">=</span> &quot;V2&quot;,</span><br><span class="line">&quot;enable_unique_key_merge_on_write&quot; <span class="operator">=</span> &quot;true&quot;,</span><br><span class="line">&quot;light_schema_change&quot; <span class="operator">=</span> &quot;true&quot;,</span><br><span class="line">&quot;disable_auto_compaction&quot; <span class="operator">=</span> &quot;false&quot;,</span><br><span class="line">&quot;enable_single_replica_compaction&quot; <span class="operator">=</span> &quot;false&quot;,</span><br><span class="line">&quot;group_commit_interval_ms&quot; <span class="operator">=</span> &quot;10000&quot;,</span><br><span class="line">&quot;group_commit_data_bytes&quot; <span class="operator">=</span> &quot;134217728&quot;,</span><br><span class="line">&quot;enable_mow_light_delete&quot; <span class="operator">=</span> &quot;false&quot;</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>当然，除了主键模型，doris 还支持聚合模型(Aggregate)和明细模型(Duplicate)表，参考 <a href="https://doris.apache.org/docs/dev/table-design/data-model/overview">data models</a>。但是 flink cdc 对于同步源表中主键的表，会默认创建主键模型表。因此有创建其他模型表的话就需要提前建了</p><p>关于 flink cdc 实现提前建表和 schema evolution 的实现可以参考对各个数据源的 MetadataApplier 实现，如 <a href="https://github.com/apache/flink-cdc/blob/master/flink-cdc-connect/flink-cdc-pipeline-connectors/flink-cdc-pipeline-connector-doris/src/main/java/org/apache/flink/cdc/connectors/doris/sink/DorisMetadataApplier.java">DorisMetadataApplier</a></p><h3 id="schema-evolution"><a href="#schema-evolution" class="headerlink" title="schema evolution"></a>schema evolution</h3><p>铺垫了这么久，终于来到了测试表结构变更同步的环节</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 添加字段</span></span><br><span class="line">mysql -hlocalhost -P3306 -uroot -p&#x27;&#123;mysql密码&#125;&#x27; -e &quot;ALTER TABLE d_music.album ADD COLUMN duration DOUBLE AFTER song_count&quot;</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 修改后确认 doris 表结构是否更新</span></span><br><span class="line">mysql -h127.0.0.1 -P9030 -uroot -p&#123;doris密码&#125; -e &quot;show create table d_music.album&quot;</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 修改 mysql 字段名称</span></span><br><span class="line">mysql -hlocalhost -P3306 -uroot -p&#x27;&#123;mysql密码&#125;&#x27; -e &quot;ALTER TABLE d_music.album RENAME COLUMN duration TO duration_total&quot;</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 删除 mysql 字段</span></span><br><span class="line">mysql -hlocalhost -P3306 -uroot -p&#x27;&#123;mysql密码&#125;&#x27; -e &quot;ALTER TABLE d_music.album DROP COLUMN duration_total&quot;</span><br></pre></td></tr></table></figure><p>从 flink taskmanager 日志中我们可以看到表结构变更时，会触发 SchemaChangeEvent 事件，后续的其他数据写入或变更操作都必须等待当前的 schema change 完成后才会继续进行，以保证数据一致性</p><p><img src="/2024/06/19/flink-cdc-3.0/flink-cdc-job-03.png" alt="flink taskmanager log"></p><blockquote><p>注: 表字段类型变更的同步在 <a href="https://github.com/apache/flink-cdc/blob/release-3.2.0/flink-cdc-connect/flink-cdc-pipeline-connectors/flink-cdc-pipeline-connector-doris/src/main/java/org/apache/flink/cdc/connectors/doris/sink/DorisMetadataApplier.java#L112">3.2.0</a> 版本之后才支持，本文所用的 3.1 不支持</p></blockquote><blockquote><p>注: 不同数据源对字段变更的适配完善程度有所不同，如 Doris 在 cdc 最新版支持字段类型变更，但 <a href="https://github.com/apache/flink-cdc/blob/release-3.2/flink-cdc-connect/flink-cdc-pipeline-connectors/flink-cdc-pipeline-connector-starrocks/src/main/java/org/apache/flink/cdc/connectors/starrocks/sink/StarRocksMetadataApplier.java#L292-L301">Starrocks</a> 还不支持</p></blockquote><h3 id="整库同步"><a href="#整库同步" class="headerlink" title="整库同步"></a>整库同步</h3><p>我们在 mysql 中再创建两张表</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> if <span class="keyword">not</span> <span class="keyword">exists</span> d_music.artist</span><br><span class="line">(</span><br><span class="line">    `id` <span class="type">varchar</span>(<span class="number">255</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    `create_time` datetime <span class="keyword">DEFAULT</span> <span class="built_in">CURRENT_TIMESTAMP</span>,</span><br><span class="line">    `name` <span class="type">varchar</span>(<span class="number">255</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">    `album_count` <span class="type">int</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;0&#x27;</span>,</span><br><span class="line">    <span class="keyword">PRIMARY</span> KEY (`id`)</span><br><span class="line">)ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8mb4;</span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> d_music.playlist</span><br><span class="line">(</span><br><span class="line">    `id` <span class="type">varchar</span>(<span class="number">255</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    `create_time` datetime <span class="keyword">DEFAULT</span> <span class="built_in">CURRENT_TIMESTAMP</span>,</span><br><span class="line">    `name` <span class="type">varchar</span>(<span class="number">255</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">    `comment` <span class="type">varchar</span>(<span class="number">255</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">    `song_count` <span class="type">int</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;0&#x27;</span>,</span><br><span class="line">    <span class="keyword">PRIMARY</span> KEY (`id`)</span><br><span class="line">)ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8mb4;</span><br></pre></td></tr></table></figure><p>对应的，我们在 flink 也再提交这两张新表的 datagen</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> TEMPORARY <span class="keyword">TABLE</span> artist_datagen (</span><br><span class="line">    id STRING,</span><br><span class="line">    name STRING,</span><br><span class="line">    album_count <span class="type">INT</span></span><br><span class="line">) <span class="keyword">WITH</span> (</span><br><span class="line">    <span class="string">&#x27;connector&#x27;</span> <span class="operator">=</span> <span class="string">&#x27;datagen&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;rows-per-second&#x27;</span> <span class="operator">=</span> <span class="string">&#x27;3&#x27;</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> TEMPORARY <span class="keyword">TABLE</span> playlist_datagen (</span><br><span class="line">    id STRING,</span><br><span class="line">    name STRING,</span><br><span class="line">    `comment` STRING,</span><br><span class="line">    song_count <span class="type">INT</span></span><br><span class="line">) <span class="keyword">WITH</span> (</span><br><span class="line">    <span class="string">&#x27;connector&#x27;</span> <span class="operator">=</span> <span class="string">&#x27;datagen&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;rows-per-second&#x27;</span> <span class="operator">=</span> <span class="string">&#x27;3&#x27;</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> artist_mysql (</span><br><span class="line">    id STRING,</span><br><span class="line">    name STRING,</span><br><span class="line">    album_count <span class="type">INT</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (id) <span class="keyword">NOT</span> ENFORCED</span><br><span class="line">) <span class="keyword">WITH</span> (</span><br><span class="line">   <span class="string">&#x27;connector&#x27;</span> <span class="operator">=</span> <span class="string">&#x27;jdbc&#x27;</span>,</span><br><span class="line">   <span class="string">&#x27;url&#x27;</span> <span class="operator">=</span> <span class="string">&#x27;jdbc:mysql://localhost:3306/d_music&#x27;</span>,</span><br><span class="line">   <span class="string">&#x27;username&#x27;</span> <span class="operator">=</span> <span class="string">&#x27;root&#x27;</span>,</span><br><span class="line">   <span class="string">&#x27;password&#x27;</span> <span class="operator">=</span> <span class="string">&#x27;&#123;mysql密码&#125;&#x27;</span>,</span><br><span class="line">   <span class="string">&#x27;table-name&#x27;</span> <span class="operator">=</span> <span class="string">&#x27;artist&#x27;</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> playlist_mysql (</span><br><span class="line">    id STRING,</span><br><span class="line">    name STRING,</span><br><span class="line">    `comment` STRING,</span><br><span class="line">    song_count <span class="type">INT</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (id) <span class="keyword">NOT</span> ENFORCED</span><br><span class="line">) <span class="keyword">WITH</span> (</span><br><span class="line">   <span class="string">&#x27;connector&#x27;</span> <span class="operator">=</span> <span class="string">&#x27;jdbc&#x27;</span>,</span><br><span class="line">   <span class="string">&#x27;url&#x27;</span> <span class="operator">=</span> <span class="string">&#x27;jdbc:mysql://localhost:3306/d_music&#x27;</span>,</span><br><span class="line">   <span class="string">&#x27;username&#x27;</span> <span class="operator">=</span> <span class="string">&#x27;root&#x27;</span>,</span><br><span class="line">   <span class="string">&#x27;password&#x27;</span> <span class="operator">=</span> <span class="string">&#x27;&#123;mysql密码&#125;&#x27;</span>,</span><br><span class="line">   <span class="string">&#x27;table-name&#x27;</span> <span class="operator">=</span> <span class="string">&#x27;playlist&#x27;</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> `artist_mysql` <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> artist_datagen;</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> `playlist_mysql` <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> playlist_datagen;</span><br></pre></td></tr></table></figure><p>最后我们再提交同步这三张表 flink cdc ，相比刚才同步一张表的配置只需要修改 tables，按照正则表达式配置即可。从 <a href="https://github.com/apache/flink-cdc/blob/master/flink-cdc-connect/flink-cdc-pipeline-connectors/flink-cdc-pipeline-connector-mysql/src/main/java/org/apache/flink/cdc/connectors/mysql/factory/MySqlDataSourceFactory.java">MySqlDataSourceFactory</a> 可以找到对 tables 配置的解析逻辑</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># /opt/modules/flink-cdc/album.yaml</span></span><br><span class="line">  <span class="attr">tables:</span> <span class="string">d_music.\.*</span></span><br></pre></td></tr></table></figure><p>提交所有任务后，flink 上将会有四个任务，三个 datagen 对应三张表，而 flink cdc 对应的所有表都在一个任务中同步</p><p><img src="/2024/06/19/flink-cdc-3.0/flink-cdc-job-04.png" alt="flink cdc all job"></p><p>另外，我们还可以注意 mysql 的连接数: 和 2.4 版本对比，这次一整个任务只需要一个连接，其读取 binlog 会自动解析给对应表的同步，而不需要每张表都创建一个连接</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查看 mysql 读取 binlog 相关的连接数</span></span><br><span class="line">mysql <span class="operator">-</span>hlocalhost <span class="operator">-</span>P3306 <span class="operator">-</span>uroot <span class="operator">-</span>p<span class="string">&#x27;&#123;mysql密码&#125;&#x27;</span> <span class="operator">-</span>e &quot;show processlist&quot; <span class="operator">|</span> grep &quot;Binlog Dump&quot;</span><br></pre></td></tr></table></figure><p>但注意: 有哪些表需要同步，是任务在创建的时候就解析的，后续源库再添加表，不会让现有的任务把这个新表也加入同步</p><!--### 扩展: 同步 tidb[使用最新版flink tidb cdc 同步数据到StarRocks](https://blog.csdn.net/gongxiucheng/article/details/124281253)截止目前 tidb 还不支持 pipeline 连接器 - [mysql](https://nightlies.apache.org/flink/flink-cdc-docs-release-3.1/zh/docs/connectors/pipeline-connectors/mysql)--><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>3.0 之后的 cdc 在功能上更加成熟，不仅是架构更清楚，通过 yaml 配置 cdc 任务的方式也更简化，和 flink 本身更统一了</p><p>不过从整个过程也能看到，在生产环境面对大量业务表需要同步的时候，先不说任务怎么做好监控，本身任务要做到高可用就必须把 checkpoint 打开，另外，不是所有 mysql 的表结构变更都能成功同步到下游，面对无法同步的特殊情况，还需要手动设置指定同步时间点恢复任务，一些繁琐的维护过程还是无法避免</p><p>后续有机会再探索一下这些优化的思路吧</p>]]></content>
      
      
      <categories>
          
          <category> 大数据 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 大数据 </tag>
            
            <tag> flink </tag>
            
            <tag> doris </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>azkaban-tools 项目介绍</title>
      <link href="/2024/04/25/azkaban-tools/"/>
      <url>/2024/04/25/azkaban-tools/</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.cnblogs.com/smiecj/p/18328700">本文cnblog博客地址</a></p><h2 id="文章结构"><a href="#文章结构" class="headerlink" title="文章结构"></a>文章结构</h2><p>本文背景 -&gt; 项目背景 -&gt; azkaban 编译方式 -&gt; jq 基本使用方法 -&gt; 后记</p><h2 id="本文背景"><a href="#本文背景" class="headerlink" title="本文背景"></a>本文背景</h2><p>应一个用户的好心和好奇心，在最近<strong>水深火热的百忙之中</strong>抽时间写完了一个简短的项目介绍，项目代码不多，其实就是几个azkaban的批量操作脚本，但在大数据集群的“运维生涯”中，还是帮了自己不少忙的，也算是为了它做一个简单的回顾吧</p><h2 id="项目背景"><a href="#项目背景" class="headerlink" title="项目背景"></a>项目背景</h2><p><a href="https://github.com/azkaban/azkaban">azkaban</a> 是一个大数据领域通用的任务管理服务，它的运行模式和其他任务管理服务类似，都是将任务下发到执行器，定期执行，它的优势主要在于可定义任务流，同个项目下不同任务可引用同个模板，大数据领域的任务正好比较具有复用性，因此在 azkaban 诞生的时代（<a href="https://github.com/azkaban/azkaban/releases/tag/2.6.1">第一个release</a>在2014年），它还是成为了当时比较流行的开源任务调度服务</p><p>azkaban 的操作方式比较容易上手，通过界面即可完成所有的操作，包括上传项目、执行项目中定义的job、查看job日志、给任务配置调度时间等，操作并不复杂。但如果需要批量做一些操作，在界面一个个点就不太方便了</p><p>之前没有做这个项目的时候，隔三差五用户就要来找我“能不能帮忙…”（具体对话参考下面），终于有一天没忍住，本项目就此诞生…</p><p>主要实现的批量操作场景如下：</p><h3 id="批量操作①-启动任务"><a href="#批量操作①-启动任务" class="headerlink" title="批量操作① 启动任务"></a>批量操作① 启动任务</h3><p>每年都会有个一两次的真实对话</p><!--<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">用户: 昨晚集群是不是有点问题啊，有几个抽数任务跑失败了</span><br><span class="line">我: 啊，好像是有点问题...我看一下，要不一会我重新拉起一次吧</span><br><span class="line">用户: 但是失败的任务好像有点多啊，你要一个个拉起吗</span><br><span class="line">我: 我试试用脚本批量拉起吧...</span><br></pre></td></tr></table></figure><p>–&gt;</p><p><img src="/2024/04/25/azkaban-tools/10.png" alt="对话"></p><h3 id="批量操作②-启动任务"><a href="#批量操作②-启动任务" class="headerlink" title="批量操作② 启动任务"></a>批量操作② 启动任务</h3><p>azkaban 默认不允许同时执行同一个任务，因此如果任务在上个周期执行一直没结束，到下个周期也不会被触发</p><p>于是偶尔也会有以下的对话</p><!--<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">用户: http://azkaban/executor 这几个任务跑了好几天了，还没结束</span><br><span class="line">我: 我看看</span><br><span class="line">我: 这几个任务计算量怎么这么大，跑了一天多了</span><br><span class="line">用户: 哦，好像是有个参数设置错了，你先帮我把这些任务都停一下吧</span><br></pre></td></tr></table></figure><p>–&gt;</p><p><img src="/2024/04/25/azkaban-tools/14.png" alt="对话"></p><h3 id="批量操作③-设置调度"><a href="#批量操作③-设置调度" class="headerlink" title="批量操作③ 设置调度"></a>批量操作③ 设置调度</h3><p>对离线抽数任务来说，有时业务会新增好几张表，并要求执行时间统一放在早上8点或是晚上8点这样的</p><!--<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">用户: 大佬，帮忙加一下这几张表的调度，时间早上8点</span><br><span class="line">我: 好的</span><br></pre></td></tr></table></figure><p>–&gt;</p><p><img src="/2024/04/25/azkaban-tools/15.png" alt="对话"></p><h3 id="批量操作④-设置调度"><a href="#批量操作④-设置调度" class="headerlink" title="批量操作④ 设置调度"></a>批量操作④ 设置调度</h3><p>背景同上，调度周期如果要修改，比如从早上8点改成9点，需要先把原来的调度删除后再创建新的调度</p><h2 id="如何使用"><a href="#如何使用" class="headerlink" title="如何使用"></a>如何使用</h2><h3 id="本地部署-azkaban"><a href="#本地部署-azkaban" class="headerlink" title="本地部署 azkaban"></a>本地部署 azkaban</h3><p>azkaban 提供两种部署模式: solo （单节点）和 webserver+executor集群模式，生产环境肯定是采用后者，本地测试可以通过 solo 模式快速部署</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 第三方镜像</span></span><br><span class="line">docker run -d -p 8081:8081 --name azkaban-srv -e TZ=<span class="string">&#x27;Asia/Shanghai&#x27;</span> haxqer/azkaban</span><br><span class="line"></span><br><span class="line"><span class="comment"># 下载代码</span></span><br><span class="line">git <span class="built_in">clone</span> https://github.com/azkaban/azkaban</span><br><span class="line"><span class="comment"># 注意: 官方仓库久未维护，直接编译甚至会有报错，也可以拉取笔者 fork 后修复的仓库</span></span><br><span class="line"><span class="comment"># 修复 commit: https://github.com/smiecj/azkaban/commit/94dc6034ee522199db7a8b4f315cfa0779f37bf6</span></span><br><span class="line">git <span class="built_in">clone</span> https://github.com/smiecj/azkaban -b b_3_90_extend</span><br><span class="line"></span><br><span class="line"><span class="comment"># 编译</span></span><br><span class="line">./gradlew build installDist</span><br><span class="line"></span><br><span class="line"><span class="comment"># solo模式启动</span></span><br><span class="line"><span class="built_in">cd</span> azkaban-solo-server/build/install/azkaban-solo-server</span><br><span class="line">./bin/start-solo.sh</span><br></pre></td></tr></table></figure><p>访问刚启动的 solo 服务器: <a href="http://localhost:8081/">http://localhost:8081</a> ，默认用户名密码都是 azkaban</p><p><img src="/2024/04/25/azkaban-tools/01.png" alt="首次登录，首页还没有项目"></p><h3 id="创建项目"><a href="#创建项目" class="headerlink" title="创建项目"></a>创建项目</h3><p>这里我们创建一个示例项目 examples, 并以 <a href="https://github.com/joeharris76/azkaban_examples">azkaban_examples</a> 作为项目代码，压缩成zip包后上传</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/joeharris76/azkaban_examples</span><br><span class="line">zip -r azkaban_examples.zip azkaban_examples</span><br></pre></td></tr></table></figure><p><img src="/2024/04/25/azkaban-tools/02.png" alt="上传任务压缩包后azkaban会解析出任务结构"></p><p>azkaban 项目下的任务结构一般是 flow-&gt;job-&gt;template，flow 是父任务，job 为子任务。flow 可以通过串行或并行定义一组job的关系，job 可以直接定义任务行为，也可以引用template，在template中定义具体行为</p><p>以笔者实际维护的离线抽数作为例子，就是一个比较标准的azkaban任务格式:<br><img src="/2024/04/25/azkaban-tools/18.png" alt="STG"></p><p>所有抽数任务都在每天早上7点执行，每个抽数任务都对应一张mysql表，具体指令都是通过sqoop指令将数据从mysql导入hive表，区别只是执行sqoop的参数（即库表名）。这种任务我们就可以在 template 中编写sqoop的执行逻辑，每个表的同步任务作为一个job，都引用定义了sqoop 操作的 template 即可</p><p>具体的任务定义示例:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># template/sqoop.job</span></span><br><span class="line"><span class="built_in">command</span>=sqoop import -Dmapreduce.job.user.classpath.first=<span class="literal">true</span> --connect jdbc:mysql://mysql_host:mysql_port/<span class="variable">$&#123;mysql_db&#125;</span> --username mysql_user --password mysql_pwd --table <span class="variable">$&#123;mysql_table&#125;</span> -m 1 --target-dir /import/stg/<span class="variable">$&#123;mysql_table&#125;</span> --as-avrodatafile</span><br><span class="line"></span><br><span class="line"><span class="comment"># stg/table1.job</span></span><br><span class="line">mysql_db=element</span><br><span class="line">mysql_table=orders</span><br><span class="line"></span><br><span class="line"><span class="built_in">command</span>=<span class="built_in">echo</span> <span class="string">&quot;import mysql table&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">type</span>=flow</span><br><span class="line">flow.name=sqoop</span><br></pre></td></tr></table></figure><p>examples 项目结构也比较简单，basic_flow 和 workflow 是最上层的 flow，basic_flow 引用的8个job直接定义了执行echo的行为；workflow引用的4个job则都属于同一个template，同样都是echo操作，只是最后打印的内容不同</p><p><img src="/2024/04/25/azkaban-tools/16.png" alt="basic_flow任务结构"></p><p><img src="/2024/04/25/azkaban-tools/17.png" alt="workflow任务结构"></p><p>手动执行两个flow，可以看到它们的执行速度都非常快，因为到最后的子任务都只是执行 echo</p><p><img src="/2024/04/25/azkaban-tools/04.png" alt="执行basic_flow"></p><p><img src="/2024/04/25/azkaban-tools/03.png" alt="basic_flow执行结果"></p><p>为了方便接下来的测试，我们可以给basic_flow下的job添加sleep以增加执行时间</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 每个job增加睡眠时间，序号越大睡眠时间越长</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> &#123;1..8&#125;</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">&quot;command.1=sleep <span class="variable">$&#123;i&#125;</span>&quot;</span> &gt;&gt; basic_flow/basic_step_<span class="variable">$&#123;i&#125;</span>.cmd.job</span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><h3 id="登录配置"><a href="#登录配置" class="headerlink" title="登录配置"></a>登录配置</h3><p>在正式使用 azkaban-tools 之前，我们需要先修改 env.sh 中和服务相关的配置</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># search_env_name: 查询操作的环境</span></span><br><span class="line">search_env_name=produce</span><br><span class="line"></span><br><span class="line"><span class="comment"># exec_env_name: 执行、修改等操作的环境</span></span><br><span class="line"><span class="comment"># 注: 一开始开发这个项目是为了将一个老集群部署的azkaban上的所有任务调度都迁移到新集群服务上。为防止误操作生产环境，区分了进行查询和执行操作时使用不同的环境</span></span><br><span class="line">exec_env_name=<span class="built_in">test</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## produce env 连接信息</span></span><br><span class="line">produce_azkaban_address=localhost:8081</span><br><span class="line">produce_azkaban_user=azkaban</span><br><span class="line">produce_azkaban_password=azkaban</span><br><span class="line"></span><br><span class="line"><span class="comment">## test env 连接信息</span></span><br><span class="line"><span class="comment">## 这里故意将测试环境地址配置成和生产环境不同（虽然都是本地地址），是为了接下来测试批量停止任务时，不会因为脚本中判断“执行环境地址和生产环境地址完全一致”而停止执行</span></span><br><span class="line">test_azkaban_address=127.0.0.1:8081</span><br><span class="line">test_azkaban_user=azkaban</span><br><span class="line">test_azkaban_password=azkaban</span><br></pre></td></tr></table></figure><h3 id="jq-工具"><a href="#jq-工具" class="headerlink" title="jq 工具"></a>jq 工具</h3><p>项目通过 <a href="https://github.com/jqlang/jq">jq</a> 工具来解析 azkaban 接口返回的json数据</p><p>jq 可以通过 yum/apt 安装，或者直接下载可执行文件</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">wget https://github.com/stedolan/jq/releases/download/jq-1.6/jq-linux64</span><br><span class="line">mv jq-linux64 /usr/<span class="built_in">local</span>/bin/jq</span><br><span class="line">chmod +x jq</span><br></pre></td></tr></table></figure><p>jq 作为命令行工具，解析json还是非常好用的，常用指令可以参考后面的章节</p><h3 id="批量启动任务"><a href="#批量启动任务" class="headerlink" title="批量启动任务"></a>批量启动任务</h3><p>如果需要把examples的两个flow都调度起来，可以这么配置:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 需要执行的项目名</span></span><br><span class="line">execute_project_name=<span class="string">&quot;examples&quot;</span></span><br><span class="line"><span class="comment"># 禁止执行的任务名</span></span><br><span class="line">execute_block_flow_names=<span class="string">&quot;(^_template$)&quot;</span></span><br><span class="line"><span class="comment"># 允许执行的任务名</span></span><br><span class="line">execute_allow_flow_names=<span class="string">&quot;&quot;</span></span><br></pre></td></tr></table></figure><p>配置完成后直接执行 <code>make run</code>，即可同时拉起两个任务</p><p><img src="/2024/04/25/azkaban-tools/05.png" alt="两个flow被同时拉起"></p><h3 id="批量停止任务"><a href="#批量停止任务" class="headerlink" title="批量停止任务"></a>批量停止任务</h3><p>配置和启动任务一样，执行 <code>make kill</code>，即可把项目下所有<strong>执行中</strong>的任务停止</p><h3 id="批量创建调度"><a href="#批量创建调度" class="headerlink" title="批量创建调度"></a>批量创建调度</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 操作项目名</span></span><br><span class="line">target_project_name=<span class="string">&quot;examples&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 需要设置调度的白名单，不配置默认会设置项目下的所有任务</span></span><br><span class="line">flow_name_allowlist=<span class="string">&quot;(^workflow$|^basic_flow$)&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置的调度周期，java cron 格式</span></span><br><span class="line">fix_schedule_cron=<span class="string">&quot;0 0 18 * * ?&quot;</span></span><br></pre></td></tr></table></figure><p>注: 已经配有调度的任务不会覆盖</p><p><img src="/2024/04/25/azkaban-tools/06.png" alt="设置调度后"></p><h3 id="批量删除调度"><a href="#批量删除调度" class="headerlink" title="批量删除调度"></a>批量删除调度</h3><p>配置和创建调度相同，执行 <code>make clean_cron</code>即可删除任务调度</p><h2 id="部分脚本逻辑"><a href="#部分脚本逻辑" class="headerlink" title="部分脚本逻辑"></a>部分脚本逻辑</h2><h3 id="登录"><a href="#登录" class="headerlink" title="登录"></a>登录</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 登录方法需要返回azkaban地址和登录成功得到的session id 两个信息</span></span><br><span class="line"><span class="function"><span class="title">login</span></span>() &#123;</span><br><span class="line">    <span class="built_in">local</span> env_name=<span class="variable">$1</span></span><br><span class="line">    <span class="built_in">eval</span> $(get_azkaban_env_info_by_envname <span class="variable">$env_name</span>)</span><br><span class="line">    <span class="built_in">local</span> login_ret=`curl -X POST --data <span class="string">&quot;action=<span class="variable">$command_login</span>&amp;username=<span class="variable">$tmp_azkaban_user</span>&amp;password=<span class="variable">$tmp_azkaban_password</span>&quot;</span> http://<span class="variable">$tmp_azkaban_address</span> 2&gt;/dev/null`</span><br><span class="line">    <span class="built_in">local</span> tmp_session_id=`<span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$login_ret</span>&quot;</span> | jq <span class="string">&#x27;.[&quot;session.id&quot;] // empty&#x27;</span> | tr -d <span class="string">&#x27;&quot;&#x27;</span>`</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;tmp_azkaban_address=<span class="variable">$tmp_azkaban_address</span>&quot;</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;tmp_session_id=<span class="variable">$tmp_session_id</span>&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># eval $(login $exec_env_name)</span></span><br><span class="line"><span class="comment"># session_id=$tmp_session_id</span></span><br><span class="line"><span class="comment"># azkaban_address=$tmp_azkaban_address</span></span><br></pre></td></tr></table></figure><p>shell脚本中返回多个值的方法<a href="https://stackoverflow.com/a/32030550">参考</a>，<a href="https://phoenixnap.com/kb/bash-eval">eval</a>: 将传入的字符串当成指令执行</p><h3 id="获取任务下的所有-flow"><a href="#获取任务下的所有-flow" class="headerlink" title="获取任务下的所有 flow"></a>获取任务下的所有 flow</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">get_project_flow</span></span>() &#123;</span><br><span class="line">    <span class="built_in">local</span> project_name=<span class="variable">$1</span></span><br><span class="line">    <span class="built_in">local</span> session_id=<span class="variable">$2</span></span><br><span class="line">    <span class="built_in">local</span> azkaban_address=<span class="variable">$3</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">local</span> get_project_ret=`curl <span class="string">&quot;http://<span class="variable">$azkaban_address</span>/manager?ajax=<span class="variable">$command_get_project_flows</span>&amp;project=<span class="variable">$project_name</span>&amp;session.id=<span class="variable">$session_id</span>&quot;</span> 2&gt;/dev/null`</span><br><span class="line"></span><br><span class="line">    <span class="built_in">local</span> tmp_project_id=`<span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$get_project_ret</span>&quot;</span> | jq <span class="string">&#x27;.projectId // empty&#x27;</span>`</span><br><span class="line">    <span class="built_in">local</span> tmp_flow_count=`<span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$get_project_ret</span>&quot;</span> | jq <span class="string">&#x27;.flows | length&#x27;</span>`</span><br><span class="line">    <span class="built_in">local</span> tmp_flow_name=`<span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$get_project_ret</span>&quot;</span> | sed <span class="string">&quot;s/ //g&quot;</span> | jq -r <span class="string">&#x27;[.flows[].flowId] | join(&quot;,&quot;)&#x27;</span>`</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;project_id=<span class="variable">$tmp_project_id</span>&quot;</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;flow_name_join_str=<span class="variable">$tmp_flow_name</span>&quot;</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;flow_count=<span class="variable">$tmp_flow_count</span>&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="jq-基本用法"><a href="#jq-基本用法" class="headerlink" title="jq 基本用法"></a>jq 基本用法</h2><p>参考<a href="https://justcode.ikeepstudying.com/2018/02/shell%EF%BC%9A%E6%97%A0%E6%AF%94%E5%BC%BA%E5%A4%A7%E7%9A%84shell%E4%B9%8Bjson%E8%A7%A3%E6%9E%90%E5%B7%A5%E5%85%B7jq-linux%E5%91%BD%E4%BB%A4%E8%A1%8C%E8%A7%A3%E6%9E%90json-jq%E8%A7%A3%E6%9E%90-json">这篇文档</a>和<a href="https://jqlang.github.io/jq/manual">官方文档</a></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 获取某个key-value</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;&#123;&quot;hello&quot;: &quot;world&quot;&#125;&#x27;</span> | jq <span class="string">&#x27;.hello&#x27;</span> <span class="comment"># world</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取数组</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;&#123;&quot;arr&quot;: [1,2,3]&#125;&#x27;</span> | jq <span class="string">&#x27;.arr&#x27;</span> <span class="comment"># [1,2,3]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 数组所有元素用逗号组合</span></span><br><span class="line"><span class="comment"># 注意: 如果数组元素类型是数字，还要先通过tostring转成字符串</span></span><br><span class="line"><span class="comment"># -r: 直接打印，不再组装成json</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;&#123;&quot;arr&quot;: [1,2,3]&#125;&#x27;</span> | jq -r <span class="string">&#x27;[.arr[] | tostring] | join(&quot;,&quot;)&#x27;</span> <span class="comment"># 1,2,3</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 判断</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;&#123;&quot;hello&quot;: &quot;world&quot;&#125;&#x27;</span> | jq <span class="string">&#x27;has(&quot;world&quot;)&#x27;</span> <span class="comment"># false</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 选择器</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;&#123;&quot;arr&quot;: [1,2,3,4,5]&#125;&#x27;</span> | jq -r <span class="string">&#x27;[.arr[] | select(.&gt;2) | tostring] | join(&quot;,&quot;)&#x27;</span> <span class="comment"># 3,4,5</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 选择器和映射</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;&#123;&quot;arr&quot;: [1,2,3,4,5]&#125;&#x27;</span> | jq -r <span class="string">&#x27;.arr | map(select(.&gt;2))&#x27;</span> <span class="comment"># [3,4,5]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 排序</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;&#123;&quot;arr&quot;: [5,4,3,2,1]&#125;&#x27;</span> | jq -r <span class="string">&#x27;.arr | sort&#x27;</span> <span class="comment"># [1,2,3,4,5]</span></span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>未来或许是属于airflow的，我或许也是应该考虑 airflow-tools 该怎么写了</p><p>直到想起原来自己只是过了个单休，算了，挖坑的事情还是放以后吧😂</p>]]></content>
      
      
      <categories>
          
          <category> 大数据 </category>
          
          <category> azkaban </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 大数据 </tag>
            
            <tag> azkaban </tag>
            
            <tag> shell </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>make sadservers happy again</title>
      <link href="/2024/01/17/sadserver-intro/"/>
      <url>/2024/01/17/sadserver-intro/</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.cnblogs.com/smiecj/p/18306958">本文 cnblog 博客地址</a></p><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>从 <a href="https://www.ruanyifeng.com/blog/2022/11/weekly-issue-230.html">阮一峰老师的博客</a> 了解到 <a href="https://sadservers.com/">sadserver</a> 这样一个可以提供 linux 服务器，并尝试解决系统和服务相关问题的在线测试平台。非常难得的是它可以直接提供一个公网的linux服务器（一般40-60分钟后会自动销毁），你可以在上面做任何探索。对于想要学习常用 linux 指令的同学，是一个非常不错的练手平台</p><p>sadserver 大部分题目都是免费的，46道题中11道需要会员，会员一个月5美元。可以在完成其他题目之后再小小氪💰一下挑战剩下的题目</p><p>本文整理了目前sadserver所有题目的分类和解题相关指令，带部分“剧透”，建议对题目本身有强烈兴趣的同学直接动手尝试</p><p>*推荐: 标注推荐的主要是和 linux 常用指令相关的题目，其他开源服务相关的题目可以选择性了解</p><p>*提醒: 部分题目需要root用户权限，以执行系统配置修改等相关指令，可通过<code>sudo su</code>指令提权</p><h2 id="题目分类"><a href="#题目分类" class="headerlink" title="题目分类"></a>题目分类</h2><table><thead><tr><th>题目</th><th>类型/相关服务</th><th>题目/问题概述</th><th>相关指令</th></tr></thead><tbody><tr><td>“Saint John”: what is writing to this log file?</td><td>linux</td><td>查找文件占用的进程</td><td>lsof, find</td></tr><tr><td><strong>“Saskatoon”: counting IPs. (推荐)</strong></td><td>linux</td><td>字符串计数</td><td>awk, uniq, sort</td></tr><tr><td>“Santiago”: Find the secret combination (推荐)</td><td>linux</td><td>文本内容过滤</td><td>grep</td></tr><tr><td><strong>“Taipei”: Come a-knocking (推荐)</strong></td><td>linux</td><td>knock 端口开放</td><td>knocked</td></tr><tr><td><strong>“Lhasa”: Easy Math (推荐)</strong></td><td>linux</td><td>数值计算</td><td>bc</td></tr><tr><td>“Bucharest”: Connecting to Postgres</td><td>postgresql</td><td>pgsql配置修复</td><td></td></tr><tr><td>“Bilbao”: Basic Kubernetes Problems</td><td>kubernetes</td><td>服务配置修复</td><td>kubectl</td></tr><tr><td>“Apia”: Needle in a Haystack</td><td>linux</td><td>文本比较</td><td>diff</td></tr><tr><td>“Manhattan”: can’t write data into database.</td><td>postgresql</td><td>pgsql 配置修复</td><td></td></tr><tr><td><strong>“Tokyo”: can’t serve web file (推荐)</strong></td><td>httpd, linux</td><td>httpd 配置修复</td><td>iptables</td></tr><tr><td>“Cape Town”: Borked Nginx</td><td>nginx</td><td>nginx 配置修复</td><td>systemctl</td></tr><tr><td>“Salta”: Docker container won’t start</td><td>Docker</td><td>容器内服务启动问题</td><td>docker, netstat</td></tr><tr><td>“Oaxaca”: Close an Open File</td><td>linux</td><td>查找文件占用的进程</td><td>lsof, exec</td></tr><tr><td>“Melbourne”: WSGI with Gunicorn</td><td>gunicorn</td><td>gunicorn 配置修复</td><td></td></tr><tr><td>“Lisbon”: etcd SSL cert troubles</td><td>etcd 访问不通</td><td>etcd, iptables</td><td></td></tr><tr><td>“Kihei”: Surely Not Another Disk Space Scenario (推荐)</td><td>linux</td><td>挂盘</td><td>pvcreate, vgcreate, lvcreate, mount</td></tr><tr><td>“Unimak Island”: Fun with Mr Jason</td><td>linux</td><td>文本解析</td><td>jq</td></tr><tr><td>“Ivujivik”: Parlez-vous Français?</td><td>python</td><td>excel 解析</td><td>python</td></tr><tr><td>“Paris”: Where is my webserver?</td><td>linux</td><td>http 接口调用和参数</td><td>curl</td></tr><tr><td>“Buenos Aires”: Kubernetes Pod Crashing</td><td>kubernetes</td><td>kubernetes 权限体系</td><td>kubectl</td></tr><tr><td>“Tarifa”: Between Two Seas</td><td>nginx</td><td>nginx 配置修复</td><td>docker</td></tr><tr><td><strong>“Marrakech”: Word Histogram (推荐)</strong></td><td>sqlite</td><td>文本解析</td><td>sqlite</td></tr><tr><td>“Rosario”: Restore a MySQL database</td><td>mysql</td><td>mysql 故障恢复</td><td>mysql</td></tr><tr><td>“Abaokoro”: Restore MySQL Databases Spooked by a Ghost</td><td>mysql</td><td>mysql 数据导入</td><td>mysql</td></tr><tr><td>“Poznań”: Helm Chart Issue in Kubernetes</td><td>kubernetes</td><td>helm 基本使用</td><td>helm</td></tr><tr><td>“Manado”: How much do you press?</td><td>linux</td><td>解压缩常用指令的使用</td><td>zip, tar, xz</td></tr><tr><td>“Warsaw”: Prometheus can’t scrape the webserver</td><td>linux</td><td>go 服务问题修复</td><td>docker</td></tr><tr><td>“Moyogalpa”: Security Snag. The Trials of Mary and John</td><td>linux</td><td>服务文件权限和防火墙设置</td><td>apparmor, systemctl, update-ca-certificates</td></tr><tr><td>“Helsingør”: The first walls of postgres physical replication</td><td>postgresql</td><td>postgresql 同步主库相关配置修复</td><td>docker</td></tr><tr><td>“Bekasi”: Supervisor is still around</td><td>wsgi</td><td>wsgi 启动配置修复</td><td>curl, supervisorctl</td></tr><tr><td>“Depok”: Nginx with Brotli</td><td>nginx</td><td>nginx 插件安装</td><td>cmake, make, systemctl</td></tr><tr><td>“Tukaani”: XZ LZMA Library Compromised</td><td>linux</td><td>preload 库问题修复</td><td>lsof</td></tr><tr><td>“Jakarta”: it’s always DNS.</td><td>linux</td><td>DNS 解析配置修复</td><td></td></tr><tr><td>“Bern”: Docker web container can’t connect to db container.</td><td>wordpress</td><td>通过 docker 启动 wordpress</td><td>docker</td></tr><tr><td><strong>“Karakorum”: WTFIT – What The Fun Is This? (推荐)</strong></td><td>linux</td><td>定位系统和进程启动问题</td><td>perl, strace, python</td></tr><tr><td>“Singara”: Docker and Kubernetes web app not working.</td><td>kubernetes</td><td>镜像重建和提交</td><td>docker, kubectl</td></tr><tr><td>“Hong-Kong”: can’t write data into database.</td><td>postgresql</td><td>postgresql 配置问题修复</td><td>postgres, systemctl</td></tr><tr><td><strong>“Pokhara”: SSH and other sshenanigans (推荐)</strong></td><td>linux</td><td>ssh 和 su 问题解决</td><td>ssh, su, chage, ssh-keygen</td></tr><tr><td>“Roseau”: Hack a Web Server</td><td>linux</td><td>john 暴力破解工具的使用</td><td>john</td></tr><tr><td>“Belo-Horizonte”: A Java Enigma</td><td>linux</td><td>java 程序执行问题解决</td><td>java, javap, free, fallocate, mkswap, swapon</td></tr><tr><td>“Chennai”: Pull a Rabbit from a Hat</td><td>rabbitmq</td><td>rabbitmq 测试生产消费</td><td>docker, python</td></tr><tr><td>“Monaco”: Disappearing Trick</td><td>linux</td><td>git和进程环境变量</td><td>git</td></tr><tr><td>“Florence”: Database Migration Hell</td><td>微服务</td><td>js+web后台+pgsql问题解决</td><td>docker, sed</td></tr></tbody></table><h2 id="如何解题"><a href="#如何解题" class="headerlink" title="如何解题"></a>如何解题</h2><p><img src="/2024/01/17/sadserver-intro/01.png" alt="打开题目"></p><p><img src="/2024/01/17/sadserver-intro/02.png" alt="题目示例"></p><p><img src="/2024/01/17/sadserver-intro/03.png" alt="检查成功结果"></p><h2 id="Level-简单"><a href="#Level-简单" class="headerlink" title="Level: 简单"></a>Level: 简单</h2><h3 id="【linux】“Saint-John”-what-is-writing-to-this-log-file"><a href="#【linux】“Saint-John”-what-is-writing-to-this-log-file" class="headerlink" title="【linux】“Saint John”: what is writing to this log file?"></a>【linux】<a href="https://sadservers.com/scenario/saint-john">“Saint John”: what is writing to this log file?</a></h3><p><img src="/2024/01/17/sadserver-intro/04.png" alt="题目"></p><h4 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h4><p>服务器上有一个日志文件在被一个进程占用，需要找到这个进程并停止</p><h4 id="相关指令"><a href="#相关指令" class="headerlink" title="相关指令"></a>相关指令</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 查看文件占用进程 id</span></span><br><span class="line">lsof /var/log/bad.log</span><br><span class="line">ls -l /proc/*/fd/* | grep bad.log</span><br><span class="line">fuser /var/log/bad.log</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 确认文件是否最近未更新</span></span><br><span class="line">find /var/log/bad.log -mmin -0.1</span><br></pre></td></tr></table></figure><h3 id="【推荐】【linux】“Saskatoon”-counting-IPs"><a href="#【推荐】【linux】“Saskatoon”-counting-IPs" class="headerlink" title="【推荐】【linux】“Saskatoon”: counting IPs."></a>【推荐】【linux】<a href="https://sadservers.com/scenario/saskatoon">“Saskatoon”: counting IPs.</a></h3><p><img src="/2024/01/17/sadserver-intro/05.png" alt="题目"></p><h4 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h4><p>/home/admin/access.log 是一个 web 服务的访问记录日志（如 nginx 的访问日志就在 access.log 中），从中统计出访问次数最多的源ip</p><h4 id="相关指令-1"><a href="#相关指令-1" class="headerlink" title="相关指令"></a>相关指令</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 截取ip</span></span><br><span class="line">cat /home/admin/access.log | awk &#x27;&#123;print $1&#125;&#x27; &gt; /tmp/access_ips.log</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 排序</span></span><br><span class="line">cat /tmp/access_ips.log | sort &gt; /tmp/sort_ips.log</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 计数 &amp; 再排序</span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># uniq: 统计出现次数</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># sort: -n: 按数值排序而不是字符串序; -r: 逆序</span></span></span><br><span class="line">cat /tmp/sort_ips.log | uniq -c | sort -nr &gt; /tmp/count_ips.log</span><br></pre></td></tr></table></figure><h3 id="【推荐】【linux】“Santiago”-Find-the-secret-combination"><a href="#【推荐】【linux】“Santiago”-Find-the-secret-combination" class="headerlink" title="【推荐】【linux】“Santiago”: Find the secret combination"></a>【推荐】【linux】<a href="https://sadservers.com/scenario/santiago">“Santiago”: Find the secret combination</a></h3><p><img src="/2024/01/17/sadserver-intro/06.png" alt="题目"></p><h4 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h4><p>统计特定字符串在每个文件中的出现次数，并导出只出现一次的文件，出现位置的下一行内容</p><h4 id="相关指令-2"><a href="#相关指令-2" class="headerlink" title="相关指令"></a>相关指令</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 查找文件内容 &amp; 统计数量</span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># 注意: 题目要求是字符串出现次数，如果是统计词语可在 grep 之后加上 -w 参数</span></span></span><br><span class="line">find /home/admin -name &quot;*.txt&quot; | xargs grep -c &#x27;Alice&#x27;</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 输出之后一行（前一行是-B），且过滤出数字部分</span></span><br><span class="line">grep &quot;Alice&quot; -A1 /home/admin/1342-0.txt | grep -oE &quot;[0-9]+&quot;</span><br></pre></td></tr></table></figure><h3 id="The-Command-Line-Murders"><a href="#The-Command-Line-Murders" class="headerlink" title="The Command Line Murders"></a><a href="https://sadservers.com/scenario/command-line-murders">The Command Line Murders</a></h3><p>本题更像是解密游戏，而不是解决服务器问题，因此笔者选择（偷懒）跳过了这题，喜欢读解密类小说的可以试一下</p><h3 id="【推荐】【linux】“Taipei”-Come-a-knocking"><a href="#【推荐】【linux】“Taipei”-Come-a-knocking" class="headerlink" title="【推荐】【linux】“Taipei”: Come a-knocking"></a>【推荐】【linux】<a href="https://sadservers.com/scenario/taipei">“Taipei”: Come a-knocking</a></h3><p><img src="/2024/01/17/sadserver-intro/07.png" alt="题目"></p><h4 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h4><p>本机 80 端口启动了 http 服务，但端口被 knockd 进程限制访问，无法直接访问</p><p>需要通过 knock 对所有端口进行“开门”，使得 80 端口放开</p><p><a href="https://www.cnblogs.com/f-carey/p/16066178.html">参考-knock：端口敲门服务</a></p><h4 id="相关指令-3"><a href="#相关指令-3" class="headerlink" title="相关指令"></a>相关指令</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 对 1000 到 65535 的所有端口发送 knock 请求（ 发送 SYN ）</span></span><br><span class="line">for port in &#123;1000..65535&#125;</span><br><span class="line">do</span><br><span class="line">knock localhost $&#123;port&#125;</span><br><span class="line">done</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 扫描本地常见服务端口（ 发送 SYN ）</span></span><br><span class="line">nmap -p- localhost</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看 nmap 扫描的端口范围</span></span><br><span class="line">nmap -v -oG - | grep &quot;Ports scanned&quot;</span><br></pre></td></tr></table></figure><h3 id="【推荐】【linux】“Lhasa”-Easy-Math"><a href="#【推荐】【linux】“Lhasa”-Easy-Math" class="headerlink" title="【推荐】【linux】“Lhasa”: Easy Math"></a>【推荐】【linux】<a href="https://sadservers.com/scenario/lhasa">“Lhasa”: Easy Math</a></h3><p><img src="/2024/01/17/sadserver-intro/08.png" alt="题目"></p><h4 id="题意-4"><a href="#题意-4" class="headerlink" title="题意"></a>题意</h4><p>将一个文本中的第二列数字求和以及求平均</p><p>linux 本身的运算符支持整数运算，因此节点还提供了 python3 和 bc</p><h4 id="相关指令-4"><a href="#相关指令-4" class="headerlink" title="相关指令"></a>相关指令</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 获取第二列</span></span><br><span class="line">sum_expr=`awk &#x27;&#123;print $2&#125;&#x27; /home/admin/scores.txt </span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 将文本的每一行拼接到同一行，并用加号分隔</span></span><br><span class="line">paste -sd+ test.txt</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 计算数学表达式</span></span><br><span class="line">sum=`echo $&#123;expr&#125; | bc`</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 文本行数</span></span><br><span class="line">count=`cat scores.txt | wc -l`</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 保留两位小数，计算两数相除</span></span><br><span class="line">echo &quot;scale=2; $&#123;sum&#125; / $&#123;count&#125;&quot; | bc</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># python3 test.py</span></span><br><span class="line"><span class="built_in">sum</span> = <span class="number">0</span></span><br><span class="line">num = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">score_file = <span class="string">&#x27;/home/admin/scores.txt&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(score_file, <span class="string">&quot;r&quot;</span>) <span class="keyword">as</span> scores_file:</span><br><span class="line">    lines = data = scores_file.read().splitlines()</span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> lines:</span><br><span class="line">        score = line.split(<span class="string">&quot; &quot;</span>)[<span class="number">1</span>]</span><br><span class="line">        <span class="built_in">sum</span> += <span class="built_in">float</span>(score)</span><br><span class="line">        num += <span class="number">1</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;%.2f&quot;</span> % (<span class="built_in">sum</span> / num))</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// go run test.go</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;bufio&quot;</span></span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;os&quot;</span></span><br><span class="line"><span class="string">&quot;strconv&quot;</span></span><br><span class="line"><span class="string">&quot;strings&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">scoreFile, _ := os.Open(<span class="string">&quot;/root/scores.txt&quot;</span>)</span><br><span class="line"><span class="keyword">defer</span> scoreFile.Close()</span><br><span class="line"></span><br><span class="line">scanner := bufio.NewScanner(scoreFile)</span><br><span class="line">scoreCount := <span class="number">0</span></span><br><span class="line">scoreSum := <span class="number">0.0</span></span><br><span class="line"><span class="keyword">for</span> scanner.Scan() &#123;</span><br><span class="line">scoreStr := strings.Split(scanner.Text(), <span class="string">&quot; &quot;</span>)[<span class="number">1</span>]</span><br><span class="line">scoreFloat, _ := strconv.ParseFloat(scoreStr, <span class="number">32</span>)</span><br><span class="line">scoreSum += scoreFloat</span><br><span class="line">scoreCount++</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">&quot;%.2f\n&quot;</span>, <span class="keyword">float32</span>(scoreSum)/<span class="keyword">float32</span>(scoreCount))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="【postgresql】“Bucharest”-Connecting-to-Postgres"><a href="#【postgresql】“Bucharest”-Connecting-to-Postgres" class="headerlink" title="【postgresql】“Bucharest”: Connecting to Postgres"></a>【postgresql】<a href="https://sadservers.com/scenario/bucharest">“Bucharest”: Connecting to Postgres</a></h3><p><img src="/2024/01/17/sadserver-intro/09.png" alt="题目"></p><h4 id="题意-5"><a href="#题意-5" class="headerlink" title="题意"></a>题意</h4><p>本机启动了 postgresql 服务，但因为配置问题连接失败。需要修复 pgsql 配置并重启</p><h4 id="相关指令-5"><a href="#相关指令-5" class="headerlink" title="相关指令"></a>相关指令</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 指定密码、用户和 db 连接 pgsql</span></span><br><span class="line">PGPASSWORD=app1user psql -h 127.0.0.1 -d app1 -U app1user -c &#x27;\q&#x27;</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看 pgsql 进程和启动参数 (-e: 查看所有进程，-f: 列举所有进程信息)</span></span><br><span class="line">ps -ef | grep pgsql</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看 pgsql 服务基础配置文件</span></span><br><span class="line">vim /etc/postgresql/13/main/postgresql.conf</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看 pgsql 登录身份和允许访问源地址的配置文件</span></span><br><span class="line">vim /etc/postgresql/13/main/pg_hba.conf</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 重启 pgsql</span></span><br><span class="line">systemctl restart postgresql</span><br></pre></td></tr></table></figure><h3 id="【kubernetes】“Bilbao”-Basic-Kubernetes-Problems"><a href="#【kubernetes】“Bilbao”-Basic-Kubernetes-Problems" class="headerlink" title="【kubernetes】“Bilbao”: Basic Kubernetes Problems"></a>【kubernetes】<a href="https://sadservers.com/scenario/bilbao">“Bilbao”: Basic Kubernetes Problems</a></h3><p><img src="/2024/01/17/sadserver-intro/10.png" alt="题目"></p><h4 id="题意-6"><a href="#题意-6" class="headerlink" title="题意"></a>题意</h4><p>manifest.yaml 中定义了 nginx service，但启动失败了，需要通过 pod 的启动信息去解决</p><h4 id="相关指令-6"><a href="#相关指令-6" class="headerlink" title="相关指令"></a>相关指令</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 检查指令:</span> </span><br><span class="line">curl 10.43.216.196</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看 nginx pod 状态</span></span><br><span class="line">kubectl get pods</span><br><span class="line">kubectl describe pod nginx-deployment-67699598cc-zrj6f</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 解决 1 node(s) didn<span class="string">&#x27;t match Pod&#x27;</span>s node affinity/selector ...</span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># node 添加 label</span></span></span><br><span class="line">kubectl label nodes node1 disk=ssd</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># 删除 pod （触发重建）</span></span></span><br><span class="line">kubectl delete pod nginx-deployment-67699598cc-zrj6f</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 解决 1 Insufficient memory</span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># 减少 nginx 申请的内存资源</span></span></span><br><span class="line">sed -i &quot;s/memory:.*/memory: 500Mi/g&quot; manifest.yml</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># 重载 manifest.yml</span></span></span><br><span class="line">kubectl apply -f manifest.yml</span><br></pre></td></tr></table></figure><!--## 查看kubectl get nodes -o json | jq '.items[].spec'## 移除kubectl taint nodes --all node.kubernetes.io/unreachable:NoSchedule-kubectl taint nodes i-02f8e6680f7d5e616 node.kubernetes.io/unreachable:NoSchedule-kubectl taint nodes i-02f8e6680f7d5e616 node.kubernetes.io/unreachable:NoExecute---><h3 id="【linux】“Apia”-Needle-in-a-Haystack"><a href="#【linux】“Apia”-Needle-in-a-Haystack" class="headerlink" title="【linux】“Apia”: Needle in a Haystack"></a>【linux】<a href="https://sadservers.com/scenario/apia">“Apia”: Needle in a Haystack</a></h3><p><img src="/2024/01/17/sadserver-intro/11.png" alt="题目"></p><h4 id="题意-7"><a href="#题意-7" class="headerlink" title="题意"></a>题意</h4><p>在 /home/admin/data 目录下有很多 txt 文件，其中一个和其他文件内容不一样，而且只是在一个段落中多了一个单词，找到这个单词</p><h4 id="相关指令-7"><a href="#相关指令-7" class="headerlink" title="相关指令"></a>相关指令</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 输出文本的 md5 值</span></span><br><span class="line">md5sum  /home/admin/data/file1.txt</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 对比两个文本差异（段落级别）</span></span><br><span class="line">diff /home/admin/data/file1.txt /home/admin/data/file2.txt</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 对比两个文本差异（单词级别）</span></span><br><span class="line">wdiff /home/admin/data/file1.txt /home/admin/data/file2.txt</span><br></pre></td></tr></table></figure><h2 id="中等"><a href="#中等" class="headerlink" title="中等"></a>中等</h2><h3 id="【postgresql】“Manhattan”-can’t-write-data-into-database"><a href="#【postgresql】“Manhattan”-can’t-write-data-into-database" class="headerlink" title="【postgresql】“Manhattan”: can’t write data into database."></a>【postgresql】<a href="https://sadservers.com/scenario/manhattan">“Manhattan”: can’t write data into database.</a></h3><p><img src="/2024/01/17/sadserver-intro/12.png" alt="题目"></p><h4 id="题意-8"><a href="#题意-8" class="headerlink" title="题意"></a>题意</h4><p>本机启动了 postgresql 服务，但执行 insert 会失败，找到原因并解决</p><h4 id="相关指令-8"><a href="#相关指令-8" class="headerlink" title="相关指令"></a>相关指令</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 查看 postgresql 日志</span></span><br><span class="line">tail -f /var/log/postgresql/postgresql-14-main.log</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 重启 postgresql</span></span><br><span class="line">systemctl restart postgresql</span><br></pre></td></tr></table></figure><h3 id="【推荐】【httpd、linux】“Tokyo”-can’t-serve-web-file"><a href="#【推荐】【httpd、linux】“Tokyo”-can’t-serve-web-file" class="headerlink" title="【推荐】【httpd、linux】“Tokyo”: can’t serve web file"></a>【推荐】【httpd、linux】<a href="https://sadservers.com/scenario/tokyo">“Tokyo”: can’t serve web file</a></h3><p><img src="/2024/01/17/sadserver-intro/13.png" alt="题目"></p><h4 id="题意-9"><a href="#题意-9" class="headerlink" title="题意"></a>题意</h4><p>本机启动了 apache2（即 <a href="https://askubuntu.com/a/248412">httpd</a>） 服务，但执行 curl 127.0.0.1:80 没有任何返回，确认具体原因</p><h4 id="相关指令-9"><a href="#相关指令-9" class="headerlink" title="相关指令"></a>相关指令</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 查看防火墙规则列表</span></span><br><span class="line">iptables -L --line-numbers</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 删除指定规则</span></span><br><span class="line">iptables -t filter --delete INPUT 1</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 清空所有防火墙规则</span></span><br><span class="line">iptables -F</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 给文件添加所有用户可读权限</span></span><br><span class="line">chmod +r /var/www/html/index.html</span><br></pre></td></tr></table></figure><h3 id="【nginx】“Cape-Town”-Borked-Nginx"><a href="#【nginx】“Cape-Town”-Borked-Nginx" class="headerlink" title="【nginx】“Cape Town”: Borked Nginx"></a>【nginx】<a href="https://sadservers.com/scenario/capetown">“Cape Town”: Borked Nginx</a></h3><p><img src="/2024/01/17/sadserver-intro/14.png" alt="题目"></p><h4 id="题意-10"><a href="#题意-10" class="headerlink" title="题意"></a>题意</h4><p>本机安装了 nginx 但无法启动，检查启动失败原因，修复并启动</p><h4 id="相关指令-10"><a href="#相关指令-10" class="headerlink" title="相关指令"></a>相关指令</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 重启 nginx 服务</span></span><br><span class="line">systemctl restart nginx</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看 nginx 启动日志</span></span><br><span class="line">journalctl -u nginx</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看 nginx 启动错误日志</span></span><br><span class="line">tail -f /var/log/nginx/error.log</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看 nginx 配置</span></span><br><span class="line">/etc/nginx/nginx.conf</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看 nginx systemd 服务管理配置</span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># 关键配置: LimitNOFILE</span></span></span><br><span class="line">vim /etc/systemd/system/nginx.service</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 重新加载配置并重启 nginx</span></span><br><span class="line">systemctl daemon-reload</span><br><span class="line">systemctl restart nginx</span><br></pre></td></tr></table></figure><h3 id="【docker】“Salta”-Docker-container-won’t-start"><a href="#【docker】“Salta”-Docker-container-won’t-start" class="headerlink" title="【docker】“Salta”: Docker container won’t start."></a>【docker】<a href="https://sadservers.com/scenario/salta">“Salta”: Docker container won’t start.</a></h3><p><img src="/2024/01/17/sadserver-intro/15.png" alt="题目"></p><h4 id="题意-11"><a href="#题意-11" class="headerlink" title="题意"></a>题意</h4><p>本机 /home/admin/app 目录下有一个支持容器化的 node 应用，并提供 Dockerfile 可以直接构建<br>服务主逻辑在 server.js 中<br>需要构建镜像后，启动该服务，并解决调用该服务接口遇到的问题</p><h4 id="相关指令-11"><a href="#相关指令-11" class="headerlink" title="相关指令"></a>相关指令</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 构建镜像</span></span><br><span class="line">docker build -t app .</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 启动</span></span><br><span class="line">docker run -d --name app -p 8888:8888 app</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 检查端口占用</span></span><br><span class="line">netstat -tunlp | grep 8888</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看容器日志</span></span><br><span class="line">docker logs dd231758183e</span><br></pre></td></tr></table></figure><h3 id="【linux】“Oaxaca”-Close-an-Open-File"><a href="#【linux】“Oaxaca”-Close-an-Open-File" class="headerlink" title="【linux】“Oaxaca”: Close an Open File"></a>【linux】<a href="https://sadservers.com/scenario/oaxaca">“Oaxaca”: Close an Open File</a></h3><p><img src="/2024/01/17/sadserver-intro/16.png" alt="题目"></p><h4 id="题意-12"><a href="#题意-12" class="headerlink" title="题意"></a>题意</h4><p>/home/admin/somefile 正在被一个进程占用，找到占用原因，并使得下次登录终端后，该文件不会再被进程占用</p><p>相关知识点: <a href="https://www.geeksforgeeks.org/exec-command-in-linux-with-examples/">exec 指令</a></p><h4 id="相关指令-12"><a href="#相关指令-12" class="headerlink" title="相关指令"></a>相关指令</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 找到占用文件的进程 ，并直接 <span class="built_in">kill</span></span></span><br><span class="line">lsof /home/admin/somefile | tail -2 | awk &#x27;&#123;print $2&#125;&#x27; | xargs kill -9</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 一个会导致 /tmp/test.txt 被bash进程占用的指令</span></span><br><span class="line">exec 77&gt; /tmp/test.txt</span><br></pre></td></tr></table></figure><h3 id="【nginx、gunicorn】“Melbourne”-WSGI-with-Gunicorn"><a href="#【nginx、gunicorn】“Melbourne”-WSGI-with-Gunicorn" class="headerlink" title="【nginx、gunicorn】“Melbourne”: WSGI with Gunicorn"></a>【nginx、gunicorn】<a href="https://sadservers.com/scenario/melbourne">“Melbourne”: WSGI with Gunicorn</a></h3><p><img src="/2024/01/17/sadserver-intro/17.png" alt="题目"></p><h4 id="题意-13"><a href="#题意-13" class="headerlink" title="题意"></a>题意</h4><p>本机运行了 nginx 和 <a href="https://docs.gunicorn.org/en/latest/install.html">gunicorn</a>（实现了 WSGI 协议的 HTTP 服务器，master-worker 架构）</p><p>正常情况下，通过 curl 调用服务的调用链: curl -&gt; nginx -&gt; gunicorn -&gt; wesi.py，其中 /home/admin/wesi.py 中定义了接口的响应方式为返回200状态码和字符串”Hello World”</p><p>但是通过 curl -i <a href="http://localhost/">http://localhost</a> 调用接口失败了，找到原因并通过修改配置解决</p><p>相关教程: <a href="https://docs.gunicorn.org/en/latest/deploy.html">Deploying Gunicorn</a><br>相关知识点: <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Length">http header: content-length</a></p><h4 id="相关指令-13"><a href="#相关指令-13" class="headerlink" title="相关指令"></a>相关指令</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 查看 nginx 错误日志</span></span><br><span class="line">tail -f /var/log/nginx/error.log</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查找 nginx 配置目录下带有指定关键字的配置文件</span></span><br><span class="line">find /etc/nginx -name &#x27;*&#x27; -type f | xargs grep &quot;gunicorn&quot;</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 重启 nginx</span></span><br><span class="line">systemctl restart nginx</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看 gunicorn 配置</span></span><br><span class="line">vim /etc/systemd/system/gunicorn.service</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看 wsgi 服务配置</span></span><br><span class="line">vim /home/admin/wsgi.py</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 重启 gunicorn</span></span><br><span class="line">systemctl restart gunicorn</span><br></pre></td></tr></table></figure><!--[WSGI](https://zh.wikipedia.org/zh-cn/Web%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BD%91%E5%85%B3%E6%8E%A5%E5%8F%A3): Web Server Gateway Interface, 为Python语言定义的Web服务器和Web应用程序或框架之间的一种简单而通用的接口[gunicorn](https://docs.gunicorn.org/en/stable/): 基于 WSGI 实现的http服务器，类似 httpd--><h3 id="【etcd、linux】“Lisbon”-etcd-SSL-cert-troubles"><a href="#【etcd、linux】“Lisbon”-etcd-SSL-cert-troubles" class="headerlink" title="【etcd、linux】“Lisbon”: etcd SSL cert troubles"></a>【etcd、linux】<a href="https://sadservers.com/scenario/lisbon">“Lisbon”: etcd SSL cert troubles</a></h3><p><img src="/2024/01/17/sadserver-intro/18.png" alt="题目"></p><h4 id="题意-14"><a href="#题意-14" class="headerlink" title="题意"></a>题意</h4><p>本机部署了 etcd 服务，正常情况下可通过 <code>etcdctl get foo</code> 或 <code>curl -i https://localhost:2379/v2/keys/foo</code> 获取配置，但目前访问失败，需要解决</p><h4 id="相关指令-14"><a href="#相关指令-14" class="headerlink" title="相关指令"></a>相关指令</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 通过 etcdctl 获取配置</span></span><br><span class="line">etcdctl get foo</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 设置系统时间</span></span><br><span class="line">date -s &#x27;2023-01-29 00:00:00&#x27;</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 调用etcd接口</span></span><br><span class="line">curl -ik https://localhost:2379/v2/keys/foo</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看防火墙NAT类型的配置</span></span><br><span class="line">iptables -t nat -L</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 清空NAT类型防火墙规则</span></span><br><span class="line">iptables -t nat -F</span><br></pre></td></tr></table></figure><h3 id="【推荐】【linux】“Kihei”-Surely-Not-Another-Disk-Space-Scenario"><a href="#【推荐】【linux】“Kihei”-Surely-Not-Another-Disk-Space-Scenario" class="headerlink" title="【推荐】【linux】“Kihei”: Surely Not Another Disk Space Scenario"></a>【推荐】【linux】<a href="https://sadservers.com/scenario/kihei">“Kihei”: Surely Not Another Disk Space Scenario</a></h3><p><img src="/2024/01/17/sadserver-intro/19.png" alt="题目"></p><h4 id="题意-15"><a href="#题意-15" class="headerlink" title="题意"></a>题意</h4><p>当前路径的 kihei 程序会在 /home/admin/data 目录下创建一个 1.5G大小的文件，但因为磁盘空间不足，执行失败了，需要在不删除其他文件的情况下使得 kihei 能够正常执行</p><h4 id="相关指令-15"><a href="#相关指令-15" class="headerlink" title="相关指令"></a>相关指令</h4><p>本题是非常完整的磁盘挂载练手好题，可以结合挂盘相关的指令一起理解</p><p><a href="https://blog.csdn.net/MssGuo/article/details/120473476">参考: lvcreate 创建逻辑卷、vgcreate 创建卷组、pvcreate 创建物理卷、vgextend 扩容卷组、lv缩容</a></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 查看 kihei 进程的详细日志</span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># 注意: 这里的 kihei 可执行文件并不是来自开源项目...</span></span></span><br><span class="line">./kihei -v</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看本地磁盘使用情况和剩余空间</span></span><br><span class="line">df -h</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看所有磁盘</span></span><br><span class="line">lsblk</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 创建物理卷</span></span><br><span class="line">pvcreate /dev/nvme1n1</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看所有物理卷</span></span><br><span class="line">pvs</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 创建卷组</span></span><br><span class="line">vgcreate vg1 /dev/nvme1n1 /dev/nvme2n1</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看所有卷组</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 创建逻辑卷</span></span><br><span class="line">lvcreate -n lv1 -l 100%FREE vg1</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看逻辑卷</span></span><br><span class="line">lvs</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 格式化卷，初始化文件系统</span></span><br><span class="line">mkfs -t ext4 /dev/vg1/lv1</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 卷挂载，并设置目录权限</span></span><br><span class="line">mount /dev/vg1/lv1 /home/admin/data</span><br><span class="line">chown -R admin:root /home/admin/data</span><br></pre></td></tr></table></figure><h3 id="【linux】“Unimak-Island”-Fun-with-Mr-Jason"><a href="#【linux】“Unimak-Island”-Fun-with-Mr-Jason" class="headerlink" title="【linux】“Unimak Island”: Fun with Mr Jason"></a>【linux】<a href="https://sadservers.com/scenario/unimak">“Unimak Island”: Fun with Mr Jason</a></h3><p><img src="/2024/01/17/sadserver-intro/20.png" alt="题目"></p><h4 id="题意-16"><a href="#题意-16" class="headerlink" title="题意"></a>题意</h4><p>station_information.json 中包含若干个单车租赁站的信息，筛选其中 没有自动服务机（has_kiosk=false）且剩余单车超过30辆（capacity&gt;30）的租赁站，将它的id（station_id）写入答案文件中</p><h4 id="相关指令-16"><a href="#相关指令-16" class="headerlink" title="相关指令"></a>相关指令</h4><p>虽然题目提示本机有 <a href="https://github.com/jqlang/jq">jq</a> 、 <a href="https://github.com/tomnomnom/gron">gron</a> 和 <a href="https://github.com/simeji/jid">jid</a> 等工具，但后两者操作起来都不如同时包含解析和筛选器的 jq 方便，这里直接展示 jq 的几个基本指令，组合几个 filter ，就可以解答本题了</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 获取数组长度</span></span><br><span class="line">echo &quot;[1,2,3,4,5]&quot; | jq length</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 过滤器</span></span><br><span class="line">echo &#x27;&#123;&quot;dates&quot;:[&#123;&quot;day&quot;:&quot;monday&quot;,&quot;emotion&quot;:&quot;happy&quot;&#125;,&#123;&quot;day&quot;:&quot;tuesday&quot;,&quot;emotion&quot;:&quot;crazy&quot;&#125;]&#125;&#x27; | jq -r &#x27;.dates[] | select(.emotion==&quot;happy&quot;)&#x27;</span><br></pre></td></tr></table></figure><h3 id="【python、go】“Ivujivik”-Parlez-vous-Francais"><a href="#【python、go】“Ivujivik”-Parlez-vous-Francais" class="headerlink" title="【python、go】“Ivujivik”: Parlez-vous Français?"></a>【python、go】<a href="https://sadservers.com/scenario/ivujivik">“Ivujivik”: Parlez-vous Français?</a></h3><p><img src="/2024/01/17/sadserver-intro/21.png" alt="题目"></p><h4 id="题意-17"><a href="#题意-17" class="headerlink" title="题意"></a>题意</h4><p>table_tableau11.csv 文件中记录了总统选举中，各个选区的投票情况信息，需要按题目的筛选条件得到对应的选区名称</p><p>省份,选区名称,选区编号,人口,选民,投票站,有效选票,有效选票百分比,被拒绝的选票 被拒绝的选票,被拒绝的选票百分比,总投票数,选民投票率,当选候选人</p><h4 id="相关指令-17"><a href="#相关指令-17" class="headerlink" title="相关指令"></a>相关指令</h4><p>本题主要考察通过各个语言/工具解析 csv 的方法，这里展示 python 和 go 的解答方式</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># pandas</span></span><br><span class="line"><span class="keyword">import</span> csv</span><br><span class="line">max_reject = <span class="number">0</span></span><br><span class="line">answer = <span class="string">&quot;&quot;</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;table_tableau11.csv&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    reader = csv.reader(f)</span><br><span class="line">    <span class="built_in">next</span>(reader) <span class="comment"># skip first line</span></span><br><span class="line">    <span class="keyword">for</span> row <span class="keyword">in</span> reader:</span><br><span class="line">        current_reject = <span class="built_in">int</span>(<span class="built_in">float</span>(row[<span class="number">8</span>]))</span><br><span class="line">        current_population = <span class="built_in">int</span>(row[<span class="number">3</span>])</span><br><span class="line">        <span class="keyword">if</span> current_reject &gt; max_reject:</span><br><span class="line">            max_reject = current_reject</span><br><span class="line">            <span class="keyword">if</span> current_population &lt; <span class="number">100000</span>:</span><br><span class="line">                answer = row[<span class="number">1</span>]</span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;mysolution&#x27;</span>, <span class="string">&#x27;w&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    f.write(<span class="string">f&quot;<span class="subst">&#123;answer&#125;</span>\n&quot;</span>)</span><br><span class="line">    f.close()</span><br></pre></td></tr></table></figure><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;encoding/csv&quot;</span></span><br><span class="line"><span class="string">&quot;os&quot;</span></span><br><span class="line"><span class="string">&quot;io/ioutil&quot;</span></span><br><span class="line"><span class="string">&quot;strconv&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">f, _ := os.Open(<span class="string">&quot;table_tableau11.csv&quot;</span>)</span><br><span class="line"></span><br><span class="line">csvReader := csv.NewReader(f)</span><br><span class="line">csvReader.FieldsPerRecord = <span class="number">-1</span> <span class="comment">// ignore fields per record</span></span><br><span class="line">records, _ := csvReader.ReadAll()</span><br><span class="line"></span><br><span class="line">answer := <span class="string">&quot;&quot;</span></span><br><span class="line">maxReject := <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> _, currentRecord := <span class="keyword">range</span> records[<span class="number">1</span>:] &#123;</span><br><span class="line">currentReject, _ := strconv.Atoi(currentRecord[<span class="number">8</span>])</span><br><span class="line">currentPopulation, _ := strconv.Atoi(currentRecord[<span class="number">3</span>])</span><br><span class="line"><span class="keyword">if</span> currentReject &gt; maxReject &#123;</span><br><span class="line">maxReject = currentReject</span><br><span class="line"><span class="keyword">if</span> currentPopulation &lt; <span class="number">100000</span> &#123;</span><br><span class="line">answer = currentRecord[<span class="number">1</span>]</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ioutil.WriteFile(<span class="string">&quot;mysolution&quot;</span>, []<span class="keyword">byte</span>(answer + <span class="string">&quot;\n&quot;</span>), <span class="number">0644</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="【linux】“Paris”-Where-is-my-webserver"><a href="#【linux】“Paris”-Where-is-my-webserver" class="headerlink" title="【linux】“Paris”: Where is my webserver?"></a>【linux】<a href="https://sadservers.com/scenario/paris">“Paris”: Where is my webserver?</a></h3><p><img src="/2024/01/17/sadserver-intro/22.png" alt="题目"></p><h4 id="题意-18"><a href="#题意-18" class="headerlink" title="题意"></a>题意</h4><p>本题没有提示应该比较难做出来，因为问题相关的代码甚至都看不到，所以不是很推荐，主要考察对 user-agent header 的了解</p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/User-Agent">user-agent</a>: 表示客户端类型，默认为空，浏览器访问时将会自动填充</p><p>这里访问 5000 端口启动的服务端会对 user-agent 进行校验，如果为空将不会返回数据，需要指定任意的 user-agent 再调用 5000 端口，拿到答案需要的密码</p><h4 id="相关指令-18"><a href="#相关指令-18" class="headerlink" title="相关指令"></a>相关指令</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 添加 user-agent 调用接口</span></span><br><span class="line">curl --user-agent &quot;hhh&quot; http://localhost:5000</span><br><span class="line">curl -H &#x27;User-Agent: hhh&#x27; http://localhost:5000</span><br><span class="line">curl -A &#x27;hhh&#x27; http://localhost:5000</span><br></pre></td></tr></table></figure><h3 id="【kubernetes】“Buenos-Aires”-Kubernetes-Pod-Crashing"><a href="#【kubernetes】“Buenos-Aires”-Kubernetes-Pod-Crashing" class="headerlink" title="【kubernetes】“Buenos Aires”: Kubernetes Pod Crashing"></a>【kubernetes】<a href="https://sadservers.com/scenario/buenos-aires">“Buenos Aires”: Kubernetes Pod Crashing</a></h3><p><img src="/2024/01/17/sadserver-intro/23.png" alt="题目"></p><h4 id="题意-19"><a href="#题意-19" class="headerlink" title="题意"></a>题意</h4><p>本机部署了 k8s ，其中名为 logshipper 的 pod 启动失败了，需要确认失败原因</p><p>本题主要考察 k8s 的 clusterrole 对应的权限类型</p><h4 id="相关指令-19"><a href="#相关指令-19" class="headerlink" title="相关指令"></a>相关指令</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 查看所有 pod 的 label</span></span><br><span class="line">kubectl get pod --show-labels</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看指定 label 对应的 pod 信息和状态</span></span><br><span class="line">kubectl describe pod -l app=logshipper</span><br><span class="line">kubectl describe pod logshipper-597f84bf4f-6ssjq</span><br><span class="line">kubectl describe deployment logshipper</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看 pod 日志（提示权限不足）</span></span><br><span class="line">kubectl logs logshipper-597f84bf4f-6ssjq --follow</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看 logshipper pod 绑定的 serviceAccount 对应的 rolebinding 和 clusterrolebinding</span></span><br><span class="line">kubectl get rolebinding,clusterrolebinding --all-namespaces -o jsonpath=&#x27;&#123;range .items[?(@.subjects[0].name==&quot;logshipper-sa&quot;)]&#125;[&#123;.roleRef.kind&#125;,&#123;.roleRef.name&#125;]&#123;end&#125;&#x27;</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看指定 clusterrole</span></span><br><span class="line">kubectl describe ClusterRole logshipper-cluster-role</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 编辑 clusterrole 权限</span></span><br><span class="line">kubectl edit ClusterRole logshipper-cluster-role</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 删除（触发自动拉起新的pod）</span></span><br><span class="line">kubectl delete pod logshipper-597f84bf4f-6ssjq</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 获取服务状态</span></span><br><span class="line">kubectl get pods -l app=logshipper --no-headers -o json | jq -r &#x27;.items[] | &quot;\(.status.containerStatuses[0].ready)&quot;&#x27;</span><br></pre></td></tr></table></figure><h3 id="【haproxy、docker】“Tarifa”-Between-Two-Seas"><a href="#【haproxy、docker】“Tarifa”-Between-Two-Seas" class="headerlink" title="【haproxy、docker】“Tarifa”: Between Two Seas"></a>【haproxy、docker】<a href="https://sadservers.com/scenario/tarifa">“Tarifa”: Between Two Seas</a></h3><p><img src="/2024/01/17/sadserver-intro/24.png" alt="题目"></p><h4 id="题意-20"><a href="#题意-20" class="headerlink" title="题意"></a>题意</h4><p>本机通过 docker compose 启动了一个 haproxy 和两个 nginx。因为 haproxy 的配置（haproxy.cfg）策略是对两个 nginx 节点进行轮询（roundrobin）访问，因此正常情况下，调用 localhost:5000 会依次返回  “nginx_0” 和 “nginx_1”<br>但目前调用只返回了 “nginx_0”，需要找到原因</p><h4 id="相关指令-20"><a href="#相关指令-20" class="headerlink" title="相关指令"></a>相关指令</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 调用 haproxy</span></span><br><span class="line">curl localhost:5000</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看 haproxy pod 日志</span></span><br><span class="line">docker logs c79c9eb25143</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看 haproxy 配置</span></span><br><span class="line">vim haproxy.cfg</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看 nginx 配置</span></span><br><span class="line">vim custom-nginx_0.conf</span><br><span class="line">vim custom-nginx_1.conf</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看 docker compose 服务定义</span></span><br><span class="line">vim docker-compose.yml</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 重启 docker-compose 服务组</span></span><br><span class="line">docker compose down</span><br><span class="line">docker compose up -d</span><br></pre></td></tr></table></figure><h3 id="【推荐】【sqlite】“Marrakech”-Word-Histogram"><a href="#【推荐】【sqlite】“Marrakech”-Word-Histogram" class="headerlink" title="【推荐】【sqlite】“Marrakech”: Word Histogram"></a>【推荐】【sqlite】<a href="https://sadservers.com/scenario/marrakech">“Marrakech”: Word Histogram</a></h3><p><img src="/2024/01/17/sadserver-intro/25.png" alt="题目"></p><h4 id="题意-21"><a href="#题意-21" class="headerlink" title="题意"></a>题意</h4><p>frankestein.txt 文本中有一段文章，找到其中出现次数排第二多的单词<br>常见的单词分隔符为: .,:; ，且单词需忽略大小写</p><h4 id="相关指令-21"><a href="#相关指令-21" class="headerlink" title="相关指令"></a>相关指令</h4><p>这里通过 sqlite3 来解决本题</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 所有单词分隔后，转成全大写并按换行符分隔写入新文件</span></span><br><span class="line">cat frankestein.txt | tr &#x27;.&#x27; &#x27;\n&#x27; | tr &#x27;,&#x27; &#x27;\n&#x27; | tr &#x27;:&#x27; &#x27;\n&#x27; | tr &#x27;;&#x27; &#x27;\n&#x27; | tr &#x27; &#x27; &#x27;\n&#x27; | tr &#x27;&quot;&#x27; &#x27;\n&#x27; | sed -r &#x27;/^\s*$/d&#x27; | tr &#x27;a-z&#x27; &#x27;A-Z&#x27; &gt; frankestein_new.txt</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 写入文件头（作为 sqlite 加载的列名）</span></span><br><span class="line">sed -i &#x27;1iword&#x27; frankestein_new.txt</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> sqlite: 导入文本到words表</span></span><br><span class="line">.import frankestein_new.txt words</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> sql: 出现次数排第二的单词</span></span><br><span class="line">SELECT a.word, a.count_word FROM (SELECT word, count(word) AS count_word FROM words GROUP BY word) AS a ORDER BY a.count_word DESC LIMIT 1 OFFSET 1;</span><br></pre></td></tr></table></figure><h3 id="【mysql】“Rosario”-Restore-a-MySQL-database"><a href="#【mysql】“Rosario”-Restore-a-MySQL-database" class="headerlink" title="【mysql】“Rosario”: Restore a MySQL database"></a>【mysql】<a href="https://sadservers.com/scenario/rosario">“Rosario”: Restore a MySQL database</a></h3><p><img src="/2024/01/17/sadserver-intro/26.png" alt="题目"></p><p>本机启动了 <a href="https://github.com/MariaDB/server">mariadb</a> ，需要在 main 数据库中执行 backup.sql 中的语句，但题目没有提供数据库登录密码</p><p>本题主要考察 mysql/mariadb 如何通过免密模式启动，参考 <a href="https://dev.mysql.com/doc/refman/8.4/en/resetting-permissions.html">B.3.3.2 How to Reset the Root Password</a></p><h4 id="相关指令-22"><a href="#相关指令-22" class="headerlink" title="相关指令"></a>相关指令</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 查看/修改 mariadb 启动配置</span></span><br><span class="line">vim /usr/lib/systemd/system/mariadb.service</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 添加systemctl启动服务的环境变量</span></span><br><span class="line">[Service]</span><br><span class="line">Environment=&quot;MYSQLD_OPTS=&#x27;--skip-grant-tables&#x27;&quot;</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 重启 mariadb</span></span><br><span class="line">systemctl daemon-reload</span><br><span class="line">service mariadb restart</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 免密登录</span></span><br><span class="line">mysql</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 修正 backup.sql 语法问题</span></span><br><span class="line">sed -i &#x27;s#?$#;#g&#x27; /home/admin/backup.sql</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 执行 backup.sql</span></span><br><span class="line">use main;</span><br><span class="line">source /home/admin/backup.sql;</span><br><span class="line"></span><br><span class="line">mysql -Dmain &lt; /home/admin/backup.sql</span><br></pre></td></tr></table></figure><h3 id="【mysql】“Abaokoro”-Restore-MySQL-Databases-Spooked-by-a-Ghost"><a href="#【mysql】“Abaokoro”-Restore-MySQL-Databases-Spooked-by-a-Ghost" class="headerlink" title="【mysql】“Abaokoro”: Restore MySQL Databases Spooked by a Ghost"></a>【mysql】<a href="https://sadservers.com/scenario/abaokoro">“Abaokoro”: Restore MySQL Databases Spooked by a Ghost</a></h3><p><img src="/2024/01/17/sadserver-intro/27.png" alt="题目"></p><h4 id="题意-22"><a href="#题意-22" class="headerlink" title="题意"></a>题意</h4><p>本机启动了 mariadb ，需要将 dbs_to_restore.zip 中的三个 sql 文件分别导入 first 、 second 和 third 三个数据库中</p><h4 id="相关指令-23"><a href="#相关指令-23" class="headerlink" title="相关指令"></a>相关指令</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 检查磁盘占用</span></span><br><span class="line">du -h --max-depth=1 /var</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 解压</span></span><br><span class="line">tar -xzvf dbs_to_restore.tar.gz </span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 导入三个数据库（注：导入时间较长）</span></span><br><span class="line">mysql -e &quot;create database first&quot;</span><br><span class="line">mysql -Dfirst &lt; first.sql</span><br><span class="line"></span><br><span class="line">mysql -e &quot;create database second&quot;</span><br><span class="line">mysql -Dsecond &lt; second.sql</span><br><span class="line"></span><br><span class="line">mysql -e &quot;create database third&quot;</span><br><span class="line">mysql -Dthird &lt; third.sql</span><br></pre></td></tr></table></figure><h3 id="【k8s、helm】“Poznan”-Helm-Chart-Issue-in-Kubernetes"><a href="#【k8s、helm】“Poznan”-Helm-Chart-Issue-in-Kubernetes" class="headerlink" title="【k8s、helm】“Poznań”: Helm Chart Issue in Kubernetes"></a>【k8s、helm】<a href="https://sadservers.com/scenario/poznan">“Poznań”: Helm Chart Issue in Kubernetes</a></h3><p><img src="/2024/01/17/sadserver-intro/28.png" alt="题目"></p><p>本机通过 web_chart 目录定义的 nginx chart 启动了一个 nginx pod，期望是调用任何一个 nginx 的 80 端口都能返回 configmap.yaml 中定义的 “Welcome SadServers” 页面</p><p>但现在调用返回的是 nginx 默认的页面，configmap 配的页面并没有生效。需要使之生效，还需要将 nginx 的副本数修改为 3</p><p>本题主要考察 helm 的基本使用，以及 k8s configmap 如何注入到 pod 中，参考:<br><a href="https://stackoverflow.com/questions/71058097/how-do-i-attach-a-configmap-to-a-deployment-in-kubernetes/71058264#71058264">How do I attach a configmap to a deployment in Kubernetes?</a></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 获取 nginx pod 对应的 ip 并调用 nginx 服务</span></span><br><span class="line">pod_ip=`kubectl get pods -n default -o jsonpath=&#x27;&#123;.items[0].status.podIP&#125;&#x27;`</span><br><span class="line">curl $&#123;pod_ip&#125;</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看 deployment</span></span><br><span class="line">kubectl describe deployment web-chart-nginx</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 修改 chart values（包含副本数配置）</span></span><br><span class="line">helm get values web-chart --all</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 重装 web-chart</span></span><br><span class="line">helm uninstall web-chart</span><br><span class="line">helm install web-chart web_chart/</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 或: 更新 chart</span></span><br><span class="line">helm upgrade web-chart ./web_chart --values ./web_chart/values.yaml</span><br></pre></td></tr></table></figure><p>修改后的 deployment:</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">(省略)</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> &#123;&#123; <span class="string">.Chart.Name</span> &#125;&#125;</span><br><span class="line">          <span class="attr">image:</span> <span class="string">&quot;<span class="template-variable">&#123;&#123; .Values.image.repository &#125;&#125;</span>:<span class="template-variable">&#123;&#123; .Values.image.tag &#125;&#125;</span>&quot;</span></span><br><span class="line">          <span class="attr">imagePullPolicy:</span> &#123;&#123; <span class="string">.Values.image.pullPolicy</span> &#125;&#125;</span><br><span class="line">          <span class="attr">ports:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">http</span></span><br><span class="line">              <span class="attr">containerPort:</span> <span class="number">80</span></span><br><span class="line">              <span class="attr">protocol:</span> <span class="string">TCP</span></span><br><span class="line">          <span class="attr">volumeMounts:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="attr">mountPath:</span> <span class="string">/usr/share/nginx/html/</span></span><br><span class="line">            <span class="attr">name:</span> <span class="string">nginx-html</span></span><br><span class="line">      <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx-html</span></span><br><span class="line">        <span class="attr">configMap:</span></span><br><span class="line">          <span class="attr">name:</span> &#123;&#123; <span class="string">.Release.Name</span> &#125;&#125;<span class="string">-cm-index-html</span></span><br><span class="line">          <span class="attr">items:</span>              </span><br><span class="line">          <span class="bullet">-</span> <span class="attr">key:</span> <span class="string">index.html</span></span><br><span class="line">            <span class="attr">path:</span> <span class="string">index.html</span></span><br></pre></td></tr></table></figure><h3 id="【linux】“Manado”-How-much-do-you-press"><a href="#【linux】“Manado”-How-much-do-you-press" class="headerlink" title="【linux】“Manado”: How much do you press?"></a>【linux】<a href="https://sadservers.com/scenario/manado">“Manado”: How much do you press?</a></h3><p><img src="/2024/01/17/sadserver-intro/29.png" alt="题目"></p><h4 id="题意-23"><a href="#题意-23" class="headerlink" title="题意"></a>题意</h4><p>通过本机提供的 gzip、xz、lzip、tar 等工具，将 35147 字节大小的 names 文件压缩成不到 9400 字节，并将压缩文件放到 solution 目录下</p><p>可以在<strong>不删除</strong>任何行的前提下对文件进行修改</p><h4 id="相关指令-24"><a href="#相关指令-24" class="headerlink" title="相关指令"></a>相关指令</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> gzip 压缩和解压</span></span><br><span class="line">gzip -v9 names</span><br><span class="line">gunzip names.gz</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> xz</span></span><br><span class="line">xz names</span><br><span class="line">xz -d names.xz</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> lzip</span></span><br><span class="line">tar --use-compress-program=lbzip2 -cvf names.tar.bz2 names</span><br><span class="line">tar --use-compress-program=lbzip2 -xvf names.tar.bz2</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> lz4</span></span><br><span class="line">lz4 names</span><br><span class="line">lz4 -d names.lz4</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> lzip</span></span><br><span class="line">lzip --best names</span><br><span class="line">lzip -d names.lz</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> lzop</span></span><br><span class="line">lzop -9 names</span><br><span class="line">lzop -d names.lz.lzo</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> zstd</span></span><br><span class="line">zstd -19 names</span><br><span class="line">zstd -d names.zst</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 文件内容排序</span></span><br><span class="line">sort names &gt; names_new</span><br></pre></td></tr></table></figure><h3 id="【docker、golang】“Warsaw”-Prometheus-can’t-scrape-the-webserver"><a href="#【docker、golang】“Warsaw”-Prometheus-can’t-scrape-the-webserver" class="headerlink" title="【docker、golang】“Warsaw”: Prometheus can’t scrape the webserver"></a>【docker、golang】<a href="https://sadservers.com/scenario/warsaw">“Warsaw”: Prometheus can’t scrape the webserver</a></h3><p><img src="/2024/01/17/sadserver-intro/30.png" alt="题目"></p><h4 id="题意-24"><a href="#题意-24" class="headerlink" title="题意"></a>题意</h4><p>app 目录下是一个通过 gorilla/mux 框架搭建的 web 服务，并通过 promhttp 暴露 /metrics 接口</p><p>但是目前直接调用 <a href="http://localhost:9000/metrics">http://localhost:9000/metrics</a> 接口将失败，需要解决</p><h4 id="相关指令-25"><a href="#相关指令-25" class="headerlink" title="相关指令"></a>相关指令</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 调用 metrics 接口</span></span><br><span class="line">curl http://localhost:9000/metrics</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 重启 docker compose 服务</span></span><br><span class="line">docker compose down --volumes</span><br><span class="line">docker compose up -d</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># 重新构建镜像再启动</span></span></span><br><span class="line">docker compose up --build -d</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看 app 的启动逻辑</span></span><br><span class="line">vim app/main.go</span><br></pre></td></tr></table></figure><h3 id="“Moyogalpa”-Security-Snag-The-Trials-of-Mary-and-John"><a href="#“Moyogalpa”-Security-Snag-The-Trials-of-Mary-and-John" class="headerlink" title="“Moyogalpa”: Security Snag. The Trials of Mary and John"></a><a href="https://sadservers.com/scenario/moyogalpa">“Moyogalpa”: Security Snag. The Trials of Mary and John</a></h3><p><img src="/2024/01/17/sadserver-intro/31.png" alt="题目"></p><h4 id="题意-25"><a href="#题意-25" class="headerlink" title="题意"></a>题意</h4><p>本地有一个通过 systemctl 启动的 web 服务，虽然它可以运行但访问其接口会失败，需要修复证书和权限相关的问题，以及防火墙 apparmor 的配置问题</p><p><a href="https://wsxk.github.io/apparmor%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6/">apparmor 的使用方式参考</a></p><h4 id="相关指令-26"><a href="#相关指令-26" class="headerlink" title="相关指令"></a>相关指令</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 查看服务定义</span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># 一个二进制文件，指定了静态文件路径为 /home/webapp/static-files, 证书文件为 /home/webapp/pki/server.crt</span></span></span><br><span class="line">cat /etc/systemd/system/webapp.service</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 重启 webapp</span></span><br><span class="line">systemctl restart webapp</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 解决 webapp 无法 su 的问题: 替换 webapp 的登录 shell</span></span><br><span class="line">vim /etc/passwd</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 手动启动 webapp</span></span><br><span class="line">export APP_STATIC_DIR=/home/webapp/static-files</span><br><span class="line">export APP_CERT=/home/webapp/pki/server.crt</span><br><span class="line">export APP_KEY=/home/webapp/pki/server.pem</span><br><span class="line">su webapp -c &quot;/usr/local/bin/webapp&quot;</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 修复证书权限问题</span></span><br><span class="line">chown -R webapp:webapp /home/webapp/</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 添加 hosts</span></span><br><span class="line">echo &quot;127.0.0.1 webapp&quot; &gt;&gt; /etc/hosts</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 检查指令</span></span><br><span class="line">curl https://webapp:7000/users.html</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 修复 SSL certificate problem: unable to get <span class="built_in">local</span> issuer certificate 的问题</span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># 参考: https://stackoverflow.com/questions/24611640/curl-60-ssl-certificate-problem-unable-to-get-local-issuer-certificate</span></span></span><br><span class="line">cp /home/webapp/pki/CA.crt /usr/local/share/ca-certificates</span><br><span class="line">chmod 644 /usr/local/share/ca-certificates/CA.crt</span><br><span class="line">update-ca-certificates</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 解决 open /home/webapp/static-files/users.html: permission denied 的问题</span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># 在防火墙配置中，添加 /home/webapp/static-files/ r 和 /home/webapp/static-files/* r</span></span></span><br><span class="line">vim /etc/apparmor.d/usr.local.bin.webapp</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># 更新配置到内核中</span></span></span><br><span class="line">apparmor_parser -r /etc/apparmor.d/usr.local.bin.webapp</span><br></pre></td></tr></table></figure><!--[使用 AppArmor 限制容器对资源的访问](https://kubernetes.io/zh-cn/docs/tutorials/security/apparmor/)[AppArmor相关各脚本和服务解析（2）](https://blog.csdn.net/phmatthaus/article/details/130863424)[How do you add a certificate authority (CA) to Ubuntu?](https://superuser.com/questions/437330/how-do-you-add-a-certificate-authority-ca-to-ubuntu)--><h3 id="【postgresql】“Helsingor”-The-first-walls-of-postgres-physical-replication"><a href="#【postgresql】“Helsingor”-The-first-walls-of-postgres-physical-replication" class="headerlink" title="【postgresql】“Helsingør”: The first walls of postgres physical replication"></a>【postgresql】<a href="https://sadservers.com/scenario/helsingor">“Helsingør”: The first walls of postgres physical replication</a></h3><p><img src="/2024/01/17/sadserver-intro/32.png" alt="题目"></p><h4 id="题意-26"><a href="#题意-26" class="headerlink" title="题意"></a>题意</h4><p>本地通过 docker compose 启动了 postgresql，agent/check.sh 也就是检查答案的脚本中，将会先确认备库和主库的同步是否正常。但是目前备库启动失败了，需要找到原因并解决</p><p>扩展: <a href="https://stackoverflow.com/questions/8466223/reuse-a-hash-in-yaml/9197237#9197237">yaml 中复用内容的写法（&amp;）</a></p><h4 id="相关指令-27"><a href="#相关指令-27" class="headerlink" title="相关指令"></a>相关指令</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 查看节点状态</span></span><br><span class="line">docker ps -a</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看日志</span></span><br><span class="line">docker logs 98e1b8d4a341</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 重启 compose</span></span><br><span class="line">docker compose down --volumes</span><br><span class="line">docker compose up -d</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># 强制重建</span></span></span><br><span class="line">docker compose up -d --force-recreate</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 修改配置</span></span><br><span class="line">vim postgres/replica/postgres.conf</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># 批量修复配置</span></span></span><br><span class="line">sed -i &quot;s/max_connections = 80/max_connections = 100/g&quot; postgres/replica/postgres.conf</span><br><span class="line">sed -i &quot;s/max_worker_processes = 4/max_worker_processes = 8/g&quot; postgres/replica/postgres.conf</span><br><span class="line">sed -i &quot;s/max_wal_senders = 5/max_wal_senders = 10/g&quot; postgres/replica/postgres.conf</span><br><span class="line">sed -i &quot;s/max_locks_per_transaction = 32/max_locks_per_transaction = 64/g&quot; postgres/replica/postgres.conf</span><br></pre></td></tr></table></figure><!--# 查看从库数据docker compose exec postgres-db-replica psql -U helsingor -d helsingor -tc "select person_id from users order by person_id desc limit 1;"# docker compose exec postgres-db-master psql -U helsingor -d helsingor -tc "insert into users (first_name, last_name, age, city, os) values ('Will', 'Smith', '55', 'Philadelphia', 'MacOS')"docker compose exec postgres-db-replica psql -U helsingor -d helsingor -tc "select person_id from users order by person_id desc limit 1;"--><h3 id="【WSGI】“Bekasi”-Supervisor-is-still-around"><a href="#【WSGI】“Bekasi”-Supervisor-is-still-around" class="headerlink" title="【WSGI】“Bekasi”: Supervisor is still around"></a>【WSGI】<a href="https://sadservers.com/scenario/bekasi">“Bekasi”: Supervisor is still around</a></h3><p><img src="/2024/01/17/sadserver-intro/33.png" alt="题目"></p><h4 id="题意-27"><a href="#题意-27" class="headerlink" title="题意"></a>题意</h4><p>本地通过 uwsgi 启动了一个 https 服务，但通过 curl -k <a href="https://bekasi/">https://bekasi</a> 调用失败</p><p>本题思路是先确认 uwsgi 的部署方式，再确认如何修改它的部署配置，最后重启</p><h4 id="相关指令-28"><a href="#相关指令-28" class="headerlink" title="相关指令"></a>相关指令</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 调用服务</span></span><br><span class="line">curl -k https://bekasi</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看 uwsgi 进程</span></span><br><span class="line">ps -ef | grep uwsgi</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看后台逻辑</span></span><br><span class="line">cat bekasi/bekasi.py</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># 修改 supervisor 启动 uwsgi 配置</span></span></span><br><span class="line">vim /etc/supervisor/conf.d/uwsgi.conf</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 重载配置并重启服务</span></span><br><span class="line">sudo supervisorctl reload</span><br></pre></td></tr></table></figure><!--cat /etc/supervisor/conf.d/uwsgi.confcat /usr/lib/systemd/system/supervisor.servicesystemctl restart supervisor# vim bekasi/bekasi.inienv             = BEKASI_USER=adminenv             = BEKASI_SERVER=bekasi.sadservers.com# vim /etc/supervisor/conf.d/uwsgi.confenvironment=BEKASI_USER=admin,BEKASI_SERVER=bekasi.sadservers.com# 重启 supervisorsystemctl restart supervisor# 修改 uwsgi 后台服务配置vim bekasi/bekasi.ini# （会被 supervisor 自动拉起）ps -ef | grep "uwsgi" | grep -v grep | awk '{print $2}' | xargs kill -9--><h3 id="【nginx】“Depok”-Nginx-with-Brotli"><a href="#【nginx】“Depok”-Nginx-with-Brotli" class="headerlink" title="【nginx】“Depok”: Nginx with Brotli"></a>【nginx】<a href="https://sadservers.com/scenario/depok">“Depok”: Nginx with Brotli</a></h3><p><img src="/2024/01/17/sadserver-intro/34.png" alt="题目"></p><h4 id="题意-28"><a href="#题意-28" class="headerlink" title="题意"></a>题意</h4><p><a href="https://github.com/google/ngx_brotli">brotli</a> 是 是 Google 在 2015 年 9 月推出的一种压缩算法，使用通用的 LZ77 无损压缩算法、Huffman 编码和二阶上下文建模（2nd order context modelling）的特定组合，旨在进一步提高压缩比</p><p>部署在本地的 nginx 服务目前还不支持 brotli 压缩算法，需要通过 brotli 源码安装插件</p><p>本题主要考察 nginx 插件的安装方法</p><p>参考: <a href="https://juejin.cn/post/7031471867609546759">CentOS 8 安装并加载 Nginx 模组 ngx_brotli 然后启用 brotli 压缩</a></p><p><a href="https://ubuntu.com/server/docs/how-to-use-nginx-modules">How to use nginx modules</a></p><h4 id="相关指令-29"><a href="#相关指令-29" class="headerlink" title="相关指令"></a>相关指令</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 调用 nginx 并指定编码为 br</span></span><br><span class="line">curl -H &quot;Accept-Encoding: br&quot; -I http://localhost</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 编译 brotli 插件</span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># 步骤参考官方仓库 https://github.com/google/ngx_brotli</span></span></span><br><span class="line">cd /home/admin/ngx_brotli/deps/brotli</span><br><span class="line">mkdir out</span><br><span class="line">cd out</span><br><span class="line">cmake -DCMAKE_BUILD_TYPE=Release -DBUILD_SHARED_LIBS=OFF -DCMAKE_C_FLAGS=&quot;-Ofast -m64 -march=native -mtune=native -flto -funroll-loops -ffunction-sections -fdata-sections -Wl,--gc-sections&quot; -DCMAKE_CXX_FLAGS=&quot;-Ofast -m64 -march=native -mtune=native -flto -funroll-loops -ffunction-sections -fdata-sections -Wl,--gc-sections&quot; -DCMAKE_INSTALL_PREFIX=./installed ..</span><br><span class="line">cmake --build . --config Release --target brotlienc</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 重新编译 nginx 并链接 brotli</span></span><br><span class="line">cd /home/admin/nginx</span><br><span class="line">./configure --with-compat --add-dynamic-module=../ngx_brotli</span><br><span class="line">make modules</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 拷贝编译后产生的链接文件</span></span><br><span class="line">cp objs/ngx_http_brotli_filter_module.so /usr/lib/nginx/modules/</span><br><span class="line">cp objs/ngx_http_brotli_static_module.so /usr/lib/nginx/modules/</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 添加</span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># vim /etc/nginx/modules-available/50-ngx-http-brotli.conf</span></span></span><br><span class="line">load_module modules/ngx_http_brotli_filter_module.so;</span><br><span class="line">load_module modules/ngx_http_brotli_static_module.so;</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 开启 brotli 插件</span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># vim /etc/nginx/sites-enabled/default</span></span></span><br><span class="line">server &#123;</span><br><span class="line">brotli on;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 重载 nginx 配置</span></span><br><span class="line">sudo systemctl reload nginx</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 重启 nginx</span></span><br><span class="line">sudo systemctl restart nginx</span><br></pre></td></tr></table></figure><!-- 参考:[http响应Header：Content-Encoding=br怎么办？](https://blog.csdn.net/lrcxl/article/details/128416117)--><h3 id="【linux】“Tukaani”-XZ-LZMA-Library-Compromised"><a href="#【linux】“Tukaani”-XZ-LZMA-Library-Compromised" class="headerlink" title="【linux】“Tukaani”: XZ LZMA Library Compromised"></a>【linux】<a href="https://sadservers.com/scenario/tukaani">“Tukaani”: XZ LZMA Library Compromised</a></h3><p><img src="/2024/01/17/sadserver-intro/35.png" alt="题目"></p><h4 id="题意-29"><a href="#题意-29" class="headerlink" title="题意"></a>题意</h4><p>liblzma 是一个用于数据压缩的库，提供对 LZMA（Lempel-Ziv-Markov chain algorithm）和 XZ 压缩格式的支持</p><p>正常情况下本地服务需要加载的是 /usr/lib/x86_64-linux-gnu/liblzma.so.5.2.5，但通过 sudo lsof | grep liblzma.so.5 可以看到很多进程都加载了 /opt/.trash/liblzma.so.5，需要解决这个问题</p><p>本题主要考察预加载库的设置（LD_PRELOAD）</p><h4 id="相关指令-30"><a href="#相关指令-30" class="headerlink" title="相关指令"></a>相关指令</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 查看 liblzma 相关进程</span></span><br><span class="line">lsof | grep liblzma.so.5</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 删除无效库</span></span><br><span class="line">rm /opt/.trash/liblzma.so.5</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看所有动态链接库之前预加载的库配置</span></span><br><span class="line">vim /etc/ld.so.preload</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 重启节点</span></span><br><span class="line">reboot</span><br></pre></td></tr></table></figure><h2 id="困难"><a href="#困难" class="headerlink" title="困难"></a>困难</h2><p>提醒: 困难的题目似乎登录节点后默认在根目录，需要记得切换到 /home/admin 才能看到题目提供的文件</p><h3 id="【linux】“Jakarta”-it’s-always-DNS"><a href="#【linux】“Jakarta”-it’s-always-DNS" class="headerlink" title="【linux】“Jakarta”: it’s always DNS."></a>【linux】<a href="https://sadservers.com/scenario/jakarta">“Jakarta”: it’s always DNS.</a></h3><p><img src="/2024/01/17/sadserver-intro/36.png" alt="题目"></p><h4 id="题意-30"><a href="#题意-30" class="headerlink" title="题意"></a>题意</h4><p>本机无法 ping 通 google.com，直接 ping 返回的是 Name or service not known，</p><p>本题是以前 sadserver 的实验题，所以虽然放在困难部分，但只要修复 /etc/nsswitch.conf 配置即可解决</p><p><a href="https://www.cnblogs.com/emilyyoucan/articles/8118173.html">参考-Linux系统解析域名的先后顺序files（/etc/hosts）OR dns（/etc/resolv.conf）</a></p><h4 id="相关指令-31"><a href="#相关指令-31" class="headerlink" title="相关指令"></a>相关指令</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 查看并修复域名解析优先级配置</span></span><br><span class="line">vim /etc/nsswitch.conf</span><br><span class="line">sed -i &quot;s/hosts:.*/hosts:          files dns/g&quot; /etc/nsswitch.conf</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 检查指令</span></span><br><span class="line">ping google.com</span><br></pre></td></tr></table></figure><h3 id="【wordpress、docker】“Bern”-Docker-web-container-can’t-connect-to-db-container"><a href="#【wordpress、docker】“Bern”-Docker-web-container-can’t-connect-to-db-container" class="headerlink" title="【wordpress、docker】“Bern”: Docker web container can’t connect to db container."></a>【wordpress、docker】<a href="https://sadservers.com/scenario/bern">“Bern”: Docker web container can’t connect to db container.</a></h3><p><img src="/2024/01/17/sadserver-intro/37.png" alt="题目"></p><h4 id="题意-31"><a href="#题意-31" class="headerlink" title="题意"></a>题意</h4><p>本地通过 docker 启动了 <a href="https://wordpress.com/zh-cn">wordpress</a> 和 mariadb 两个容器，mariadb 数据库状态正常，但 wordpress 服务无法访问 mariadb，需要解决这个问题</p><h4 id="相关指令-32"><a href="#相关指令-32" class="headerlink" title="相关指令"></a>相关指令</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 查看 wordpress 接口返回结果</span></span><br><span class="line">curl -s localhost:80 |tail -4</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 检查 wordpress 容器访问域名 <span class="string">&quot;mysql&quot;</span> 的结果</span></span><br><span class="line">docker exec wordpress mysqladmin -h mysql -u root -ppassword --connect-timeout 2 ping</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看 wordpress 容器的详细信息（ 主要看环境变量 Env ）</span></span><br><span class="line">docker inspect 6ffb084b515c</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看 wordpress 容器中设置的连接数据库相关的环境变量</span></span><br><span class="line">docker exec wordpress env | grep WORDPRESS_DB_</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看 wordpress 配置文件中，和连接数据库相关的环境变量</span></span><br><span class="line">grep WORDPRESS_DB_ /home/admin/html/wp-config.php</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 删除容器</span></span><br><span class="line">docker rm 6ffb084b515c</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 启动新的 设置了域名映射的 wordpress 容器</span></span><br><span class="line">docker run -it -p 80:80 -e WORDPRESS_DB_PASSWORD=password -e WORDPRESS_DB_USER=root --add-host mysql:172.17.0.1 --name wordpress -d wordpress:sad</span><br></pre></td></tr></table></figure><!--# 查看重启脚本cat /usr/local/bin/docker-entrypoint.sh# 重启 wordpressps -ef | grep 'apache2' | grep -v grep | awk '{print $2}' | xargs --no-run-if-empty kill -9/usr/local/bin/docker-entrypoint.sh apache2-foreground# 设置 wordpress 数据库配置相关的环境变量## export WORDPRESS_DB_PASSWORD=password## export WORDPRESS_DB_USER=rootexport WORDPRESS_DB_HOST=172.17.0.1(容器连接宿主机的地址)# 修改 wordpress 配置文件vim ./wp-config.php## 172.17.0.1: 容器连接宿主机的地址## sed -i "s/'WORDPRESS_DB_HOST', 'mysql'/'WORDPRESS_DB_HOST', '172.17.0.1'/g" wp-config.php# hosts 中设置域名和ip映射echo "172.17.0.1 mysql" >> /etc/hosts# 重启容器docker restart 6ffb084b515c--><h3 id="【推荐】【linux】“Karakorum”-WTFIT-–-What-The-Fun-Is-This"><a href="#【推荐】【linux】“Karakorum”-WTFIT-–-What-The-Fun-Is-This" class="headerlink" title="【推荐】【linux】“Karakorum”: WTFIT – What The Fun Is This?"></a>【推荐】【linux】<a href="https://sadservers.com/scenario/karakorum">“Karakorum”: WTFIT – What The Fun Is This?</a></h3><p><img src="/2024/01/17/sadserver-intro/38.png" alt="题目"></p><h4 id="题意-32"><a href="#题意-32" class="headerlink" title="题意"></a>题意</h4><p>/home/admin/wtfit 文件是一个需要连接某个地址才能启动的服务。但首先它因为没有可执行权限而无法执行，其次它实际执行也有报错，需要给它添加可执行权限，并解决运行文件使得其能够正常启动</p><h4 id="相关指令-33"><a href="#相关指令-33" class="headerlink" title="相关指令"></a>相关指令</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> chmod 添加可执行权限</span></span><br><span class="line">chmod +x /home/admin/wtfit</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 通过 perl 脚本调用 chmod</span></span><br><span class="line">perl -e &#x27;chmod 0755, &quot;/usr/bin/chmod&quot;&#x27;</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 通过 ld-linux （动态链接器） 调用 chmod</span></span><br><span class="line">/lib64/ld-linux-x86-64.so.2 /usr/bin/chmod +x /usr/bin/chmod</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 执行二进制文件，并跟踪进程堆栈</span></span><br><span class="line">strace /home/admin/wtfit</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 通过 python 快速启动一个监听端口 7777 http 服务端</span></span><br><span class="line">python3 -m http.server 7777 &amp;</span><br></pre></td></tr></table></figure><h3 id="【kubernetes】“Singara”-Docker-and-Kubernetes-web-app-not-working"><a href="#【kubernetes】“Singara”-Docker-and-Kubernetes-web-app-not-working" class="headerlink" title="【kubernetes】“Singara”: Docker and Kubernetes web app not working."></a>【kubernetes】<a href="https://sadservers.com/scenario/singara">“Singara”: Docker and Kubernetes web app not working.</a></h3><p><img src="/2024/01/17/sadserver-intro/39.png" alt="题目"></p><h4 id="题意-33"><a href="#题意-33" class="headerlink" title="题意"></a>题意</h4><p>本地通过 <a href="https://github.com/k3s-io/k3s">k3s</a> 启动了一个轻量级 kubernetes 集群，并在 /home/admin/deployment.yml 中定义了 webapp 这个 web 服务，但是容器启动有问题，通过 curl -i localhost:8888 无法调通，需要解决</p><h4 id="相关指令-34"><a href="#相关指令-34" class="headerlink" title="相关指令"></a>相关指令</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 获取所有 pod</span></span><br><span class="line">kubectl get pod -A</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 获取 pod 的描述信息</span></span><br><span class="line">kubectl describe pod webapp-deployment-666b67994b-5sffz -n web</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 启动 register 镜像仓库</span></span><br><span class="line">docker run -d -p 5000:5000 registry:2</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 提交镜像 webapp 到本地镜像仓库</span></span><br><span class="line">docker tag webapp localhost:5000/webapp</span><br><span class="line">docker push localhost:5000/webapp</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 修改 deployment 并重新启动</span></span><br><span class="line">kubectl delete deployment webapp-deployment -n web</span><br><span class="line">vim /home/admin/deployment.yml</span><br><span class="line">kubectl apply -f /home/admin/deployment.yml</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 开放端口</span></span><br><span class="line">kubectl port-forward deployments/webapp-deployment 8888 -n web &amp; </span><br></pre></td></tr></table></figure><h3 id="【postgresql】“Hong-Kong”-can’t-write-data-into-database"><a href="#【postgresql】“Hong-Kong”-can’t-write-data-into-database" class="headerlink" title="【postgresql】“Hong-Kong”: can’t write data into database."></a>【postgresql】<a href="https://sadservers.com/scenario/hongkong">“Hong-Kong”: can’t write data into database.</a></h3><p><img src="/2024/01/17/sadserver-intro/40.png" alt="题目"></p><h4 id="题意-34"><a href="#题意-34" class="headerlink" title="题意"></a>题意</h4><p>本地启动了 postgresql 但无法正常连接和插入数据，需要从 pg 的存储目录配置去分析原因</p><h4 id="相关指令-35"><a href="#相关指令-35" class="headerlink" title="相关指令"></a>相关指令</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 检查指令: 向 pg 中插入一条数据</span></span><br><span class="line">sudo -u postgres psql -c &quot;insert into persons(name) values (&#x27;jane smith&#x27;);&quot; -d dt</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 手动启动 pg server 并确认报错</span></span><br><span class="line">pg_ctlcluster 14 main restart -m fast</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看配置中的存储目录</span></span><br><span class="line">cat /etc/postgresql/14/main/postgresql.conf | grep data_directory</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 创建数据目录并初始化</span></span><br><span class="line">mkdir -p /opt/pgdata</span><br><span class="line">chown -R postgres:postgres /opt/pgdata</span><br><span class="line">su postgres -c &quot;/usr/lib/postgresql/14/bin/initdb -D /opt/pgdata/main&quot;</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 重启 pgsql</span></span><br><span class="line">systemctl restart postgresql</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 从日志确认启动启动是否正常</span></span><br><span class="line">tail -f /var/log/postgresql/postgresql-14-main.log</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 创建库表</span></span><br><span class="line">sudo -u postgres psql -c &quot;create database dt&quot;</span><br><span class="line">sudo -u postgres psql -c &quot;CREATE TABLE persons(name varchar(100))&quot; -d dt</span><br></pre></td></tr></table></figure><h3 id="【推荐】【linux】“Pokhara”-SSH-and-other-sshenanigans"><a href="#【推荐】【linux】“Pokhara”-SSH-and-other-sshenanigans" class="headerlink" title="【推荐】【linux】“Pokhara”: SSH and other sshenanigans"></a>【推荐】【linux】<a href="https://sadservers.com/scenario/pokhara">“Pokhara”: SSH and other sshenanigans</a></h3><p><img src="/2024/01/17/sadserver-intro/41.png" alt="题目"></p><h4 id="题意-35"><a href="#题意-35" class="headerlink" title="题意"></a>题意</h4><p>本机启动了 sshd，且 client 用户下已经设置了 ssh key ， 期望是可以通过 ssh client@localhost 免密访问本机，但是目前会失败，找到账号和 ssh 相关的问题并解决</p><p>注: /home/client/.ssh/authorized_keys 中已经添加了公钥</p><p>本题涉及面很广，包括 ssh 配置、linux 用户配置、用户可用系统资源配置等，但整体都是围绕 su client 和 ssh client@localhost 失败来解决的，建议实际解题时，通过这两个指令执行的报错一步步解决</p><h4 id="相关指令-36"><a href="#相关指令-36" class="headerlink" title="相关指令"></a>相关指令</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 切换 client 用户</span></span><br><span class="line">su client</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 解决 <span class="string">&quot;Your account has expired; please contact your system administrator.&quot;</span> 问题</span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># 查看 client 用户的过期时间</span></span></span><br><span class="line">chage -l client</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># 设置 client 用户过期时间</span></span></span><br><span class="line">chage -E 2024-12-31 client</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 解决 <span class="string">&quot;su: failed to execute /usr/sbin/nologin: Resource temporarily unavailable&quot;</span> 问题</span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># 查看用户登录信息 （登录脚本）</span></span></span><br><span class="line">lslogins client</span><br><span class="line"><span class="meta">#</span><span class="bash"> 或: cat /etc/passwd | grep client</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 设置用户登录 shell 为 /bin/bash</span></span><br><span class="line">usermod --shell /bin/bash client</span><br><span class="line"><span class="meta">#</span><span class="bash"> 或: sed -i <span class="string">&quot;s#/home/client:/usr/sbin/nologin#/home/client:/bin/bash#g&quot;</span> /etc/passwd</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 检查指令: ssh 到 client 用户并执行 <span class="built_in">pwd</span></span></span><br><span class="line">ssh -v client@localhost &quot;pwd&quot;</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># 解决 &quot;su: failed to execute /usr/sbin/nologin: Resource temporarily unavailable&quot; 问题</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># https://access.redhat.com/solutions/30316</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># 查看文件描述符配置 （需要修改）</span></span></span><br><span class="line">vim /etc/security/limits.conf</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 解决 ssh client 问题</span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># https://askubuntu.com/a/343217</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># root 用户下生成ssh密钥对，并把公钥写入 client 的 authorized_keys 中</span></span></span><br><span class="line">ssh-keygen</span><br><span class="line">cat ~/.ssh/id_rsa.pub &gt;&gt; /home/client/.ssh/authorized_keys</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># 清空 known_hosts</span></span></span><br><span class="line">echo &quot;&quot; &gt; /home/client/.ssh/known_hosts</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 修正私钥文件权限</span></span><br><span class="line">chmod 600 /home/client/.ssh/*</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 删除 ssh 错误配置并重启 sshd</span></span><br><span class="line">rm /etc/ssh/sshd_config.d/sad.conf</span><br><span class="line">systemctl restart sshd</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 最后，切回 admin 用户并执行 ssh，使得 known hosts 被刷新</span></span><br><span class="line">sudo -u client ssh client@localhost &#x27;pwd&#x27;</span><br></pre></td></tr></table></figure><h3 id="【linux】“Roseau”-Hack-a-Web-Server"><a href="#【linux】“Roseau”-Hack-a-Web-Server" class="headerlink" title="【linux】“Roseau”: Hack a Web Server"></a>【linux】<a href="https://sadservers.com/scenario/roseau">“Roseau”: Hack a Web Server</a></h3><p><img src="/2024/01/17/sadserver-intro/42.png" alt="题目"></p><h4 id="题意-36"><a href="#题意-36" class="headerlink" title="题意"></a>题意</h4><p>在本机的 apache web 服务器上存有一个密码文件，通过 zip 方式加密压缩。这个压缩文件通过 admin 用户无法直接访问，需要调用 apache 接口拿到，然而 apache 接口也是需要密码（配置: AuthUserFile）。因此需要通过密码破解工具 john 分别破解 apache 的密码 以及 压缩文件</p><p>本题主要是介绍暴力破解工具 <a href="https://github.com/openwall/john">john</a> 的使用。它的原理简单来说是通过 预先准备的词典、哈希字典，对特定加密方式进行特定的暴力破解</p><p><a href="https://zhuanlan.zhihu.com/p/395718068">参考-使用John the ripper破解密码</a></p><h4 id="相关指令-37"><a href="#相关指令-37" class="headerlink" title="相关指令"></a>相关指令</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 查看 httpd 配置，包括根路径和认证方式</span></span><br><span class="line">cat /etc/apache2/sites-enabled/000-default.conf</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看 apache 根路径下的压缩文件</span></span><br><span class="line">ls -l /var/www/html</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 破解 httpd 密码</span></span><br><span class="line">/home/admin/john/run/john /etc/apache2/.htpasswd</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 下载 webfile 文件</span></span><br><span class="line">curl localhost/webfile -u &quot;carlos:(这里替换成httpd密码)&quot; --output secret</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 解密 secret （格式: zip） 密码</span></span><br><span class="line">/home/admin/john/run/zip2john secret &gt; zip.hash</span><br><span class="line">/home/admin/john/run/john zip.hash</span><br></pre></td></tr></table></figure><!--curl localhost/webfile -u "carlos:chalet" --output secretunzip -p andes--><h3 id="【java、linux】“Belo-Horizonte”-A-Java-Enigma"><a href="#【java、linux】“Belo-Horizonte”-A-Java-Enigma" class="headerlink" title="【java、linux】“Belo-Horizonte”: A Java Enigma"></a>【java、linux】<a href="https://sadservers.com/scenario/belo-horizonte">“Belo-Horizonte”: A Java Enigma</a></h3><p><img src="/2024/01/17/sadserver-intro/43.png" alt="题目"></p><h4 id="题意-37"><a href="#题意-37" class="headerlink" title="题意"></a>题意</h4><p>Sad.class 是一段 java 程序，成功执行后，会打印一段题目需要的密码，但它目前是无法执行的，需要通过反编译等方法解决</p><p><a href="https://blog.csdn.net/yu20190429/article/details/109050769">参考: 使用fallocate命令创建swap分区</a></p><h4 id="相关指令-38"><a href="#相关指令-38" class="headerlink" title="相关指令"></a>相关指令</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 运行 class</span></span><br><span class="line">java Sad.class</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看 /usr/bin/java 指向的实际的文件</span></span><br><span class="line">readlink -f /usr/bin/java</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看本机安装的其他版本 java</span></span><br><span class="line">ls -l /usr/lib/jvm | grep java</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 将 /usr/bin/java 指向新的地址</span></span><br><span class="line">sudo rm /usr/bin/java</span><br><span class="line">sudo ln -s /usr/lib/jvm/java-1.17.0-openjdk-amd64/bin/java /usr/bin/java</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 反编译 Sad.class</span></span><br><span class="line">javap -c -l Sad.class</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 重命名</span></span><br><span class="line">mv Sad.class VerySad.class</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看本地内存（总剩余内存只有 200m 左右，不足以运行进程）</span></span><br><span class="line">free -m</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看本地磁盘（可以看到至少有4G空间）</span></span><br><span class="line">df -h</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 以本地磁盘申请交换空间</span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># 申请1G空间</span></span></span><br><span class="line">sudo fallocate -l 1G /swapfile</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># 设置文件权限为600</span></span></span><br><span class="line">sudo chmod 600 /swapfile</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># 将文件设置为交换空间</span></span></span><br><span class="line">sudo mkswap /swapfile</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># 启用交换文件</span></span></span><br><span class="line">sudo swapon /swapfile</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># 查看交换空间</span></span></span><br><span class="line">sudo swapon --show</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># 再次查看内存</span></span></span><br><span class="line">free -m</span><br></pre></td></tr></table></figure><h3 id="【rabbitmq、docker】“Chennai”-Pull-a-Rabbit-from-a-Hat"><a href="#【rabbitmq、docker】“Chennai”-Pull-a-Rabbit-from-a-Hat" class="headerlink" title="【rabbitmq、docker】“Chennai”: Pull a Rabbit from a Hat"></a>【rabbitmq、docker】<a href="https://sadservers.com/scenario/chennai">“Chennai”: Pull a Rabbit from a Hat</a></h3><p><img src="/2024/01/17/sadserver-intro/44.png" alt="题目"></p><h4 id="题意-38"><a href="#题意-38" class="headerlink" title="题意"></a>题意</h4><p>在本地的 rabbitmq-cluster-docker-master 目录下，提供了启动 rabbitmq 三节点集群的 compose 仓库（参考这个 <a href="https://github.com/serkodev/rabbitmq-cluster-docker">serkodev/rabbitmq-cluster-docker</a> ），需要正常启动集群，并先后运行 <code>python3 ~/producer.py hello-lwc</code> 和 <code>python3 ~/consumer.py</code>，完成一个完整的生产和消费过程</p><p>注意: 虽然 consumer.py 和 producer.py 中确实有一些连接参数不太一致，但题目要求不能修改这两个代码文件，否则校验答案会失败，因此只能通过设置环境变量的方式来解决</p><h4 id="相关指令-39"><a href="#相关指令-39" class="headerlink" title="相关指令"></a>相关指令</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 重启 rabbitmq 集群</span></span><br><span class="line">docker compose down --volumes</span><br><span class="line">docker compose up -d</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 修改启动脚本最后一段，tail 之前创建一个空日志文件，解决 tail 执行失败导致卡住的问题</span></span><br><span class="line">touch /var/log/rabbitmq/empty.log</span><br><span class="line">vim cluster-entrypoint.sh</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看 .env 文件（ compose 默认使用的环境变量 ），并将其修改为 consumer.py 中写死的用户名和密码</span></span><br><span class="line">cat ./.env</span><br><span class="line">export RABBITMQ_DEFAULT_USER=username</span><br><span class="line">export RABBITMQ_DEFAULT_PASS=password</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 设置环境变量并触发生产者</span></span><br><span class="line">export RMQ_QUEUE=hello</span><br><span class="line">export RMQ_USER=username</span><br><span class="line">export RMQ_PASSWORD=password</span><br><span class="line">python3 ~/producer.py hello-lwc</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 触发消费者</span></span><br><span class="line">python3 ~/consumer.py</span><br></pre></td></tr></table></figure><!--# 添加用户docker exec rabbitmq-cluster-docker-master-rabbitmq1-1 rabbitmqctl add_user username passworddocker exec rabbitmq-cluster-docker-master-rabbitmq1-1 rabbitmqctl set_permissions -p / username ".*" ".*" ".*"docker exec rabbitmq-cluster-docker-master-rabbitmq1-1 ls -l /var/log/rabbitmq/docker exec rabbitmq-cluster-docker-master-rabbitmq1-1 find / -name 'rabbitmq.conf'log.dir = /var/log/rabbitmq--><h3 id="【git、linux】“Monaco”-Disappearing-Trick"><a href="#【git、linux】“Monaco”-Disappearing-Trick" class="headerlink" title="【git、linux】“Monaco”: Disappearing Trick"></a>【git、linux】<a href="https://sadservers.com/scenario/monaco">“Monaco”: Disappearing Trick</a></h3><p><img src="/2024/01/17/sadserver-intro/45.png" alt="题目"></p><h4 id="题意-39"><a href="#题意-39" class="headerlink" title="题意"></a>题意</h4><p>本地 5000 端口上启动了一个 web 服务，通过 post 方法指定密码调用它的接口后，会返回一个密钥，需要把这个密钥写入 mysolution 文件中</p><p>根据提示，当前路径是一个代码工作路径，“那么”（虽然感觉这个推理有点牵强）可以推测是一个 git 路径，但是本地并没有代码，可以通过 git 指令恢复 webserver 的代码，确认其需要的密码是在哪个环境变量中定义的，并在已启动的 webserver 进程中，找到对应的环境变量</p><h4 id="相关指令-40"><a href="#相关指令-40" class="headerlink" title="相关指令"></a>相关指令</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 恢复 git 项目（即：重新拉取代码）</span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># 显示目前文件差异</span></span></span><br><span class="line">git status</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># 恢复指定文件</span></span></span><br><span class="line">git restore webserver_v1.py</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># 或: 恢复当前路径下的所有文件</span></span></span><br><span class="line">git restore .</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看 webserver 逻辑</span></span><br><span class="line">cat webserver_v1.py</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查找 webserver_v1.py 配置的密码相关的环境变量，在已启动的 webserver 服务中定义的值</span></span><br><span class="line">ps -ef | grep webserver.py | grep -v grep | awk &#x27;&#123;print $2&#125;&#x27; | xargs -I &#123;&#125; bash -c &quot;cat /proc/&#123;&#125;/environ&quot; | tr &#x27;\000&#x27; &#x27;\n&#x27; | grep &quot;(环境变量名)&quot;</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 访问 webserver 并指定密码，并将得到的 secret 写入 mysolution 文件中</span></span><br><span class="line">secret=`curl -X POST localhost:5000 --data-raw &quot;password=(上一步得到的密码)&quot; | sed &#x27;s/.* //g&#x27;`</span><br><span class="line">echo &quot;$secret&quot; &gt; ~/mysolution</span><br></pre></td></tr></table></figure><h3 id="【docker】“Florence”-Database-Migration-Hell"><a href="#【docker】“Florence”-Database-Migration-Hell" class="headerlink" title="【docker】“Florence”: Database Migration Hell"></a>【docker】<a href="https://sadservers.com/scenario/florence">“Florence”: Database Migration Hell</a></h3><p><img src="/2024/01/17/sadserver-intro/46.png" alt="题目"></p><h4 id="题意-40"><a href="#题意-40" class="headerlink" title="题意"></a>题意</h4><p>/home/admin/app/docker-compose.yml 中定义了一个 nginx + nodejs + postgresql 的后台服务，其中 pgsql 作为数据库；api 服务进行数据库访问用户的初始化，以及提供接口；api_aggregator 对 pgsql 进行访问权限验证；nginx 服务提供代理和 https 接口。正常的启动和初始化顺序为: pgsql -&gt; d</p><p>现在这些服务的启动和访问有问题，需要解决</p><h4 id="相关指令-41"><a href="#相关指令-41" class="headerlink" title="相关指令"></a>相关指令</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 查看 compose 定义</span></span><br><span class="line">cat ~/app/docker-compose.yml</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看并修改 postgresql Dockerfile，以解决 postgresql 容器日志中的 <span class="string">&quot;initdb: cannot be run as root&quot;</span> 问题</span></span><br><span class="line">vim ~/app/postgresql/Dockerfile</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 重启容器并重新构建镜像</span></span><br><span class="line">docker compose down --volumes</span><br><span class="line">docker compose up --build -d</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 添加 解决 api_aggregator 连接 pg 失败的问题</span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># 第14行添加内容</span></span></span><br><span class="line">sed -i &quot;14iecho \&quot;host all api_aggregator 0.0.0.0/0 md5\&quot; &gt;&gt; /var/lib/postgresql/data/pg_hba.conf&quot; ~/app/postgresql/entrypoint.sh</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 解决 api_aggregator 容器日志提示连接 pgsql 失败问题</span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># 查看 app 服务启动时对 pgsql 的 migrations 逻辑(go-pg/migrations.NewCollection.DiscoverSQLMigrations</span></span></span><br><span class="line">cat ~/app/api/pkg/db/db.go</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># 查看 api_aggregator 服务所用的账号和密码</span></span></span><br><span class="line">cat ~/app/docker-compose.yml | grep DATABASE_URL</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># 计算密码的 md5 值</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># 注意计算方式: 密码和用户名一起计算，参考源码 https://github.com/postgres/postgres/blob/REL_17_STABLE/src/interfaces/libpq/fe-auth.c#L732</span></span></span><br><span class="line">echo -n (上一步得到的密码)(上一步得到的用户名) | md5sum | awk &#x27;&#123;print $1&#125;&#x27;</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># 创建 api_aggregator 访问需要的用户</span></span></span><br><span class="line">sed -i &quot;s/CREATE ROLE api_aggregator .*/CREATE ROLE api_aggregator LOGIN PASSWORD &#x27;(上一步计算得到的md5值)&#x27;;/g&quot; ~/app/api/migrations/1_users.up.sql</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># api 服务中添加适当 sleep ，防止执行 migration 时 pgsql 还未启动导致报错</span></span></span><br><span class="line">sed -i &quot;10i\&quot;time\&quot;&quot; ~/app/api/server.go</span><br><span class="line">sed -i &quot;14itime.Sleep(10 * time.Second)&quot; ~/app/api/server.go</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># api_aggregator 服务中添加适当 sleep，原因同上</span></span></span><br><span class="line">sed -i &quot;s#CMD node.*#CMD sleep 10; node /usr/src/app/index.js#g&quot; ~/app/api_aggregator/Dockerfile</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># 注: 截止到这一步，重启容器后4个容器应该状态都是正常的了</span></span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 将 sadserver.local 域名映射到本地(<span class="keyword">for</span> nginx)</span></span><br><span class="line">echo &quot;127.0.0.1 sadserver.local&quot; &gt;&gt; /etc/hosts</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 重新生成证书，解决证书过期问题: curl: (60) SSL certificate problem: certificate has expired</span></span><br><span class="line">openssl req -x509 -nodes -days 365 -newkey rsa:2048 -keyout /etc/nginx/certs/sadserver.key -out /etc/nginx/certs/sadserver.crt -subj &quot;/C=CN/ST=SZ/L=NS/O=Internet/OU=Company/CN=sadserver.local&quot;</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 重启 nginx</span></span><br><span class="line">systemctl restart nginx</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 验证接口访问</span></span><br><span class="line">curl --cacert /etc/nginx/certs/sadserver.crt https://sadserver.local</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>最近看了IT狂人这部剧，刚好想到，IT人平时的工作可能很杂，这里搞一点开发，那里做一点运维，甚至还没有程序那样有逻辑，但从外面来看，IT人确实是在做很多事情的，只是他们好像在一个锁上的礼物盒那样，不打开就不知道里面有什么</p><p>这部剧，和 sadserver 这个解题平台，都像是打开这个盒子的钥匙</p><!--整理完题目之余，就以一首适合夜晚的歌曲作为结束吧《little girl》--><!--不是所有 linux 指令都能经常用到，但没有一个指令是没有用的--><!--作者温馨提醒: 做完一道题之后最好及时关闭服务器，可以帮他省钱<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo shutdown -h now</span><br></pre></td></tr></table></figure><p>更新: 现在做完一道题后，只要 check 通过了，会自动关闭服务器。。</p><p>–&gt;</p><!------ 当前: 后续将这篇文章在 推 发，@ 一下，有点意思。。。有机会翻译成英文maybe I can translate it to english, when i am free...--><!--今天的听会歌: 此刻写本文在听的歌，也是身边枪迷给我的礼物--><!--后续发现的新题目: https://sadservers.com/scenario/luc-->]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> 操作系统 </tag>
            
            <tag> life </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>互联网之100问</title>
      <link href="/2023/12/06/program-100-qas/"/>
      <url>/2023/12/06/program-100-qas/</url>
      
        <content type="html"><![CDATA[<p><a href="https://mp.weixin.qq.com/s/xGI0vGgaZhY0T9BS64U60A">本文公众号</a></p><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>最近看了一个娱乐节目，一位歌手接受主持人的100个问题采访。快问快答的模式，很快就看完了，大部分问题也都比较平常，感觉换作其他行业的人来回答也会很有意思</p><p>但是跳出娱乐圈，这种节目似乎在普通人身上看得很少，各行各业的打工人，考虑升学或求职的应届生，面临升学压力的初高中生，都有自己的压力</p><p>作为深处互联网行业的一份子，又是临近年底，我也深深感觉工作节奏一点都停不下来。而我们这行，总是在工作需求和学习充电中疲于奔波，给自己按下暂停键已经成了一种奢侈。我还能在工作之余接受这样的采访，之前是想都不敢想的</p><p>而就在一个再平常不过的周五，突然冒出的想法：既然没有节目，没有主持人，那就自己当这个主持人呗。工作稍微停一停，头脑风暴个100个问题出来，再转换角色，以放松的心情来回答这些问题，看看我现在在做什么，周围的人在做什么，平时又有什么有趣的事情之类的</p><p>这样的自问自答，好像也能很有趣，这就是本文的来源了</p><h2 id="工作"><a href="#工作" class="headerlink" title="工作"></a>工作</h2><h3 id="平时工作内容是什么"><a href="#平时工作内容是什么" class="headerlink" title="平时工作内容是什么"></a>平时工作内容是什么</h3><p>固定事情: 接老板派的活，tapd 上写写方案，动手写代码，本地做单元测试，登录容器平台发布<br>每周事项: 开周会，需求排期会，检查服务的监控情况<br>空闲时候: 设计、开发自己想做的项目</p><h3 id="工作节奏是什么样的"><a href="#工作节奏是什么样的" class="headerlink" title="工作节奏是什么样的"></a>工作节奏是什么样的</h3><p>最忙的时候根本停不下来，开不完的会，写不完的需求，回复不完的问题<br>可能两周左右才能有一天可以稍微划划水，但是开源社区不会划水，总有新东西等着去学</p><h3 id="手头的事真的做得完吗"><a href="#手头的事真的做得完吗" class="headerlink" title="手头的事真的做得完吗"></a>手头的事真的做得完吗</h3><p>当然做不完，手机的待办事项已经很久没看了。还有一堆书看不完，一堆语言新特性看不完，时不时就觉得自己是个fw</p><h3 id="年度目标一般能完成多少"><a href="#年度目标一般能完成多少" class="headerlink" title="年度目标一般能完成多少"></a>年度目标一般能完成多少</h3><p>正常的部分80%，吹牛的部分20%</p><h3 id="工作用的聊天软件是什么"><a href="#工作用的聊天软件是什么" class="headerlink" title="工作用的聊天软件是什么"></a>工作用的聊天软件是什么</h3><p>企业微信</p><h3 id="聊天置顶的都是哪些群"><a href="#聊天置顶的都是哪些群" class="headerlink" title="聊天置顶的都是哪些群"></a>聊天置顶的都是哪些群</h3><p>生产环境告警群。。</p><h3 id="工作中会接触到哪些角色"><a href="#工作中会接触到哪些角色" class="headerlink" title="工作中会接触到哪些角色"></a>工作中会接触到哪些角色</h3><p>老板（主管、组长，PL）、产品经理（PM）、其他开发小伙伴、测试、运维、安全</p><h3 id="哪个角色最好相处"><a href="#哪个角色最好相处" class="headerlink" title="哪个角色最好相处"></a>哪个角色最好相处</h3><p>测试，因为现在自己就是测试</p><h3 id="工作上最讨厌的事项是什么"><a href="#工作上最讨厌的事项是什么" class="headerlink" title="工作上最讨厌的事项是什么"></a>工作上最讨厌的事项是什么</h3><p>开一个小时的会议，自己发言只要5分钟，其他事情完全没关系</p><p>本来简简单单通过文档就能沟通清楚的事情，却要浪费大家的时间</p><h3 id="最难搞定的需求是什么样的"><a href="#最难搞定的需求是什么样的" class="headerlink" title="最难搞定的需求是什么样的"></a>最难搞定的需求是什么样的</h3><p>上层调用我服务的同事: 诶，这个接口加个参数透传过来，赶紧点，今晚就要。什么？你这个参数也要从别的地方来吗？我不管，你怎么写是你的事，我只管要数据，你赶紧搞别摸鱼了</p><p>（好像也不一定最难搞定，但是一定最浪费心情）</p><h3 id="见过的最复杂的系统"><a href="#见过的最复杂的系统" class="headerlink" title="见过的最复杂的系统"></a>见过的最复杂的系统</h3><p>需要10个人以上维护，而且没人说得清系统整体架构</p><p>最后大概率逃不了被新系统替换的命运</p><h3 id="什么事很重要，但又很容易忽略的"><a href="#什么事很重要，但又很容易忽略的" class="headerlink" title="什么事很重要，但又很容易忽略的"></a>什么事很重要，但又很容易忽略的</h3><p>代码检视</p><h3 id="一年大概写多少代码"><a href="#一年大概写多少代码" class="headerlink" title="一年大概写多少代码"></a>一年大概写多少代码</h3><p>去年写得不算多，甚至大部分还是提交到 github 的，大概就3w</p><p>但对大厂人来说，一年写个 8-10w 还是很正常（平均一天400行，很可观了）</p><h3 id="一天写多少行代码"><a href="#一天写多少行代码" class="headerlink" title="一天写多少行代码"></a>一天写多少行代码</h3><p>状态好的话一天写个1k行，开发一个小功能，开会和杂事多的时候也可能一行都写不了</p><h3 id="理想的工作环境"><a href="#理想的工作环境" class="headerlink" title="理想的工作环境"></a>理想的工作环境</h3><p>一张床，一个桌，一台 mac，窗外面向海风，屋后花园种菜，快慢生活的完美结合，无敌</p><h3 id="现在的工作环境"><a href="#现在的工作环境" class="headerlink" title="现在的工作环境"></a>现在的工作环境</h3><p>网吧位</p><p>看起来比网吧环境好，但公司配的电脑可比网吧差得远了</p><h3 id="推荐的学习和工作方法"><a href="#推荐的学习和工作方法" class="headerlink" title="推荐的学习和工作方法"></a>推荐的学习和工作方法</h3><p>三件套: 番茄钟 + 免打扰模式 + todo list</p><h3 id="你的工作签名是什么"><a href="#你的工作签名是什么" class="headerlink" title="你的工作签名是什么"></a>你的工作签名是什么</h3><p>“10:00-16:00 专心编程，请勿打扰”（ 然而现实情况是，稍微晚回信息，用户一个电话就打过来了 :) ）</p><h2 id="日常"><a href="#日常" class="headerlink" title="日常"></a>日常</h2><h3 id="除了程序员，想个词形容自己"><a href="#除了程序员，想个词形容自己" class="headerlink" title="除了程序员，想个词形容自己"></a>除了程序员，想个词形容自己</h3><p>代码的搬运工，简称搬砖的，哪个工地有活就去哪里搬砖，没项目了也就没饭吃了</p><h3 id="看到自己写的服务有-bug-第一反应是什么"><a href="#看到自己写的服务有-bug-第一反应是什么" class="headerlink" title="看到自己写的服务有 bug 第一反应是什么"></a>看到自己写的服务有 bug 第一反应是什么</h3><p>先别急，都在我的控制范围之中</p><h3 id="一天的工作状态变化"><a href="#一天的工作状态变化" class="headerlink" title="一天的工作状态变化"></a>一天的工作状态变化</h3><p>上午: 9点半多到公司，写点代码找找状态，差不多就该吃饭了，算是一天中最轻松的时候<br>下午: 2-4点状态最佳，赶紧多写点代码，中间被用户找，能推就往后推点<br>4-6点: 这段时间专门做杂事，疲惫感逐渐起来<br>而这时候一旦来个线上问题，或是和同事讨论方案有分歧，心情确实是容易爆炸<br>晚上: 加班的话，人可能还在敲键盘，意识早已在九霄云外了</p><h3 id="一天下来全身最累的地方"><a href="#一天下来全身最累的地方" class="headerlink" title="一天下来全身最累的地方"></a>一天下来全身最累的地方</h3><p>眼睛，肩膀，脑子</p><h3 id="在日常中会不会有什么“职业病”"><a href="#在日常中会不会有什么“职业病”" class="headerlink" title="在日常中会不会有什么“职业病”"></a>在日常中会不会有什么“职业病”</h3><p>去买水果，脑海里全是这种“伪代码”：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">如果 (有🍉) &#123;</span><br><span class="line">    买半个🍉</span><br><span class="line">&#125; 如果 (有🍓) &#123;</span><br><span class="line">    买一盒🍓</span><br><span class="line">&#125; 否则 &#123;</span><br><span class="line">    买🍎</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有什么计划，第一反应是先在手机提醒事项中记起来，脑子反而懒得记了</p><p>备份强迫症: 经常会提醒自己什么笔记、代码要备份到云上，莫名担心电脑硬盘坏了丢数据</p><h3 id="你每天最不会忘记的事是什么"><a href="#你每天最不会忘记的事是什么" class="headerlink" title="你每天最不会忘记的事是什么"></a>你每天最不会忘记的事是什么</h3><p>看所有公众号的更新、各种平台打卡（比如虎牙直播）、写点日记</p><!--是不是应该有更贴近生活的呢？--><h3 id="支撑你上班的原动力"><a href="#支撑你上班的原动力" class="headerlink" title="支撑你上班的原动力"></a>支撑你上班的原动力</h3><p>听歌</p><h3 id="每天最真实的感觉是什么"><a href="#每天最真实的感觉是什么" class="headerlink" title="每天最真实的感觉是什么"></a>每天最真实的感觉是什么</h3><p>一直在忙，但是下班前都想不清这一天到底做了什么</p><h3 id="最不真实的感觉是什么"><a href="#最不真实的感觉是什么" class="headerlink" title="最不真实的感觉是什么"></a>最不真实的感觉是什么</h3><p>需求竟然做完了？</p><h3 id="中午同事们一般怎么吃"><a href="#中午同事们一般怎么吃" class="headerlink" title="中午同事们一般怎么吃"></a>中午同事们一般怎么吃</h3><p>外卖，饭堂和自己带饭</p><h3 id="午休一般能睡多久"><a href="#午休一般能睡多久" class="headerlink" title="午休一般能睡多久"></a>午休一般能睡多久</h3><p>只够睡半个小时，不过也是支撑下午到晚上的半个小时，不睡真的不行</p><h3 id="下午茶一般吃什么"><a href="#下午茶一般吃什么" class="headerlink" title="下午茶一般吃什么"></a>下午茶一般吃什么</h3><p>奶茶，偶尔会点个垃圾食品</p><h3 id="办公位大家一般会放什么东西"><a href="#办公位大家一般会放什么东西" class="headerlink" title="办公位大家一般会放什么东西"></a>办公位大家一般会放什么东西</h3><p>用来提神的（茶罐、咖啡）、收线器、厚厚一摞书，消毒水</p><h3 id="最近看到办公位上特别的东西"><a href="#最近看到办公位上特别的东西" class="headerlink" title="最近看到办公位上特别的东西"></a>最近看到办公位上特别的东西</h3><p>戴着圣诞帽的小黄鸭，加湿器，热水壶</p><h3 id="还有什么比较特别的工位"><a href="#还有什么比较特别的工位" class="headerlink" title="还有什么比较特别的工位"></a>还有什么比较特别的工位</h3><p>搞ui的工位都有 imac</p><p>面前的工位隔板上贴自己小孩照片</p><p>放几个仙人球</p><p>磊着好多业界经典书籍</p><h3 id="买过最多的东西"><a href="#买过最多的东西" class="headerlink" title="买过最多的东西"></a>买过最多的东西</h3><p>数据线，起码两位数</p><h3 id="最想要的设备"><a href="#最想要的设备" class="headerlink" title="最想要的设备"></a>最想要的设备</h3><p>好一点的音响和显示器</p><h3 id="什么样的键盘敲着舒服"><a href="#什么样的键盘敲着舒服" class="headerlink" title="什么样的键盘敲着舒服"></a>什么样的键盘敲着舒服</h3><p>Mac那种键程短，又很有反馈感的就很好</p><p>有时灵感来了，敲得飞起，有种放飞自我的感觉</p><h3 id="最近发现什么有意思的事"><a href="#最近发现什么有意思的事" class="headerlink" title="最近发现什么有意思的事"></a>最近发现什么有意思的事</h3><p>寒潮到来，让电脑多跑点服务，键盘可以暖手</p><p>跟一些同事聊天，他们的情绪波动曲线和股市波动曲线高度吻合</p><p>下班去一家点过外卖的猪脚饭，老板还送了一份咸菜，疲惫感顿时消失一半，看来外卖还是不如到店吃</p><h3 id="什么能给自己带来爽感"><a href="#什么能给自己带来爽感" class="headerlink" title="什么能给自己带来爽感"></a>什么能给自己带来爽感</h3><p>查一个问题，浏览器密密麻麻地打开了十几个网页，解决之后一连串地按 ctrl+w 关掉</p><h3 id="上班累了有什么摸鱼方式"><a href="#上班累了有什么摸鱼方式" class="headerlink" title="上班累了有什么摸鱼方式"></a>上班累了有什么摸鱼方式</h3><p>吃点零食，刷刷论坛</p><h3 id="有什么经验牢记在心"><a href="#有什么经验牢记在心" class="headerlink" title="有什么经验牢记在心"></a>有什么经验牢记在心</h3><p>执行rm千万不要顺手就接上rf</p><p>下班前半小时不要操作任何线上服务</p><p>手动测试变更了什么配置，要记得复原回去</p><p>用 nohup 启动的后台进程要知道什么时候会停止</p><h3 id="测试和你之间最常说的话"><a href="#测试和你之间最常说的话" class="headerlink" title="测试和你之间最常说的话"></a>测试和你之间最常说的话</h3><p>测试: 快看，这个参数调接口报错了</p><p>我: 你这个参数传的不合理啊，业务不可能这么传的</p><p>测试: 我哪知道，反正就是报错了，你得解决</p><h3 id="开发小伙伴和你之间最常说的话"><a href="#开发小伙伴和你之间最常说的话" class="headerlink" title="开发小伙伴和你之间最常说的话"></a>开发小伙伴和你之间最常说的话</h3><p>前端: 我这边展示需要这个信息，你加个接口吧</p><p>其他后端同学: 什么时候可以联调啊</p><h3 id="上班路上有什么有意思的事情做"><a href="#上班路上有什么有意思的事情做" class="headerlink" title="上班路上有什么有意思的事情做"></a>上班路上有什么有意思的事情做</h3><p>看看地铁上有谁不玩手机​</p><h3 id="下班路上有什么有意思的事情可以做"><a href="#下班路上有什么有意思的事情可以做" class="headerlink" title="下班路上有什么有意思的事情可以做"></a>下班路上有什么有意思的事情可以做</h3><p>出地铁了看看小吃摆摊有没有新开什么好吃的</p><!--通勤路上讨厌的人地铁已经很拥挤了，还非要看手机，把手机硬怼别人面前--><h3 id="下班后的团建一般干嘛"><a href="#下班后的团建一般干嘛" class="headerlink" title="下班后的团建一般干嘛"></a>下班后的团建一般干嘛</h3><p>烧烤，喝酒，唱K</p><h3 id="下班到家了最想做什么"><a href="#下班到家了最想做什么" class="headerlink" title="下班到家了最想做什么"></a>下班到家了最想做什么</h3><p>赶紧吃完就睡，每天都能睡够八个小时，可惜做不到</p><h3 id="工作后对你帮助最大的人"><a href="#工作后对你帮助最大的人" class="headerlink" title="工作后对你帮助最大的人"></a>工作后对你帮助最大的人</h3><p>两个以前的同事，跟他们聊项目，聊八股文，吐槽现状，总是会很有意思</p><h3 id="最近什么事是比较自豪的"><a href="#最近什么事是比较自豪的" class="headerlink" title="最近什么事是比较自豪的"></a>最近什么事是比较自豪的</h3><p>无事度过2023</p><h3 id="如果家人来深圳，你会带他们去你的公司逛吗"><a href="#如果家人来深圳，你会带他们去你的公司逛吗" class="headerlink" title="如果家人来深圳，你会带他们去你的公司逛吗"></a>如果家人来深圳，你会带他们去你的公司逛吗</h3><p>不会，写字楼有什么好看的</p><h3 id="一周里哪一天最特别"><a href="#一周里哪一天最特别" class="headerlink" title="一周里哪一天最特别"></a>一周里哪一天最特别</h3><p>还得是周五。不管工作有没有做完，团建也好，到市区逛街也好，早点回家也罢，这一天总是对下班生活有所期待</p><h3 id="周末有什么放松方式"><a href="#周末有什么放松方式" class="headerlink" title="周末有什么放松方式"></a>周末有什么放松方式</h3><p>困了睡觉，饿了做饭，想再放松点就打打cs，想过充实点就写写自己的项目​，或者出门逛逛​</p><h3 id="最讨厌职场中什么样的人"><a href="#最讨厌职场中什么样的人" class="headerlink" title="最讨厌职场中什么样的人"></a>最讨厌职场中什么样的人</h3><p>领导的舔狗，甩锅的高手，晚上群里吼，揽功他最猛</p><h3 id="看到某某大厂又给员工加薪的新闻是什么反应"><a href="#看到某某大厂又给员工加薪的新闻是什么反应" class="headerlink" title="看到某某大厂又给员工加薪的新闻是什么反应"></a>看到某某大厂又给员工加薪的新闻是什么反应</h3><p>当然是选择没看到，麻痹自己啦</p><h3 id="最近想吐槽的"><a href="#最近想吐槽的" class="headerlink" title="最近想吐槽的"></a>最近想吐槽的</h3><p>无聊的时候看了一张业务表的结构，有170多列，而且很多冗余字段，难以想象业务的sql写起来会是什么样子</p><p>最近安全部门对我们开始提各种要求，什么这个数据权限要管控，那个数据要加密，想起了几年前被安全的需求支配的日子</p><h3 id="最讨厌的词"><a href="#最讨厌的词" class="headerlink" title="最讨厌的词"></a>最讨厌的词</h3><p>狼性: “能不能学一下xx公司，他们的员工都是有狼性的”，为什么就不能先好好做个人呢</p><p>抓手: 以xx为抓手，总是觉得领导说到这个词是反而很空虚的表现，仿佛没有了这个xx抓手团队就不知道干嘛一样</p><h3 id="压力满分是100分，给自己一天的状态打个分"><a href="#压力满分是100分，给自己一天的状态打个分" class="headerlink" title="压力满分是100分，给自己一天的状态打个分"></a>压力满分是100分，给自己一天的状态打个分</h3><p>上午50，下午80，晚上70</p><p>你问什么时候才能低于20分，我估计得等到退休那天吧</p><h3 id="最羡慕什么样的人"><a href="#最羡慕什么样的人" class="headerlink" title="最羡慕什么样的人"></a>最羡慕什么样的人</h3><p>特有料（全栈工程师），特好睡，特能卷（永远充满能量）</p><h3 id="什么时候会感到失望"><a href="#什么时候会感到失望" class="headerlink" title="什么时候会感到失望"></a>什么时候会感到失望</h3><p>需求尽力去做了，但最后用户说不是我真正想要的样子</p><h3 id="最开心的时候是什么样"><a href="#最开心的时候是什么样" class="headerlink" title="最开心的时候是什么样"></a>最开心的时候是什么样</h3><p>得到用户的夸赞</p><h3 id="用歌名形容你一天的工作"><a href="#用歌名形容你一天的工作" class="headerlink" title="用歌名形容你一天的工作"></a>用歌名形容你一天的工作</h3><p>到工位先来杯《爷爷泡的茶》<br>突然来个会要处理紧急需求，心里吐槽的同时默默地把企微签名设置成了《我很忙》<br>被分配了个大需求，感叹《我不配》，不知道加多少班才能搞完<br>特别是晚上加班熬夜的时候，感觉灵魂都在《千里之外》<br>每天忙忙碌碌，时不时想回老家，只想一边闻《稻香》一边听《夜曲》</p><h2 id="技术和学习"><a href="#技术和学习" class="headerlink" title="技术和学习"></a>技术和学习</h2><h3 id="用代码形容自己的一天"><a href="#用代码形容自己的一天" class="headerlink" title="用代码形容自己的一天"></a>用代码形容自己的一天</h3><p>wakeup(7:30)<br>eat(breakfest)<br>subway(home -&gt; company)<br>meeting(daily progress)<br>coding(1 hour)<br>eat(lunch)<br>sleep(30 minutes)<br>coding(2 hour)<br>relax(10 minutes)<br>reply(users)<br>fix(bugs)<br>coding(1 hour)<br>list(what I do today)<br>eat(dinner)<br>subway(company -&gt; home)<br>coding(self project)<br>sleep</p><h3 id="工作后你掌握的第一个技能是什么"><a href="#工作后你掌握的第一个技能是什么" class="headerlink" title="工作后你掌握的第一个技能是什么"></a>工作后你掌握的第一个技能是什么</h3><p>写curd接口</p><h3 id="工作后接触的第一个项目是什么"><a href="#工作后接触的第一个项目是什么" class="headerlink" title="工作后接触的第一个项目是什么"></a>工作后接触的第一个项目是什么</h3><p>也是印象最深的: mysql 主备自动切换</p><h3 id="最近掌握的技能是什么"><a href="#最近掌握的技能是什么" class="headerlink" title="最近掌握的技能是什么"></a>最近掌握的技能是什么</h3><p>使用 ffmpeg 对音乐文件做一些处理，比如转格式，加元数据等</p><h3 id="平时用的最多的linux指令是什么"><a href="#平时用的最多的linux指令是什么" class="headerlink" title="平时用的最多的linux指令是什么"></a>平时用的最多的linux指令是什么</h3><p>ll, cd, find, vim, nohup, grep, sed</p><h3 id="平时用的最多的脚本-sql"><a href="#平时用的最多的脚本-sql" class="headerlink" title="平时用的最多的脚本/sql"></a>平时用的最多的脚本/sql</h3><p>脚本: 编译服务: go build, mvn package…</p><p>sql: 看看集群每天跑了多少任务: select count…</p><h3 id="最近做的很有意义的一件事"><a href="#最近做的很有意义的一件事" class="headerlink" title="最近做的很有意义的一件事"></a>最近做的很有意义的一件事</h3><p>树莓派真正用起来了</p><h3 id="用得最多的设计模式"><a href="#用得最多的设计模式" class="headerlink" title="用得最多的设计模式"></a>用得最多的设计模式</h3><p>单例，感觉它很能给开发者安全感</p><p>最近因为要写对接多种数据库的接口，用工厂模式也挺多的</p><h3 id="觉得最有意义的词"><a href="#觉得最有意义的词" class="headerlink" title="觉得最有意义的词"></a>觉得最有意义的词</h3><p>重构，有一种“否定旧的想法，用新的思维重造项目”的意味，也是贯穿程序员生涯始终的事情</p><h3 id="相比毕业时，用到技术栈最大的变化"><a href="#相比毕业时，用到技术栈最大的变化" class="headerlink" title="相比毕业时，用到技术栈最大的变化"></a>相比毕业时，用到技术栈最大的变化</h3><p>容器生态的流行。已经是万物（服务）皆可容器化的时代了</p><h3 id="你觉得你和自己写的代码之间是什么关系"><a href="#你觉得你和自己写的代码之间是什么关系" class="headerlink" title="你觉得你和自己写的代码之间是什么关系"></a>你觉得你和自己写的代码之间是什么关系</h3><p>以前写出来的代码（服务），写完老是不听话，有时还要闹脾气，就好像完全不认识一样</p><p>现在终于算是能写出帮自己干活的“小伙伴”了</p><h3 id="曾经有哪些误解"><a href="#曾经有哪些误解" class="headerlink" title="曾经有哪些误解"></a>曾经有哪些误解</h3><p>后台开发不用管测试（起码要写单元测试）</p><p>运维的技术含量不高（天天跟设备和底层打交道）</p><p>搞业务比搞平台事情多多了（业务的忙是一阵一阵的，平台要做好是持续性的）</p><p>小公司远没有大厂卷（有人的地方就有江湖）</p><p>996是吓唬人的（</p><h3 id="这些年开发工具的变化"><a href="#这些年开发工具的变化" class="headerlink" title="这些年开发工具的变化"></a>这些年开发工具的变化</h3><p>IDE: 从eclipse到IDEA、vscode<br>调试环境: 从本地到开发服务器或容器<br>服务升级方式: 从手动传包，和运维沟通，到直接登录devops平台操作<br>沟通方式: 从本地文档和会议，到在线文档<br>查询资料的方式: 从搜索引擎变成了gpt（趋势）</p><h3 id="平时电脑上用到比较重要的工具"><a href="#平时电脑上用到比较重要的工具" class="headerlink" title="平时电脑上用到比较重要的工具"></a>平时电脑上用到比较重要的工具</h3><p>粘贴板历史，提醒事项，onenote</p><h3 id="最好的语言是什么"><a href="#最好的语言是什么" class="headerlink" title="最好的语言是什么"></a>最好的语言是什么</h3><p>没有最好只有最适合</p><p>对我而言是 go，平时写工具，写微服务多一点，用go写确实很方便</p><h3 id="除了专业技术外练就的技巧"><a href="#除了专业技术外练就的技巧" class="headerlink" title="除了专业技术外练就的技巧"></a>除了专业技术外练就的技巧</h3><p>盲打，处理数据小能手</p><h3 id="接下来的一年想提高的地方"><a href="#接下来的一年想提高的地方" class="headerlink" title="接下来的一年想提高的地方"></a>接下来的一年想提高的地方</h3><p>英语再练好一点，现在看文章的速度还是有点慢</p><h3 id="接下来最想学的技术"><a href="#接下来最想学的技术" class="headerlink" title="接下来最想学的技术"></a>接下来最想学的技术</h3><p>客户端开发</p><h2 id="就业环境"><a href="#就业环境" class="headerlink" title="就业环境"></a>就业环境</h2><h3 id="这两年的形式，对行业影响大吗"><a href="#这两年的形式，对行业影响大吗" class="headerlink" title="这两年的形式，对行业影响大吗"></a>这两年的形式，对行业影响大吗</h3><p>虽然整体相比其他行业，可能还算好的，但明显已没有几年前疯狂“扩张”的趋势，各种“降本增效”以及它带来的后果已经很明显了，去年上热搜的故障可不少，裁员更不用多说</p><h3 id="现在行业对我们员工的期望是什么样的"><a href="#现在行业对我们员工的期望是什么样的" class="headerlink" title="现在行业对我们员工的期望是什么样的"></a>现在行业对我们员工的期望是什么样的</h3><p>一个人，担当开发测试两个角色，负责三个项目，每周开四次会，五天工作日持续输出，周六偶尔加加班，一年做出7项重点成就，在社区分享8篇博客，每天干活到9点，最后，做到以上所有，十全十美</p><!--如果你是应届生，那首先要能多加班，最好一周熟悉一个项目马上开发，毕竟不给自己点压力怎么成长呢？相信你一定行如果你是社招生，那先来接手三个旧服务吧。开发它的小伙伴没留下什么文档吗？那就加班看代码，把业务逻辑全部钻清楚呗。即使它们每天的状态都是摇摇欲坠，在线上每天给你报数不清的bug，也没事，这些项目的重构也是交给你的如果你是组内大头兵，那你最好能接住，领导给你分配一个调研性的需求，要求你一个月搞出来，没思路怎么办呢，--><!--如果你是一名应届生，那么对你的要求就是能“充满活力”地加班，要能很好地接住导师分给你的需求，偶尔写个小bug，毕竟谁都是这么过来的嘛，不加班如果你通过社招到了一个如果你是组内大头兵如果你是项目经理，那么你要能建立足够微信--><h3 id="相比刚毕业那会，行业氛围最大的变化"><a href="#相比刚毕业那会，行业氛围最大的变化" class="headerlink" title="相比刚毕业那会，行业氛围最大的变化"></a>相比刚毕业那会，行业氛围最大的变化</h3><p>大家都变得现实，不谈理想了</p><h2 id="行业观察"><a href="#行业观察" class="headerlink" title="行业观察"></a>行业观察</h2><h3 id="这一年接触最多的行业热词有哪些"><a href="#这一年接触最多的行业热词有哪些" class="headerlink" title="这一年接触最多的行业热词有哪些"></a>这一年接触最多的行业热词有哪些</h3><p>行业: 毋庸置疑的 chatgpt</p><p>语言: rust(这几年的后起之秀都很猛)</p><p>前后端: 低代码</p><p>数据: 数据安全</p><p>资源: 降本增效，资源裁撤</p><h3 id="简单的话形容云计算、云服务、云存储的云"><a href="#简单的话形容云计算、云服务、云存储的云" class="headerlink" title="简单的话形容云计算、云服务、云存储的云"></a>简单的话形容云计算、云服务、云存储的云</h3><p>就和云一样，你不需要实实在在接触到它，稍一留意就能感受到它的存在</p><h3 id="简单的话形容大数据"><a href="#简单的话形容大数据" class="headerlink" title="简单的话形容大数据"></a>简单的话形容大数据</h3><p>好比茶具，普通点的有办公室、饭店用的茶壶，高端点的有一整套的茶壶、杯子和茶几</p><p>它们当然都能泡茶，但是高端的茶具自然可以泡更高端的茶，泡出的也更有味</p><h3 id="怎么看待降本增效"><a href="#怎么看待降本增效" class="headerlink" title="怎么看待降本增效"></a>怎么看待降本增效</h3><!--本身肯定有风险，人少了，出了问题就可能找不到人来解决；机器资源减少了，服务在高峰期出故障的概率也会变高。但对公司来说，确实还是能迅速节省成本，所以都乐此不疲--><p>还是那句话，没影响的怎么都感觉不到，但压在个人身上就是座大山</p><h3 id="现在app的更新给你的感受"><a href="#现在app的更新给你的感受" class="headerlink" title="现在app的更新给你的感受"></a>现在app的更新给你的感受</h3><p>现在好多app的新功能，目的已经不是“满足我的需求”，给我的感觉也不再是“这个功能好有用”。而是不停地在首页新增各种内容板块，一打开，仿佛都在争着向你大声说“快来看我！这个内容你一定喜欢！”、“这个视频你不喜欢吗，那就翻下一个，一定更好玩！”、“不看你就out咯“…</p><h3 id="这几年一直很热门的技术"><a href="#这几年一直很热门的技术" class="headerlink" title="这几年一直很热门的技术"></a>这几年一直很热门的技术</h3><p>数据库，一直很重要，也一直有更快，更好用的数据库项目出来</p><h3 id="未来看好的方向"><a href="#未来看好的方向" class="headerlink" title="未来看好的方向"></a>未来看好的方向</h3><p>低代码</p><p>它代表的不只是通过拼接积木一般的方式写代码，而是所有逻辑，所有数据都形成了统一的规范。大家都按照这个规范，去用低代码提供的组件实现功能，就能减少不必要的争执，提高效率</p><h3 id="你认为行业中比较特别的技术人"><a href="#你认为行业中比较特别的技术人" class="headerlink" title="你认为行业中比较特别的技术人"></a>你认为行业中比较特别的技术人</h3><p>阮一峰，坚持每周五发技术周刊，而且很有干货</p><h3 id="这几年对我们生活影响最大的产品"><a href="#这几年对我们生活影响最大的产品" class="headerlink" title="这几年对我们生活影响最大的产品"></a>这几年对我们生活影响最大的产品</h3><p>毫无疑问是短视频，改变了主流媒体，改变了大家获取信息的主要方式</p><h3 id="互联网行业的意义是什么"><a href="#互联网行业的意义是什么" class="headerlink" title="互联网行业的意义是什么"></a>互联网行业的意义是什么</h3><p>有时候挺迷茫: 看起来互联网人所做的事很前沿，支撑一切线上的服务，线上的所有服务、app又确实是和现实关联着的，但回想自己每天做的事，又感觉好多都没什么意义，跟现实关系也不大</p><h2 id="最后想说说的"><a href="#最后想说说的" class="headerlink" title="最后想说说的"></a>最后想说说的</h2><h3 id="评选一个属于你的23年年度汉字"><a href="#评选一个属于你的23年年度汉字" class="headerlink" title="评选一个属于你的23年年度汉字"></a>评选一个属于你的23年年度汉字</h3><p>苟（卷、熬也行）</p><h3 id="经历过的项目中有什么事感到遗憾的"><a href="#经历过的项目中有什么事感到遗憾的" class="headerlink" title="经历过的项目中有什么事感到遗憾的"></a>经历过的项目中有什么事感到遗憾的</h3><p>之前的一个项目组，做的事挺有前景，组员之间说话也都很有意思，也有大牛能hold住一整套架构，最后却因为各种原因散了</p><h3 id="如果有时光机，想穿越到哪个时间"><a href="#如果有时光机，想穿越到哪个时间" class="headerlink" title="如果有时光机，想穿越到哪个时间"></a>如果有时光机，想穿越到哪个时间</h3><p>刚工作的第一个项目，最初的4个人，把当时做的服务再好好的重构一遍</p><h3 id="虚拟世界和现实世界分得清楚不"><a href="#虚拟世界和现实世界分得清楚不" class="headerlink" title="虚拟世界和现实世界分得清楚不"></a>虚拟世界和现实世界分得清楚不</h3><p>分不清，甚至有时觉得虚拟世界更真实，现实世界也不过就是一个大型程序嘛，每个人都在尽力完成早就编好的逻辑。可能各个小功能有bug，但最后都会有人去修补它们，我们也是无数bug修补工程师的其中之一</p><h3 id="什么时候会感到迷茫"><a href="#什么时候会感到迷茫" class="headerlink" title="什么时候会感到迷茫"></a>什么时候会感到迷茫</h3><p>学新东西的时候就特别容易迷茫</p><p>一方面要补的基础知识太多，操作系统、网络、数据库、数据结构、算法，真正解决问题的时候就得靠这些知识</p><p>另一方面，开源社区在日新月异地更新，我们在工作中所用的框架，服务，工具 各种东西，可能每个月都有大版本更新，还得抽点时间去了解</p><p>就是这种每天都在忙，每天也都有新东西要学节奏，偶尔真的会有无力感，不知道学到何时才是尽头</p><h3 id="如果生活节奏可以慢下来，最想做什么"><a href="#如果生活节奏可以慢下来，最想做什么" class="headerlink" title="如果生活节奏可以慢下来，最想做什么"></a>如果生活节奏可以慢下来，最想做什么</h3><p>用旁观者的角度看这座打工之城，在通勤高峰期，站在换乘中心的地铁站，又或是坐在前往市区的公交上，​看那与自己无关的人潮涌动，感受这座城市的血液和心跳</p><h3 id="哪天不做程序员了可以干嘛呢"><a href="#哪天不做程序员了可以干嘛呢" class="headerlink" title="哪天不做程序员了可以干嘛呢"></a>哪天不做程序员了可以干嘛呢</h3><p>其实还没有认真想过，除了做司机送外卖这些老生常谈的“归宿”，希望能再提升一下撇脚的日语，找个字幕组混口饭吃吧</p><h3 id="有什么想对刚入行的年轻人说的"><a href="#有什么想对刚入行的年轻人说的" class="headerlink" title="有什么想对刚入行的年轻人说的"></a>有什么想对刚入行的年轻人说的</h3><p>技术确实能创造价值，但也是建立在量变到质变的基础之上。所以该卷还得卷，反卷鸡汤听听就好了，吃饭的本事还是得练好的</p><p>其次就是培养点爱好，现在大家过得都不容易，总要有办法找点乐子</p><!--身处信息时代，你觉得这个时代更好了吗工具确实在进步: 通讯软件代替了电话和写信，手机代替了mp3 mp4，人和人之间的交流成本更低了，但人与人的关系，社会发生的所有事背后，依然是人性所驱。人性会随着时代改变吗，我认为不会--><h3 id="今年希望做点什么呢"><a href="#今年希望做点什么呢" class="headerlink" title="今年希望做点什么呢"></a>今年希望做点什么呢</h3><p>基于开源项目、且已经有大体规划的一个需求，已经开始做了。对自己而言挺重要的，希望到年底能把功能完善到真正用起来的程度吧</p>]]></content>
      
      
      <categories>
          
          <category> 生活 </category>
          
          <category> 互联网 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 生活 </tag>
            
            <tag> 互联网 </tag>
            
            <tag> 职业 </tag>
            
            <tag> 创作 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mongodb数据同步到hive</title>
      <link href="/2023/10/31/emr-mongo-to-hive/"/>
      <url>/2023/10/31/emr-mongo-to-hive/</url>
      
        <content type="html"><![CDATA[<p><a href="https://blog.csdn.net/xiaoliizi/article/details/134313303">本文csdn地址</a></p><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>用户需求: 需要将 mongodb 的数据同步到 hive 表，共 2 亿+条数据，总数据量约 30G</p><p>查阅一些博客后，了解到同步方法有以下几种</p><ul><li><p>手动+离线</p><p>对于比较小的数据，可以先通过 <strong>mongoexport</strong> 将数据导出到本地 json 文件，再将 json 直接上传到 hdfs，创建 hive 表关联到这个文件即可</p><p>这种方式非常简单直接，但需要两次 读取到写入 的过程，而且如果 mongodb 中的数据很大，需要先导到本地的方式将会导致本地磁盘占用升高，不是很适合</p><p>参考: <a href="https://www.cnblogs.com/beststrive/p/14187383.html">Mongoexport同步数据到Hive</a></p></li><li><p>工具+离线</p><p>通过 datax / seatunnel 之类的数据同步服务，数据在内存中完成同步</p><p><a href="https://github.com/alibaba/DataX/blob/master/mongodbreader/doc/mongodbreader.md">datax-mongodbreader</a></p><p><a href="https://github.com/alibaba/DataX/blob/master/hdfswriter/doc/hdfswriter.md">datax-hdfswriter</a></p><p><a href="https://seatunnel.apache.org/docs/2.3.3/connector-v2/source/MongoDB">seatunnel-connector-mongo</a></p><p><a href="https://seatunnel.apache.org/docs/2.3.3/connector-v2/sink/Hive/">seatunnel-connector-hive</a></p></li><li><p>实时</p><p>mongodb 在 3.6 版本支持了 change streamer，支持在客户端监听数据变更，实现实时更新</p><p>但这个同步逻辑需要依赖单独的程序去完成，这次用户需求也只要一次性的全量更新，不涉及增量更新，因此这一块就不具体看了</p><p><a href="https://cloud.tencent.com/developer/article/1711794">MongoDB Change Stream之一——上手及初体验原创</a></p></li></ul><h2 id="通过-datax-同步数据"><a href="#通过-datax-同步数据" class="headerlink" title="通过 datax 同步数据"></a>通过 datax 同步数据</h2><h3 id="任务定义"><a href="#任务定义" class="headerlink" title="任务定义"></a>任务定义</h3><p>json 配置文件参考官方文档进行适配即可</p><p>注意: hdfswriter 的 defaultFS 如果指定的是集群地址，比如 hdfs://cluster_name，可能会遇到解析不了的问题，需要把 hdfs 的配置文件打入到 hdfswriter-0.0.1-SNAPSHOT.jar 包中去</p><p><a href="https://github.com/alibaba/DataX/issues/197#issuecomment-436843464">参考issue</a></p><p><a href="https://stackoverflow.com/a/2591548">jar 打包指令参考</a></p><p>datax 任务定义:</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;job&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;content&quot;</span>: [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">&quot;reader&quot;</span>: &#123;</span><br><span class="line">          <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;mongodbreader&quot;</span>,</span><br><span class="line">          <span class="attr">&quot;parameter&quot;</span>: &#123;</span><br><span class="line">            <span class="attr">&quot;address&quot;</span>: [</span><br><span class="line">              <span class="string">&quot;host1:27017&quot;</span>,</span><br><span class="line">              <span class="string">&quot;host2:27017&quot;</span>,</span><br><span class="line">              <span class="string">&quot;host3:27017&quot;</span></span><br><span class="line">            ],</span><br><span class="line">            <span class="attr">&quot;collectionName&quot;</span>: <span class="string">&quot;collection_name&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;column&quot;</span>: [</span><br><span class="line">              &#123;</span><br><span class="line">                <span class="attr">&quot;index&quot;</span>: <span class="number">0</span>,</span><br><span class="line">                <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;id&quot;</span>,</span><br><span class="line">                <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;string&quot;</span></span><br><span class="line">              &#125;,</span><br><span class="line">              ...</span><br><span class="line">            ],</span><br><span class="line">            <span class="attr">&quot;dbName&quot;</span>: <span class="string">&quot;db&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;userName&quot;</span>: <span class="string">&quot;user&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;userPassword&quot;</span>: <span class="string">&quot;password&quot;</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">&quot;writer&quot;</span>: &#123;</span><br><span class="line">          <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;hdfswriter&quot;</span>,</span><br><span class="line">          <span class="attr">&quot;parameter&quot;</span>: &#123;</span><br><span class="line">            <span class="attr">&quot;column&quot;</span>: [</span><br><span class="line">              &#123;</span><br><span class="line">                <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;id&quot;</span>,</span><br><span class="line">                <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;string&quot;</span></span><br><span class="line">              &#125;</span><br><span class="line">              ...</span><br><span class="line">            ],</span><br><span class="line">            <span class="attr">&quot;compress&quot;</span>: <span class="string">&quot;SNAPPY&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;defaultFS&quot;</span>: <span class="string">&quot;hdfs://cluster_name&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;fieldDelimiter&quot;</span>: <span class="string">&quot;\u0001&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;fileName&quot;</span>: <span class="string">&quot;$table&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;fileType&quot;</span>: <span class="string">&quot;orc&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;path&quot;</span>: <span class="string">&quot;/user/hive/warehouse/db_name.db/table_name&quot;</span>, <span class="comment">// hdfs 路径需要先创建好</span></span><br><span class="line">            <span class="attr">&quot;writeMode&quot;</span>: <span class="string">&quot;truncate&quot;</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    ],</span><br><span class="line">    <span class="attr">&quot;setting&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;speed&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;channel&quot;</span>: <span class="string">&quot;2&quot;</span> <span class="comment">// 任务并行度，可根据实际情况调大</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h3><p>启动任务</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python bin/datax.py tmp/mongo_to_hive.json</span><br></pre></td></tr></table></figure><p>等待同步完成后，查看 hdfs 对应表路径的数据，可以看到生成的 txt 文件</p><p>然后创建 hive 表关联这个路径即可</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">external</span> <span class="keyword">table</span> table_name</span><br><span class="line">(</span><br><span class="line">    id string,</span><br><span class="line">    ...</span><br><span class="line">)</span><br><span class="line">COMMENT <span class="string">&#x27;同步表&#x27;</span></span><br><span class="line"><span class="type">ROW</span> FORMAT DELIMITED FIELDS TERMINATED <span class="keyword">BY</span> <span class="string">&#x27;\t&#x27;</span> LINES TERMINATED <span class="keyword">BY</span> <span class="string">&#x27;\n&#x27;</span></span><br><span class="line">STORED <span class="keyword">AS</span> ORC <span class="comment">-- 和 datax 任务中的 fileType 对应</span></span><br><span class="line">LOCATION <span class="string">&#x27;/user/hive/warehouse/db_name.db/table_name&#x27;</span>; <span class="comment">-- 和 path 对应</span></span><br></pre></td></tr></table></figure><h2 id="通过-seatunnel-同步数据"><a href="#通过-seatunnel-同步数据" class="headerlink" title="通过 seatunnel 同步数据"></a>通过 seatunnel 同步数据</h2><h3 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h3><p>不同于 datax，seatunnel 的安装过程稍微复杂点，而且和 hive 相关的ja包需要手动导入，因此在这里特别说明</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 下载 seatunnel 后，需要先安装插件（即各个connector）</span></span><br><span class="line">sh bin/install-plugin.sh 2.3.3</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 下载 hive 2.3.9 版本 （主要是为了拿到 jar 包，也可以从 maven 仓库单独下载下面的每个 jar 包）</span></span><br><span class="line">wget https://downloads.apache.org/hive/hive-2.3.9/apache-hive-2.3.9-bin.tar.gz</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 解压后，把以下 jar 包拷贝到 seatunnel 的 lib 下</span></span><br><span class="line"></span><br><span class="line">seatunnel_home=/opt/modules/seatunnel</span><br><span class="line"></span><br><span class="line">cd /opt/modules/apache-hive-2.3.9-bin/lib</span><br><span class="line"></span><br><span class="line">cp hive-metastore-2.3.9.jar $&#123;seatunnel_home&#125;/lib</span><br><span class="line"></span><br><span class="line">cp hive-common-2.3.9.jar $&#123;seatunnel_home&#125;/lib</span><br><span class="line"></span><br><span class="line">cp hive-exec-2.3.9.jar $&#123;seatunnel_home&#125;/lib</span><br><span class="line"></span><br><span class="line">cp libthrift-0.9.3.jar $&#123;seatunnel_home&#125;/lib</span><br><span class="line"></span><br><span class="line">cp libfb303-0.9.3.jar $&#123;seatunnel_home&#125;/lib</span><br></pre></td></tr></table></figure><h3 id="任务定义-1"><a href="#任务定义-1" class="headerlink" title="任务定义"></a>任务定义</h3><p>配置示例如下:</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">env &#123;</span><br><span class="line">  <span class="attr">execution.parallelism</span> = <span class="number">1</span></span><br><span class="line">  <span class="attr">job.mode</span> = <span class="string">&quot;BATCH&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">source &#123;</span><br><span class="line">  MongoDB &#123;</span><br><span class="line">    <span class="attr">uri</span> = <span class="string">&quot;mongodb://user:password@host1,host2,host3&quot;</span></span><br><span class="line">    <span class="attr">database</span> = <span class="string">&quot;db&quot;</span></span><br><span class="line">    <span class="attr">collection</span> = <span class="string">&quot;collection&quot;</span></span><br><span class="line">    <span class="attr">schema</span> = &#123;</span><br><span class="line">      fields &#123;</span><br><span class="line">            <span class="attr">id</span> = string</span><br><span class="line">            <span class="attr">create_time</span> = string</span><br><span class="line">            <span class="attr">update_time</span> = string</span><br><span class="line">            <span class="attr">name</span> = string</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">sink &#123;</span><br><span class="line">  Hive &#123;</span><br><span class="line">    <span class="attr">table_name</span> = <span class="string">&quot;db.table&quot;</span></span><br><span class="line">    <span class="attr">metastore_uri</span> = <span class="string">&quot;thrift://metastore_host:9083&quot;</span></span><br><span class="line">    <span class="attr">hdfs_site_path</span> = <span class="string">&quot;/etc/hadoop/conf/hdfs-site.xml&quot;</span> <span class="comment"># 和 datax 的问题类似，添加 hdfs 配置用于解析 hdfs 集群地址</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="效果-1"><a href="#效果-1" class="headerlink" title="效果"></a>效果</h3><p>执行任务:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./bin/seatunnel.sh --config mongo_to_hive.conf -e local&quot;</span><br></pre></td></tr></table></figure><p>目前还存在 空值无法转换的问题，报错: <strong>Unable to convert to &lt;STRING&gt; from nullable value null</strong>，需要等待社区解决</p><p>相关 issue: <a href="https://github.com/apache/seatunnel/issues/5340">[Bug] [MongoDB-CDC] 数据中有字段值为 Null 直接异常. #5340</a></p><h3 id="和-datax-的对比"><a href="#和-datax-的对比" class="headerlink" title="和 datax 的对比"></a>和 datax 的对比</h3><ul><li><p>配置: 都是 hive reader 和 mongo writer 的两部分数据源配置方式</p></li><li><p>写入方式: 都是把数据写入到 hdfs 路径，hive 表需要用户自己创建</p><p>seatunnel 的 hive connector 也是先从 hive 中读取 location，拿到 hdfs 的路径，参考: HiveSinkAggregatedCommitter 继承了 FileSinkAggregatedCommitter, HiveSink 继承了 BaseHdfsFileSink</p></li><li><p>运行环境: datax 只能本地运行，seatunnel 支持 local、flink、spark 等运行模式</p></li></ul><!-- 扩展: airbyte 同步方式 -->]]></content>
      
      
      <categories>
          
          <category> 大数据 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 大数据 </tag>
            
            <tag> hive </tag>
            
            <tag> mongo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>go 语言介绍</title>
      <link href="/2023/10/23/golang-origin/"/>
      <url>/2023/10/23/golang-origin/</url>
      
        <content type="html"><![CDATA[<p><a href="https://blog.csdn.net/xiaoliizi/article/details/134160923">本文 csdn</a></p><h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>一直有在零散的时间用go写点代码，正好借着最近比较有时间写东西的契机，给这个看着年轻，实际也已经发展10几年，并在当下众多开发领域都有不可忽视作用的语言做个介绍吧</p><h1 id="golang-的起点"><a href="#golang-的起点" class="headerlink" title="golang 的起点"></a>golang 的起点</h1><p>golang 的诞生可以说是时代造就了它，它也成就了研发工具、云原生和高性能服务开发百花齐放的时代</p><p>本节主要参考文章:</p><p><a href="https://go.dev/talks/2012/splash.article">Go at Google: Language Design in the Service of Software Engineering</a><br><a href="https://jaycechant.info/2020/translation-language-design-in-the-service-of-software-engineering">翻译-Google 里的 Go 语言：服务于软件工程的语言设计</a></p><p><a href="https://blog.csdn.net/EDDYCJY/article/details/122551805">煎鱼-为什么要开发 Go 这门新语言？</a></p><h2 id="开发痛点"><a href="#开发痛点" class="headerlink" title="开发痛点"></a>开发痛点</h2><ul><li>当时谷歌使用的语言：C++、Java 和 Python ，已经不适用于计算层面的需求，对于多核处理、大规模计算 和 web应用编程层面，遇到的问题都只能绕过，而不是直接解决</li></ul><p>ced by multicore processors, networked systems, massive computation clusters, and the web programming model </p><ul><li><p>软件规模：千万行代码，数千程序员共同维护（言外之意就是效率太低了，语言和开发者两个层面）</p></li><li><p>编译时间太长，几分钟到几小时都有（特别讲了 C++ #include 在编译上的消耗: <a href="https://go.dev/talks/2012/splash.article#TOC_5.">Dependencies in C and C++</a>）</p></li><li><p>依赖混乱，跨语言构建麻烦</p></li><li><p>难以编写自动化工具</p></li></ul><p>译者注: 结合原文之后的内容来看，最主要的两类问题就是 大规模的 C++ 项目编译时间长，以及多种语言维护成本高的问题</p><h2 id="发明者"><a href="#发明者" class="headerlink" title="发明者"></a>发明者</h2><p><a href="https://en.wikipedia.org/wiki/Robert_Griesemer">Robert Griesemer</a>: 参与过谷歌 V8 引擎的开发，<a href="https://en.wikipedia.org/wiki/Sawzall_(programming_language)">Sawzall 语言</a>（谷歌内部用的日志分级打印库，之后被 go 的日志库替代）、JVM 和 <a href="https://en.wikipedia.org/wiki/Strongtalk">strongtalk</a> 系统（用于类型检查，现在<a href="https://blog.csdn.net/iteye_14991/article/details/81522227">不维护了</a>）</p><p><a href="https://en.wikipedia.org/wiki/Rob_Pike">Rob Pike</a>：Unix 开发者之一，为 Unix 编写过终端，后续编写过 sam、acme 文本编辑器，再之后和 Ken Thompson 一起创造了 UTF-8</p><p><a href="https://en.wikipedia.org/wiki/Ken_Thompson">Ken Thompson</a>: Unix 开发者之一，B语言（C语言的前身）的发明者，后面 <a href="https://en.wikipedia.org/wiki/Dennis_Ritchie">Dennis Ritchie</a> 基于 B 语言又开发了 C语言。1983 年 Ken 和 Dennis 一同获得了<a href="https://zh.wikipedia.org/wiki/%E5%9B%BE%E7%81%B5%E5%A5%96">图灵奖</a></p><p>扩展: <a href="https://polarisxu.studygolang.com/posts/talk/go-celebrity-rsc">Russ Cox</a>，你可以在 golang 的很多 issue 中看到他的身影，他也是go代码<a href="https://github.com/golang/go/graphs/contributors">提交</a>次数最多的</p><p><img src="/2023/10/23/golang-origin/golang-commits.png" alt="golang commits"></p><p>推荐阅读: 图灵奖历届得主、<a href="https://changelog.com/gotime/77">golang talk</a></p><h2 id="吉祥物"><a href="#吉祥物" class="headerlink" title="吉祥物"></a>吉祥物</h2><p>名字: Gopher（囊地鼠）</p><p>由 Rob Pike 的妻子 Renee French 创作，官网甚至还有<a href="https://go.dev/doc/gopher/modelsheet.jpg">细节描述</a>呢</p><p><img src="/2023/10/23/golang-origin/gopher02.jpeg" alt="gopher"></p><p><img src="/2023/10/23/golang-origin/gopher03.jpeg" alt="gopher 特点"></p><h2 id="go-是什么样的语言"><a href="#go-是什么样的语言" class="headerlink" title="go 是什么样的语言"></a>go 是什么样的语言</h2><p>为了解决前面说的问题，go 必须有下面的特点:</p><ul><li>高效率、可扩展、满足生产力需求</li><li>必须有可扩展性，对于代码量多、依赖多、开发者多的大型项目 必须能很好运作</li><li>自带 GC，并在对象内存申请、释放空间上进行优化，保证GC尽量不影响业务运行</li><li>符合C的编程习惯，让程序员能丝滑切换（如: 静态类型对象）</li><li>必须足够现代化，在多核处理、网络、web 应用开发上需要更加方便，也要支持更多新特性，如内置的并发编程方案</li></ul><h2 id="时间和版本"><a href="#时间和版本" class="headerlink" title="时间和版本"></a>时间和版本</h2><p><a href="https://endoflife.date/go">golang 版本来源</a>: 从 1.10 到最新</p><p><img src="/2023/10/23/golang-origin/golang-versions.png" alt="golang versions"></p><h1 id="go-语言特点"><a href="#go-语言特点" class="headerlink" title="go 语言特点"></a>go 语言特点</h1><p>本节中，笔者将结合自己平时开发过程中使用到的 go 比较核心的特性进行基本介绍，这些也是 go 和其他编程语言最不同的地方，包括 基本语法、基本指令、函数、关键字、基本类型、打包方式等</p><h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><ul><li><strong>通过大括号划分代码块</strong>，保证大项目下依旧结构清晰</li><li><strong>不需要分号</strong>，虽然加了也不会报错</li><li><strong>不需要小括号</strong>，比如在 if a &lt; b 判断语句、for 循环中的判断，都不需要</li><li><strong>未使用的 import / 局部变量将报错</strong>，保证编译不会引入多余的代码，提升编译效率</li></ul><h2 id="执行"><a href="#执行" class="headerlink" title="执行"></a>执行</h2><ul><li><strong>go build</strong>: 统一的打包语句</li><li>编译后生成<strong>一个可执行文件</strong></li></ul><h2 id="debug"><a href="#debug" class="headerlink" title="debug"></a>debug</h2><ul><li><strong>pprof</strong>: 自带性能指标库，可通过火焰图、命令行查看堆栈情况、堆大小、各协程调用耗时等</li></ul><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><ul><li>接口不需要显式说明继承，只要实现了接口的方法即算是继承</li><li>接口可以通过 <strong>指针接收器（pointer receiver）</strong> 或 <strong>值接收器（value receiver）</strong>实现，分别适合 setter 和 getter 的实现，大对象的方法也适合用 指针接收器 避免频繁拷贝（参考: <a href="https://go.dev/doc/faq#methods_on_values_or_pointers">什么时候适合用什么接收器？</a>）</li><li>方法可以作为对象传递，可以作为 map 的 value、声明匿名方法、定义闭包（闭包常用于定义配置方法，如 <a href="https://github.com/trpc-group/trpc-go/blob/v1.0.1/trpc.go#L68C53-L68C59">trpc 的 server.Opts</a> 及其具体实现方法）</li><li><strong>不支持重载</strong>，用开发必须增加少量代码的代价换来了 代码可读性和编译性能（一些<a href="https://github.com/golang/go/issues/21659">讨论</a>）</li><li><strong>建议使用组合（composition），而不是继承（inheritance）</strong>（对比: java 类在多次继承后，要找到只在基类实现的方法的源代码，需要跳很多次才能找到，相反，组合的结构就很清晰，只有一层）</li></ul><h2 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h2><ul><li><strong>没有异常机制</strong>，通过 error + 函数返回值 直接返回报错，在外部及时处理错误（也促使开发者封装好会出现 error 的代码块，减少主函数的层级）</li><li>通过 <strong>panic + recover</strong> 机制捕获协程中发生的严重错误（如空指针）</li></ul><h2 id="基本类型和关键字"><a href="#基本类型和关键字" class="headerlink" title="基本类型和关键字"></a>基本类型和关键字</h2><ul><li><strong>切片（slice）和数组（array）</strong>: 切片包含数组、长度（len）和容量（cap）</li><li><strong>map</strong>: 非协程安全的 map（slice 也是非协程安全的，go 设计上就是让 channel 成为唯一的协程间通信对象）</li><li><strong>defer:</strong> 常用于释放资源、panic 处理</li><li><strong>make</strong>: 申请切片、map 和 channel 的空间</li><li><strong>init 方法</strong>: 被引用的时候，包内的所有 init 方法会自动执行。单个包内的 init 方法执行顺序按 文件名字段序 -&gt; 方法从上到下 的顺序执行，<a href="https://go.dev/ref/spec#Package_initialization">参考</a></li><li><strong>声明对象的方式</strong>: 通过 <strong>var</strong> 指定对象名称和类型，或直接 <strong>a := 1</strong>，编译器自动识别字段类型</li><li><strong>const</strong>: 声明常量</li><li><strong>iota</strong>: 枚举，只能是数值</li><li><strong>空白标识符</strong>: 下划线(_)，可用于忽略返回值，迭代 slice 或者 map 时忽略 下标/key，以及 init import（只执行包的 init 方法，不需要显式调用包的资源，如: import _ “net/http/pprof”）</li><li><strong>select case</strong>: 多个 Channel 同时读取方式</li><li><strong>总共只有[25个关键字]</strong>(<a href="https://articles.wesionary.team/know-about-25-keywords-in-go-eca109855d4d)%EF%BC%8C%E7%9B%B8%E6%AF%94">https://articles.wesionary.team/know-about-25-keywords-in-go-eca109855d4d)，相比</a>: C99 有 37 个，C++11 有 84 个</li></ul><h2 id="原生库和方法"><a href="#原生库和方法" class="headerlink" title="原生库和方法"></a>原生库和方法</h2><ul><li><strong>time</strong>: 时间，方法有 time.Parse, time.Now, time.DateTime（常量 2006-01-02 15:04:05）等</li><li><strong>io.ReadAll</strong>: 数据流</li><li><strong>bytes.Buffer</strong>: 字符串缓冲</li><li><strong>strings、maps、slices</strong>: 集合类型的工具方法，如 strings.ReplaceAll、maps.Clone、slices.Sort 等</li><li><strong>regexp</strong>: 正则</li><li><strong>net/http</strong>: http 核心库</li><li><strong>sort</strong>: 1.19 之前的数组排序库</li><li><strong>log/slog</strong>: 1.21 新增的日志库，支持等级和格式化打印</li><li><strong>sync</strong>: 协程之间同步、状态共享的相关组件库。<strong>Mutex</strong>: 锁；<strong>Once</strong>: 只执行一次；<strong>WaitGroup</strong>: 等待n个协程执行；<strong>Pool</strong>: 协程间复用对象；<strong>Cond</strong>: 等待和唤醒</li></ul><h2 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h2><ul><li><strong>reflect.TypeOf</strong>: 获取对象的具体<strong>类型</strong></li><li><strong>reflect.Kind</strong>: 获取对象的<strong>类别</strong>（和类型的区别: 具体值或指针的类别为 interface / pointer，类型可以拿到具体的 struct或接口类型）</li><li><strong>reflect.ValueOf</strong>: 获取对象的具体值</li><li><strong>struct tag</strong>: 标注 struct 内属性的附加信息，一般用于 json序列化、yaml 内容解析、orm 字段映射等场景</li></ul><h2 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h2><ul><li><strong>协程（Routine）</strong>: 用户层的“线程”，通过 <strong>go func()</strong> 开启并发</li><li><strong>管道（Channel）</strong>: 协程间的通信方式</li><li><strong>上下文（Context）</strong>: 协程间传递数据、父协程控制子协程状态的媒介</li></ul><h2 id="运行时（Runtime）"><a href="#运行时（Runtime）" class="headerlink" title="运行时（Runtime）"></a>运行时（Runtime）</h2><ul><li><strong>GPM</strong>: Go 进程的核心，协程（Goroutine）、处理器（Processor）、系统线程（Machine）</li><li><strong>GC</strong>: 三色标记法、混合写屏障等</li></ul><h2 id="包管理"><a href="#包管理" class="headerlink" title="包管理"></a>包管理</h2><ul><li><strong>从 git 路径引用依赖</strong>，没有“官方仓库”的说法，去中心化的设计</li><li>以 git tag 或者 commit id 作为版本标识</li><li>对象和方法是否对外可见，通过首字母大小写来标识，大写为开放，简单明了</li></ul><h2 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h2><ul><li><strong>gofmt、goformat、staticcheck</strong>: 代码格式化</li><li><strong>test、bench、fuzz</strong>: 普通测试、并发测试、混沌测试</li><li><strong>doc</strong>: 文档，go 的文档可在源码中通过注释编写，并自动生成</li></ul><p>以上就是自己常接触的原生库了，可以从 <a href="https://github.com/golang/go/tree/master/src">go源码的src目录</a> 更多的实现细节</p><!--## Sync- Mutex- Once- WaitGroup- Pool- Cond## package & import- from git tag / latest- import git path（ repo decentralized, can be same name ）- name case indicate visiable- not allow circle import## tools- gofmt / goformat / staticcheck- test / bench / fuzz- doc- gopls--><h1 id="自己写的和go有关的博客"><a href="#自己写的和go有关的博客" class="headerlink" title="自己写的和go有关的博客"></a>自己写的和go有关的博客</h1><p><a href="https://blog.csdn.net/xiaoliizi/article/details/133747191">golang 编程规范查漏补缺</a></p><p><a href="https://blog.csdn.net/xiaoliizi/article/details/107568024">golang-使用 go test 输出单元测试覆盖率</a></p><p><a href="https://blog.csdn.net/xiaoliizi/article/details/111768852">golang-单元测试和mock框架的介绍和推荐</a></p><p><a href="https://blog.csdn.net/xiaoliizi/article/details/111461690">golang-使用 godoc 工具编写代码注释</a></p><p><a href="https://blog.csdn.net/xiaoliizi/article/details/113177952">golang-文章翻译-go高效编程</a></p><p><a href="https://blog.csdn.net/xiaoliizi/article/details/118873747">golang-文章翻译-go常见的10种错误</a></p><p><a href="https://mp.weixin.qq.com/s/H6QUS0CtW_qUBSdXTK8E_w">vscode 使用技巧（vscode+go插件的开发环境）</a></p><h1 id="go-学习方法总结"><a href="#go-学习方法总结" class="headerlink" title="go 学习方法总结"></a>go 学习方法总结</h1><h2 id="官网"><a href="#官网" class="headerlink" title="官网"></a>官网</h2><p>Go 的官网其实是最好的学习资料，教程、博客、社区动态都有，绝对适合作为入门资料的第一位</p><p>下面说明官网中右上角各个栏目的内容</p><p><img src="/2023/10/23/golang-origin/go.dev.png" alt="go官网"></p><h3 id="为什么使用-Go（Why-Go）"><a href="#为什么使用-Go（Why-Go）" class="headerlink" title="为什么使用 Go（Why Go）"></a>为什么使用 Go（Why Go）</h3><p>大体就是 Go 在一些通用领域的使用场景，以及在大厂的使用情况</p><p>Case Studies: 大厂的使用场景，如 Google、CloudFare、Meta、Netflix 等</p><p>Use Cases: 在云服务、网络通信、命令行工具、网页/客户端应用 和 运维和可持续开发（DevOps、SRE）领域的应用<br>每一个领域下都有比较流行的开源项目的推荐</p><p>Security: 如何提升自己工程的安全性，如通过 <a href="https://go.dev/doc/tutorial/govulncheck">govulncheck</a> 检查项目存在哪些已知漏洞</p><h3 id="Learn"><a href="#Learn" class="headerlink" title="Learn"></a>Learn</h3><p>非常适合上手的 <a href="https://go.dev/tour">go tour</a>，几乎覆盖了 go，可以说练习完所有示例就会写 go 代码了</p><h3 id="Docs"><a href="#Docs" class="headerlink" title="Docs"></a>Docs</h3><p><a href="https://go.dev/doc">所有官方文章</a>: 可以挑讲原理的文章看，如 Using and understanding Go 中的 <a href="https://go.dev/doc/gc-guide">A Guide to the Go Garbage Collector</a> 以及 References 中的 <a href="https://go.dev/ref/mem">The Go Memory Model</a></p><p><a href="https://go.dev/doc/effective_go">Effective Go</a>: 上手之后，进一步了解 go 编程风格的必读文章</p><p><a href="https://pkg.go.dev/std">std</a>: 标准库文档</p><p><a href="https://go.dev/doc/faq">faq</a>: 囊括了从其他语言迁到 go 语言的常见问题，也体现了 go 的设计思想</p><h3 id="社区"><a href="#社区" class="headerlink" title="社区"></a>社区</h3><p><a href="https://go.dev/blog">blog</a>: go 博客，社区新动态</p><h2 id="开源项目和代码推荐"><a href="#开源项目和代码推荐" class="headerlink" title="开源项目和代码推荐"></a>开源项目和代码推荐</h2><h3 id="go"><a href="#go" class="headerlink" title="go"></a>go</h3><p>go 本身的源码就很好阅读，也和 go 本身语法比较简洁有关。如果你想了解 go 的基础库的原理，大可不用搜一堆博客，一点点地消化别人的总结，读go源码就是最好的学习go原理的方法<br>包括: sync, runtime, context, reflect，这些都是 go 的核心库</p><h3 id="web-应用"><a href="#web-应用" class="headerlink" title="web 应用"></a>web 应用</h3><p>开发后台必须要掌握的就是 web 框架，当然不同公司对它的定制化也会不同，如果想从简单的入手，使用官方推荐的 gin 就行。想参考大厂实际用的，可参考国内开发者开源的 web 框架（功能比较全），如字节的 hertz、go-zero、goframe 等</p><h3 id="中间件"><a href="#中间件" class="headerlink" title="中间件"></a>中间件</h3><p>gorm: 数据库 orm 库<br>redis: redigo<br>kafka: sarama</p><h3 id="云原生和监控"><a href="#云原生和监控" class="headerlink" title="云原生和监控"></a>云原生和监控</h3><p>如 Kubernetes、Istio、Prometheus、Grafana 等，也能接触到当下比较流行的项目</p><h3 id="命令行工具"><a href="#命令行工具" class="headerlink" title="命令行工具"></a>命令行工具</h3><p>以往我们需要用工具进行文档格式转换、爬虫、文件批量下载等场景，可能会主要以 python 项目作参考，因为它语法简单，执行方便，你需要的只是一个 python 环境</p><p>现在，拥有类似特性的 go 让我们多了一个选项，同样的需求，也可以看 go 社区有没有现成的方案。甚至 go 只需要编译好的可执行文件，更加方便</p><p>具体用哪个工具因需求而异，可以参考<a href="https://github.com/shockerli/go-awesome">别人的整理</a>，其中 <a href="https://github.com/shockerli/go-awesome?tab=readme-ov-file#%E7%BB%88%E7%AB%AF%E5%B7%A5%E5%85%B7">终端工具</a>、<a href="https://github.com/shockerli/go-awesome?tab=readme-ov-file#%E7%BD%91%E7%BB%9C">网络工具</a> 都有不错的项目参考，这里列几个可能比较常用的:</p><p><a href="https://github.com/gohugoio/hugo">hugo</a>: 博客网站生成，类似 hexo</p><p><a href="https://github.com/gobuffalo/buffalo">buffalo</a>: 快速生成 web 项目</p><p><a href="https://github.com/charmbracelet/vhs">vhs</a>: 终端录制</p><p><a href="https://github.com/Code-Hex/pget">pget</a>: 并发下载</p><p><a href="https://github.com/fsnotify/fsnotify">fsnotify</a>: 系统文件监听</p><p><a href="https://github.com/iawia002/lux">lux</a>: 网站视频下载工具（不能下载需要登录才能下的超高画质）</p><p><a href="https://github.com/golang-migrate/migrate">migrate</a>: 跨不同类型数据库迁移</p><h2 id="博客推荐"><a href="#博客推荐" class="headerlink" title="博客推荐"></a>博客推荐</h2><p>golang 在国内大厂实践还是比较多的，因此国内开发者写的博客也不会缺少。本着技术的学习方法来说，这里推荐两个博主 分别对应前沿动态，和深度剖析原理</p><p><a href="https://blog.csdn.net/EDDYCJY?type=blog">煎鱼</a>: go 语言开发者，对 go 社区动态、新版本特性的跟踪比较及时，类似的博主还有 <a href="https://polarisxu.studygolang.com/">polarisxu</a></p><p><a href="https://draveness.me/golang">go语言设计与实现</a>: go 原理和设计思想，这个博客对技术的思考方式值得应用到所有技术的学习上: 从为什么这么设计的问题基础上，去理解技术实现细节</p>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
          <category> golang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> golang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>树莓派搭建开发环境</title>
      <link href="/2023/10/15/rasp-dev/"/>
      <url>/2023/10/15/rasp-dev/</url>
      
        <content type="html"><![CDATA[<p><a href="https://mp.weixin.qq.com/s/sg8bsfQe3YK72_d3Ss8vyw">本文公众号</a></p><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>自从上次心血来潮给树莓派装完系统，一直没想好怎么具体使用它的场景，它就这样默默地躺在抽屉吃灰了一年</p><p>再次想起它，是一个周日的下午：收到之前在腾讯云买的云服务器快过期的提醒，一个4核8G内存的ubuntu，平时主要用它作为开发机，在本地电脑性能不够的时候，辅助 <strong>调试代码</strong>，以及 <strong>编译服务</strong> ，还是非常顺滑的</p><p>但随后登录控制台，一看续期的价格，同样性能比去年要贵个200多（去年 388，今年 646），横向对比了国内几个云厂商价格也都差不多，索性放弃续期了，想着有没有其他办法整个独立的开发环境呢？</p><p>让家里台式机一直跑着是种方法，windows 的 wsl 已经非常完善，完全可以当 linux 开发机用了</p><p>不过目前自己要跑的服务，也用不上台式机的性能，还有没有<strong>更轻量</strong>运行的方式呢？</p><p>这不就正好，终于可以重新唤醒尘封已久的树莓派咯。虽然4U4G的性能说不上绰绰有余，但就跑几个服务来说还是足够的</p><!--毕竟 windows 后台还要跑一堆其他东西，空闲时候比linux系统更耗电--><h2 id="本文内容"><a href="#本文内容" class="headerlink" title="本文内容"></a>本文内容</h2><ul><li><p>搭建开发环境（docker、各开发语言、code server）</p></li><li><p>文件服务器（samba）</p></li><li><p>监控（prometheus + grafana + node exporter）</p></li><li><p>远程桌面连接</p></li><li><p>智能开关</p></li><li><p>后续展望</p></li></ul><h2 id="系统准备"><a href="#系统准备" class="headerlink" title="系统准备"></a>系统准备</h2><p>我的树莓派上安装的是 ubuntu 22，通过 <a href="https://www.raspberrypi.com/news/raspberry-pi-imager-imaging-utility">raspberry pi imager</a>（官方刷系统工具）刷入系统并安装，具体的安装可以参考去年写的<a href="https://mp.weixin.qq.com/s/N6fEJuDNg5vYKcbl5x_7KA">博客</a></p><h2 id="安装开发环境"><a href="#安装开发环境" class="headerlink" title="安装开发环境"></a>安装开发环境</h2><p>笔者比较熟悉的开发模式: docker + 各语言开发环境 + <a href="https://mp.weixin.qq.com/s/H6QUS0CtW_qUBSdXTK8E_w">vscode</a>，在树莓派上原样进行安装</p><h3 id="docker"><a href="#docker" class="headerlink" title="docker"></a>docker</h3><p>安装 docker 的目的主要是能快速启动与主机环境隔离的容器，并进行服务编译。特别是编译 C++ 服务的时候，centos、ubuntu 这类的系统镜像自带的 gcc、glibc 版本往往不足要求，需要升级，但 <a href="https://zh.wikipedia.org/wiki/GNU_C%E5%87%BD%E5%BC%8F%E5%BA%AB">glibc</a> 的升级稍有操作不慎，又会对系统本身造成影响，所以还是建议在容器中编译相关服务</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 使用阿里源安装 docker</span></span><br><span class="line">curl -fsSL https://get.docker.com -o get-docker.sh</span><br><span class="line">sh get-docker.sh --mirror Aliyun</span><br></pre></td></tr></table></figure><p>安装后查看版本:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">❯ docker -v</span><br><span class="line">Docker version 24.0.7, build afdd53b</span><br></pre></td></tr></table></figure><p>关于在国内拉取容器镜像下载加速方式: 对不同的镜像仓库，如 <a href="https://hub.docker.com/search?image_filter=official">docker hub 官方镜像</a>、registry.k8s.io（kubernetes 相关服务的镜像仓库，旧域名是 <a href="https://kubernetes.io/blog/2022/11/28/registry-k8s-io-faster-cheaper-ga">k8s.gcr.io</a>）、quay.io（红帽镜像仓库）等，使用的仓库代理地址各有不同</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 原拉取镜像方式</span></span><br><span class="line">docker pull mysql:8.0.31</span><br><span class="line">docker pull registry.k8s.io/kube-apiserver:v1.17.3</span><br><span class="line">docker pull quay.io/dexidp/dex:v2.28.1</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 使用镜像仓库代理拉取方式</span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># docker hub 官方镜像: 设置中科大镜像加速器</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># 参考: https://mirrors.ustc.edu.cn/help/dockerhub.html</span></span></span><br><span class="line">tee /etc/docker/daemon.json &lt;&lt;-&#x27;EOF&#x27;</span><br><span class="line">&#123;</span><br><span class="line">  &quot;registry-mirrors&quot;: [&quot;https://docker.mirrors.ustc.edu.cn&quot;]</span><br><span class="line">&#125;</span><br><span class="line">EOF</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># 重启docker 后再拉取</span></span></span><br><span class="line">docker pull mysql:8.0.31</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># registry.k8s.io</span></span></span><br><span class="line">docker pull registry.aliyuncs.com/google_containers/kube-apiserver:v1.17.3</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># quay</span></span></span><br><span class="line">docker pull quay.mirrors.ustc.edu.cn/dexidp/dex:v2.28.1</span><br></pre></td></tr></table></figure><h3 id="各个语言的开发环境"><a href="#各个语言的开发环境" class="headerlink" title="各个语言的开发环境"></a>各个语言的开发环境</h3><p>关于各种开发语言如何安装环境，网上教程一大把，过程无外乎是下载和解压安装包、环境变量配置和下载源配置，熟悉了操作也快，但每次重装系统，或者基于一个基础镜像安装开发环境，都需要重新操作一遍还是挺麻烦的</p><p>笔者把常用语言和服务的安装脚本整理在 <a href="https://github.com/smiecj/shell-tools">shell-tools</a> 这个仓库了，可以直接一行指令帮我安装，还可以指定需要安装的版本</p><p>比如安装 go、java、python 和 nodejs:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> go_version: 指定版本，默认版本在 Makefile.vars.version 中定义</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> NET=CN: go 安装包将从国内源加速下载，并在安装后设置 GOPROXY 为 goproxy.cn</span></span><br><span class="line">NET=CN go_version=1.21.4 make golang</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 将安装 jdk1.8 (默认开发环境 JAVA_HOME)、jdk17（vscode java 插件使用）、maven、gradle</span></span><br><span class="line">NET=CN make java</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 将安装 conda、python 3.12</span></span><br><span class="line">NET=CN python3_version=3.12 make python3</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 将安装 nodejs 18.16.1</span></span><br><span class="line">NET=CN nodejs_version=v18.16.1 make nodejs</span><br></pre></td></tr></table></figure><p>升级 gcc、glibc，也可以使用这个脚本</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 升级 gcc 到 12.3.0</span></span><br><span class="line">NET=CN gcc_version=12.3.0 make gcc</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 升级 glibc 到 2.35</span></span><br><span class="line">NET=CN glibc_version=2.35 make glibc</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> glibc 的默认安装地址为 /usr/<span class="built_in">local</span>，因此使用前需要设置环境变量，把 /usr/<span class="built_in">local</span>/lib 放到前面</span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># 参考: https://unix.stackexchange.com/a/67783</span></span></span><br><span class="line">export LD_LIBRARY_PATH=/usr/local/lib:/usr/local/lib64:/lib</span><br></pre></td></tr></table></figure><h3 id="code-server"><a href="#code-server" class="headerlink" title="code server"></a>code server</h3><p>关于 vscode 之前写过常用插件的介绍，远程开发模式下，本地装 vscode，通过 remote ssh 连接到远端服务器，再安装各个开发语言的插件，体验还是很丝滑的</p><p><img src="/2023/10/15/rasp-dev/01.png" alt="local architecture"></p><p>架构如<a href="https://code.visualstudio.com/docs/remote/faq#_how-do-the-remote-development-extensions-work">上图</a>: 本地运行 vscode 的前端UI框架，后台服务器自动运行 vscode server，负责具体项目和具体开发语言的插件的运行，并提供 debugger、terminal 等功能</p><p>更进一步，我们还可以直接在远端服务器安装 <a href="https://coder.com/docs/code-server/latest">code server</a>，它是 vscode 的在线版，相当于UI服务也在服务器上运行，直接通过浏览器就能打开了</p><p><img src="/2023/10/15/rasp-dev/code-server-architecture.png" alt="local and remote architecture"></p><p>vscode 和 code server 的对比如<a href="https://insujang.github.io/2019-11-10/code-server">上图</a>，区别就是 nodejs（即 UI）也是运行在服务器上的，本机只需打开浏览器即可</p><p>code server 在树莓派的安装和配置方式如下:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 通过 shell-tools 安装 code server 4.19.0</span></span><br><span class="line">code_server_version=4.19.0 make code-server</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 配置: /opt/modules/code-server-4.18.0-linux-arm64/config.yaml</span></span><br><span class="line">bind-addr: 0.0.0.0:8080</span><br><span class="line">auth: password</span><br><span class="line">password: codeserver</span><br><span class="line">cert: false</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 启动</span></span><br><span class="line">nohup /opt/modules/code-server-4.19.0-linux-arm64/bin/code-server --config /opt/modules/code-server-4.19.0-linux-arm64/config.yaml &gt; /dev/null 2&gt;&amp;1 &amp;</span><br></pre></td></tr></table></figure><p>之后打开 http://树莓派内网ip:8080 就能开始愉快地享受网页版 vscode 了</p><p><img src="/2023/10/15/rasp-dev/05.png" alt="code server 效果"></p><p>扩展: 如果你想把 code server 提供给小伙伴们一起使用，配置就比较麻烦了，需要加一层 <a href="https://coder.com/docs/code-server/latest/guide#external-authentication">oauth proxy</a> 或其他代理，以支持多用户登录。 <a href="https://github.com/jupyterhub/jupyter-server-proxy">jupyterhub</a> 也是一种选择，后续有机会可以写写具体怎么做</p><!--### minikube后续: 测试 jupyter--><h2 id="文件服务器"><a href="#文件服务器" class="headerlink" title="文件服务器"></a>文件服务器</h2><p>除了用于开发，树莓派作为常驻 linux 主机，还可以安装 samba 并作为文件服务器，视频、音乐等媒体统一放到一块硬盘上，作为本地的媒体库</p><h3 id="samba"><a href="#samba" class="headerlink" title="samba"></a>samba</h3><p>samba 服务对应的 <a href="https://baike.baidu.com/item/samba/455025">SMB</a>（Server Message Block） 是一种在局域网中共享文件的协议，直接说下它在linux系统的安装方法</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 安装 samba，并添加 samba 的访问用户（注意和系统用户不同）</span></span><br><span class="line">apt -y install samba samba-common-bin</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 添加用于登录 samba 的用户: pi, 并设置密码</span></span><br><span class="line">smbpasswd -a pi</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 激活用户</span></span><br><span class="line">smbpasswd -e pi</span><br></pre></td></tr></table></figure><p>安装后，在 /etc/samba/smb.conf 中配置开放访问的目录</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># vim /etc/samba/smb.conf</span></span><br><span class="line"></span><br><span class="line"><span class="section">[music]</span></span><br><span class="line"><span class="attr">path</span> = /data/music</span><br><span class="line"><span class="attr">writeable</span>=<span class="literal">Yes</span></span><br><span class="line">valid <span class="attr">users</span> = pi</span><br><span class="line">create <span class="attr">mask</span>=<span class="number">0777</span></span><br><span class="line">directory <span class="attr">mask</span>=<span class="number">0777</span></span><br><span class="line"><span class="attr">public</span>=<span class="literal">yes</span></span><br><span class="line"><span class="attr">browseable</span>=<span class="literal">yes</span></span><br></pre></td></tr></table></figure><h3 id="挂载机械硬盘"><a href="#挂载机械硬盘" class="headerlink" title="挂载机械硬盘"></a>挂载机械硬盘</h3><p>在尝试把之前买的机械硬盘（作为媒体数据盘）挂载到树莓派的时候，遇上了一点小问题: 硬盘格式已经是 NTFS 并且放了一些数据了，但linux 系统无法直接读取，需要安装 <a href="https://zh.wikipedia.org/wiki/NTFS-3G">ntfs-3g</a> 驱动才行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt -y install ntfs-3g</span><br></pre></td></tr></table></figure><p>并在 /etc/fstab 中设置开机自动挂盘，参考</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/dev/sdb1       /data/music   ntfs-3g defaults,nofail,uid=1000,gid=1000,umask=0007,x-systemd.device-timeout=5         0       0</span><br></pre></td></tr></table></figure><h2 id="远程桌面"><a href="#远程桌面" class="headerlink" title="远程桌面"></a>远程桌面</h2><p>对 linux 系统来说，平时开发写写代码敲敲指令，是不太需要访问桌面的。不过有时想体验 linux 版的应用（QQ），还是可以装个远程桌面来体验一下</p><p>常见的远程桌面协议是 xrdp 和 vnc，这里我们通过 xrdp 来配置:</p><!--[参考-Installing an XRDP Server on Ubuntu 20.04](https://www.shells.com/l/en-US/tutorial/Installing-an-XRDP-Server-on-Ubuntu-20-04)[xrdp](https://github.com/neutrinolabs/xrdp): 远程桌面协议（RDP）的一种开源实现[xfce](https://zh.wikipedia.org/zh-cn/Xfce): 一个轻量的 unix 桌面版[lxde](https://zh.wikipedia.org/wiki/LXDE): 一种轻量而快速的桌面环境--><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 安装 xrdp</span></span><br><span class="line">apt -y install xrdp</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 安装 lxde cinnamon 桌面</span></span><br><span class="line">apt -y install lxde cinnamon-desktop-environment</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> xsession 在用户登录桌面系统后被执行，可用于定制化桌面</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 参考: https://unix.stackexchange.com/a/47426</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 使用 cinnamon 作为桌面</span></span><br><span class="line">echo cinnamon &gt; ~/.xsession</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># 修改 /etc/xrdp/startwm.sh 并在 &quot;fi&quot; 和 “test -x” 中间加3行</span></span></span><br><span class="line">unset DBUS_SESSION_BUS_ADDRESS</span><br><span class="line">unset XDG_RUNTIME_DIR</span><br><span class="line">startlxde</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 启动 xrdp</span></span><br><span class="line">systemctl start xrdp</span><br><span class="line"><span class="meta">#</span><span class="bash"> 或: /etc/init.d/xrdp restart</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 开机自启动</span></span><br><span class="line">systemctl enable xrdp</span><br></pre></td></tr></table></figure><p>xrdp 的端口 3389 可以在 /etc/xrdp/xrdp.ini 配置中查看和修改</p><p>然后通过 microsoft remote desktop 连接:</p><p><img src="/2023/10/15/rasp-dev/06.png" alt="桌面"></p><p>非常简洁的桌面</p><p>然后我们可以安装新版适配了 linux 的 QQ，从<a href="https://im.qq.com/linuxqq/index.shtml">官网</a>下载</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 下载</span></span><br><span class="line">wget https://dldir1.qq.com/qqfile/qq/QQNT/2355235c/linuxqq_3.1.1-11223_arm64.deb</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 安装</span></span><br><span class="line">dpkg -i linuxqq_3.1.1-11223_arm64.deb</span><br></pre></td></tr></table></figure><!--参考: https://cloud.tencent.com/developer/article/2301512--><h2 id="监控"><a href="#监控" class="headerlink" title="监控"></a>监控</h2><p>到这一步，我们给树莓派装的开发环境算是基本弄好了，可以愉快地在上面构建镜像、运行服务，不过摸着那微微发烫的 cpu，担心也随之而来: 是不是有个好看的面板，能直接看到当前树莓派的状态，做个监控更好呢？</p><p>那就话不多说，开始整看板吧</p><h3 id="获取树莓派的性能指标"><a href="#获取树莓派的性能指标" class="headerlink" title="获取树莓派的性能指标"></a>获取树莓派的性能指标</h3><!--[Parsing the GPU temperature outputs](https://www.cyberciti.biz/faq/linux-find-out-raspberry-pi-gpu-and-arm-cpu-temperature-command/)--><p>先来看看命令行获取树莓派 cpu 的温度的方式:</p><p><a href="https://blog.csdn.net/lakeheart879/article/details/77336393">参考-使用 vcgencmd 指令查看 Raspberry Pi 的 CPU 溫度、運行速度與電壓等資訊</a></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vcgencmd measure_temp | grep  -o -E &#x27;[[:digit:]].*&#x27;</span><br></pre></td></tr></table></figure><p><img src="/2023/10/15/rasp-dev/07.png" alt="cpu 温度"></p><p>vcgencmd 指令是基于树莓派的内核 <a href="https://github.com/raspberrypi/firmware">firmware</a> 自带的指令，能拿到关于系统资源和硬件状态相关信息，如时钟频率、电压、内存等</p><p>但通过指令获取参数的方式，采集起来需要额外写脚本，相比 exporter 的方式来说还是不太方便，那么有没有原生的 exporter 可以直接拿到温度数据呢？</p><h3 id="node-exporter"><a href="#node-exporter" class="headerlink" title="node exporter"></a>node exporter</h3><p>前面说的系统指令只是粗略看看 cpu 的指标，要想持续监控，还得通过 prometheus 采集、exporter 提供系统指标的机制，把相关指标提前暴露出来</p><p><a href="https://github.com/prometheus/node_exporter">node exporter</a> 是提供系统相关监控指标的服务，在树莓派上部署它的 arm 版本后，可通过 <strong>node_thermal_zone_temp</strong> 指标获取温度，数据来源是系统文件 /sys/class/thermal/thermal_zone0/temp 即由系统直接提供的 cpu 温度数据</p><h3 id="部署-prometheus、node-exporter-和-grafana"><a href="#部署-prometheus、node-exporter-和-grafana" class="headerlink" title="部署 prometheus、node exporter 和 grafana"></a>部署 prometheus、node exporter 和 grafana</h3><p>继续使用 shell-tools 工具一键安装</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 安装 prometheus 和 node exporter</span></span><br><span class="line">prometheus_version=2.45.0 node_exporter_version=1.6.1 NET=CN make prometheus</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 安装 grafana</span></span><br><span class="line">grafana_version=10.2.0 NET=CN make grafana</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 启动</span></span><br><span class="line">/opt/modules/prometheus/prometheus --web.enable-lifecycle --config.file=/opt/modules/prometheus/prometheus.yml --web.listen-address=:3001</span><br><span class="line"></span><br><span class="line">/opt/modules/grafana/bin/grafana-server --homepath /opt/modules/grafana --config /opt/modules/grafana/conf/custom.ini</span><br><span class="line"></span><br><span class="line">/opt/modules/node_exporter/node_exporter --web.listen-address=&quot;:9100&quot;</span><br></pre></td></tr></table></figure><p>安装后，在 prometheus 配置文件中添加 node exporter 的本地地址即可开始采集指标</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># vim /opt/modules/prometheus/prometheus.yml</span></span><br><span class="line"></span><br><span class="line"><span class="attr">scrape_configs:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">job_name:</span> <span class="string">&quot;node_exporter&quot;</span></span><br><span class="line">    <span class="attr">static_configs:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">targets:</span> [<span class="string">&quot;localhost:9100&quot;</span>] <span class="comment"># node exporter 地址</span></span><br></pre></td></tr></table></figure><h3 id="prometheus-对接-grafana"><a href="#prometheus-对接-grafana" class="headerlink" title="prometheus 对接 grafana"></a>prometheus 对接 grafana</h3><p>采集到指标后，关键的一步就是用“酷炫”的grafana看板展示出来，让我们能及时看到系统状态</p><p>node exporter 的官方的看板是 <a href="https://grafana.com/grafana/dashboards/1860-node-exporter-full">node exporter full</a>，分类非常详细，导入看板的 json 文件，并添加 prometheus 数据源（localhost:3001）即可</p><p><img src="/2023/10/15/rasp-dev/10.png" alt="导入看板"></p><p><img src="/2023/10/15/rasp-dev/11.png" alt="选择 prometheus 数据源"></p><p><img src="/2023/10/15/rasp-dev/04.png" alt="看板效果"></p><!--嵌入式Linux下获取CPU温度方法https://blog.csdn.net/qq_20553613/article/details/107703442--><h2 id="开机服务自动启动"><a href="#开机服务自动启动" class="headerlink" title="开机服务自动启动"></a>开机服务自动启动</h2><p>前面我们给树莓派已经安装了一系列服务，那么有时候树莓派要重启，我们会想让这些服务也在系统重启后自动启动。docker 这种通过 systemctl 管理的服务，直接执行 systemctl enable docker 就可以了，手动安装的 code server 、prometheus，应该怎么配置呢？</p><p>方法也有很多种，常见的有: rc.local、init.d、crontab @reboot 等方法，它们执行的时机各有不同</p><p><a href="https://shumeipai.nxez.com/2023/05/13/run-a-program-on-your-raspberry-pi-at-startup.html">参考-在树莓派上设置应用程序开机启动的五种方法</a></p><h3 id="什么时候触发执行"><a href="#什么时候触发执行" class="headerlink" title="什么时候触发执行"></a>什么时候触发执行</h3><p>linux 系统启动后，<a href="https://access.redhat.com/documentation/zh-cn/red_hat_enterprise_linux/4/html/reference_guide/s2-boot-init-shutdown-init">/sbin/init</a> 脚本会进行一众系统服务的初始化，顺序我们可以通过 systemd-analyze plot &gt; startup_order.svg 导出，一些自动启动的脚本启动顺序如下:</p><p>/etc/init.d: 最先初始化的一批系统服务</p><!--顺序依赖于服务配置，和 systemd 服务的定义方式类似，可以通过编写 --><p>rc.local: network 即网络服务启动之后</p><p>crontab @reboot: network 启动之前</p><!-- --><p>为什么要特别提到启动顺序，因为有的服务依赖网络相关的基础服务（如网卡初始化），如果通过 /etc/init.d 或是 crontab @reboot 很可能启动失败。相对比，rc.local 的启动顺序较后，可以保证在系统基础服务启动后开始。另外从配置方式来看，systemctl 和 /etc/init.d 都需要基于一定的格式规范，如服务名、依赖哪些服务等，rc.local 则直接写入服务的启动指令即可</p><p>下面我们来看看 rc.local 如何配置</p><h3 id="rc-local-添加服务启动指令"><a href="#rc-local-添加服务启动指令" class="headerlink" title="rc.local 添加服务启动指令"></a>rc.local 添加服务启动指令</h3><p>root 用户下编辑 /etc/rc.local 文件，添加服务的启动指令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> vim /etc/rc.local</span></span><br><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 启动 prometheus</span></span><br><span class="line">nohup /opt/modules/prometheus/prometheus --web.enable-lifecycle --config.file=/opt/modules/prometheus/prometheus.yml --web.listen-address=:3001 &gt; /dev/null 2&gt;&amp;1 &amp;</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 启动 grafana</span></span><br><span class="line">nohup /opt/modules/grafana/bin/grafana-server --homepath /opt/modules/grafana --config /opt/modules/grafana/conf/custom.ini &gt; /dev/null 2&gt;&amp;1 &amp;</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 启动 node exporter</span></span><br><span class="line">nohup /opt/modules/node_exporter/node_exporter --web.listen-address=&quot;:9100&quot; &gt; /dev/null 2&gt;&amp;1 &amp;</span><br></pre></td></tr></table></figure><p>之后通过 chmod +x /etc/rc.local 添加可执行文件，重启树莓派再次登录，可以看到相关服务已经运行起来了</p><p>另一个注意点是 rc.local 中的指令是串行执行，前面的指令报错，后面的也不会执行，所以也建议通过 nohup 即后台方式启动服务</p><!--另外看一些帖子，即使 rc.local 执行顺序在 network 之后，在启动时执行 wget 下载依然有概率失败service networking restartsystemctl status networkingoneshot: https://askubuntu.com/a/1072463/etc/network/if-up.d: https://askubuntu.com/a/431449关于脚本执行: https://askubuntu.com/a/243083--><h2 id="智能插座"><a href="#智能插座" class="headerlink" title="智能插座"></a>智能插座</h2><p>毕竟性能有限，随着我们在树莓派上部署的服务越来越多，也难免会遇到资源用尽，直接卡住无法连接的情况，除了重启没有别的恢复办法</p><p>好几次在外面远程连接家里树莓派，跑了几个比较吃资源的服务卡住之后，又没法重启，真的是很无奈，索性搞了个小米智能插座，感受了一波物联网带来实际的便利</p><p><img src="/2023/10/15/rasp-dev/08.jpeg" alt="只够插一个插头的位置，稍显不足"></p><p><img src="/2023/10/15/rasp-dev/09.png" alt="还能看到供电量"></p><h2 id="后续展望"><a href="#后续展望" class="headerlink" title="后续展望"></a>后续展望</h2><p>经过了一个多月的折腾，我的树莓派终于可以作为开发服务器长期跑起来了。相比开头说的云服务器，性能方面稍弱，但也带来可以对接本地数据、可随时在手机端重启等好处</p><p>之后还能在上面跑什么服务，或者还能和现实世界有什么交互呢？我也还没有特别想好，就粗略地列一列零散的点子吧，看看以后有没有时间继续折腾一下</p><!--本地运行一些定时服务，构建镜像，运行服务，备份数据等（如监控数据）系统备份: 前面的安装服务、修改服务配置和系统配置相关的操作，如果--><p>nas: 我是真没想到竟然真有人去把树莓派当作 nas，<a href="https://post.smzdm.com/p/a4p6d8r8">参考</a>，数据传输速度上的瓶颈应该还是挺明显的，当作小型文件服务器才比较现实</p><p>本地文档库+媒体库: 归档自己所有的音乐、相册、视频、电子书等</p><p>传感器: 搞个空气质量检测器，<a href="https://www.cirmall.com/articles/35968">参考</a></p><!--找一套物联网框架https://www.xiaoweigod.com/network/2235.htmlhttps://iot.mi.com/new/doc/accesses/direct-access/other-platform-access/control-api --><!--## 最后谨以这篇不那么硬核的技术文章，献给激励我创作的动力来源，总是拥有古灵精怪的魅力，今天全世界最独一无二的男人，新婚快乐！-->]]></content>
      
      
      <categories>
          
          <category> 生活 </category>
          
          <category> 树莓派 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> 树莓派 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>致命一击</title>
      <link href="/2023/10/08/vaundy-todome/"/>
      <url>/2023/10/08/vaundy-todome/</url>
      
        <content type="html"><![CDATA[<p><a href="https://mp.weixin.qq.com/s/CtuwmCKu_vpPKDhfkVD0kw">本文公众号</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><span class="line">トドメの一撃</span><br><span class="line">作词 &amp; 作曲 &amp; 编曲: Vaundy</span><br><span class="line"></span><br><span class="line">視界に目前映る深い真紅</span><br><span class="line">この先およそ40000 kilometer</span><br><span class="line"></span><br><span class="line">飘入眼中的，是那抹深邃的暗红</span><br><span class="line">在我们前方，仿佛还有四万公里的漫漫长路</span><br><span class="line"></span><br><span class="line">後ろに迫る互いの傷が</span><br><span class="line">迷う道をさらに迷わせてく</span><br><span class="line">見えず匂わぬ</span><br><span class="line">違えぬ未来が</span><br><span class="line">背中を突いた!</span><br><span class="line"></span><br><span class="line">紧紧追随着我们，曾经给彼此的伤害</span><br><span class="line">让原本就迷茫的前途，更加扑朔迷离</span><br><span class="line">看不见摸不着</span><br><span class="line">彼此截然不同的未来</span><br><span class="line">突然冲向我的后背</span><br><span class="line"></span><br><span class="line">だから</span><br><span class="line">今日の夜は隣にいさせて</span><br><span class="line">隣にいさせて</span><br><span class="line">今夜だけは本気だからね</span><br><span class="line">本気にさせて</span><br><span class="line">こっちにきてもっと</span><br><span class="line">祈りあった未来とて、道が違うのよ アナタ</span><br><span class="line">アナタ ああ</span><br><span class="line">互いの殺意で トドメ喰らっちゃうね</span><br><span class="line">やっぱりやめとくわ</span><br><span class="line"></span><br><span class="line">所以啊</span><br><span class="line">今晚就待在我身边吧</span><br><span class="line">让我在你身边</span><br><span class="line">这份认真只限今夜哦</span><br><span class="line">接受这份真心吧</span><br><span class="line">再过来一点</span><br><span class="line">一同期待的未来，但路途些许不同的你哦</span><br><span class="line">亲爱的你啊</span><br><span class="line">就让我们带上对彼此的杀意，使出致命一击，相迎对方吧</span><br><span class="line">想想还是算了吧</span><br><span class="line"></span><br><span class="line">行く、万年の困難が待つ道</span><br><span class="line">内、四千は光死ぬ常闇</span><br><span class="line">さらに続き、絶えぬ更地</span><br><span class="line">そこに現れた 心見透かすちっぽけな魂</span><br><span class="line">それは散らばるミクロ砂金手のひらに集め</span><br><span class="line">密度高め万年を照らす光の矢を放つ、穿つ</span><br><span class="line"></span><br><span class="line">出发吧，前方等待着的是万年荆棘之路</span><br><span class="line">仔细看，还有那千年都未曾照亮的地狱</span><br><span class="line">再继续，只会是无穷无尽的荒地</span><br><span class="line">未曾想，这里竟然出现了看透我们内心的一只微小灵魂</span><br><span class="line">那是无数细散的沙子，在手中凝聚</span><br><span class="line">放出了足以照亮万年天空的光芒，穿透内心</span><br><span class="line"></span><br><span class="line">こういうのとか</span><br><span class="line">そういうのとか</span><br><span class="line">偽物じゃできないよね</span><br><span class="line"></span><br><span class="line">这样的微微小事</span><br><span class="line">那样的丝丝温馨</span><br><span class="line">凭虚伪之物，可是做不到的哦</span><br><span class="line"></span><br><span class="line">だから</span><br><span class="line">今日の夜は隣にいさせて</span><br><span class="line">隣にいさせて</span><br><span class="line">今夜だけは本気だからね</span><br><span class="line">本気にさせて</span><br><span class="line">こっちにきてもっと</span><br><span class="line">祈りあった未来とて、道が違うのよ アナタ</span><br><span class="line">アナタ ああ</span><br><span class="line">互いの殺意で トドメ喰らっちゃうね</span><br><span class="line">やっぱりやめとくわ</span><br><span class="line"></span><br><span class="line">所以啊</span><br><span class="line">今晚就待在我身边吧</span><br><span class="line">让我在你身边</span><br><span class="line">我的认真只限今夜哦</span><br><span class="line">接受这份真心吧</span><br><span class="line">再过来一点</span><br><span class="line">一同期待的未来，但路途些许不同的你哦</span><br><span class="line">亲爱的你啊</span><br><span class="line">就让我们带上对彼此的杀意，使出致命一击，相迎对方吧</span><br><span class="line">想想还是算了吧</span><br><span class="line"></span><br><span class="line">もしもどこまでも続くなら</span><br><span class="line">せめて今日の一度だけ</span><br><span class="line"></span><br><span class="line">如果啊，我们之间的故事，不管怎样都会继续下去</span><br><span class="line">哪怕只有今宵佳日，也尽情地依靠我吧！</span><br><span class="line"></span><br><span class="line">今日の夜はワタシにさせて</span><br><span class="line">ワタシにさせて</span><br><span class="line">今夜だけはワタシに守らせて</span><br><span class="line">今日の夜が</span><br><span class="line">明けたころに 待ち合わせね</span><br><span class="line">明日の夜も守れますように</span><br><span class="line">こっちにきてもっと</span><br><span class="line">祈りあった未来とて、道が違うのよ アナタ</span><br><span class="line">こっちにきてもっと</span><br><span class="line">アナタ ああ</span><br><span class="line">互いの殺意で トドメ喰らっちゃうね</span><br><span class="line"></span><br><span class="line">今晚就陪在我身边吧！</span><br><span class="line">一切都交给我吧</span><br><span class="line">哪怕只有今夜，也让我好好守护你吧！</span><br><span class="line">如此美妙之夜啊！</span><br><span class="line">到破晓之时，我们继续约会吧</span><br><span class="line">只为明夜，也能一直守护着你</span><br><span class="line">再靠近我一点吧！</span><br><span class="line">一同期待的未来，但路途些许不同的你</span><br><span class="line">就让我再靠近你一点吧！</span><br><span class="line">亲爱的你啊</span><br><span class="line">带上对彼此的杀意，用致命一击迎接对方吧！</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 音乐 </category>
          
          <category> Vaundy </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 音乐 </tag>
            
            <tag> 日语 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>暮色与京都</title>
      <link href="/2023/09/18/japan-travel-note-kyoto/"/>
      <url>/2023/09/18/japan-travel-note-kyoto/</url>
      
        <content type="html"><![CDATA[<p><a href="https://mp.weixin.qq.com/s/6IF1jnZjwDrqeqZX08XakQ">本文公众号地址</a></p><h2 id="伏见稻荷神社"><a href="#伏见稻荷神社" class="headerlink" title="伏见稻荷神社"></a>伏见稻荷神社</h2><p>傍晚和伏见稻荷神社真的是绝配</p><p>和东京的神社，那种与都市融为一体的神社不同，伏见稻荷神社尽管也在京都城区，但给人的感觉却是真正的远离了城市的喧嚣</p><p><img src="/2023/09/18/japan-travel-note-kyoto/kyoto-01.JPG" alt="伏见稻荷神社"></p><p><img src="/2023/09/18/japan-travel-note-kyoto/kyoto-02.JPG" alt="伏见稻荷神社"></p><h2 id="天津饭"><a href="#天津饭" class="headerlink" title="天津饭"></a>天津饭</h2><p>和天津没有什么关系的天津饭，口味也真的很难适应，日料到底还能有多咸，恐怕我也是想象不到了</p><p><img src="/2023/09/18/japan-travel-note-kyoto/kyoto-03.JPG" alt="伏见稻荷神社"></p><h2 id="玉子市场"><a href="#玉子市场" class="headerlink" title="玉子市场"></a>玉子市场</h2><p>来到了玉子和饼藏的名场面之地，虽然没有感受到夕阳西下的氛围，但是跳大乌龟的经历也足够让我记住飛び石这个地名了</p><p>奋力跃过飛び石，再往前走一点就是民风淳朴的“玉子市场”（出町桝形商店街），上午的商业街还略显安静，走走停停，又感觉或许安静平和才是真正专属这条商业街的氛围。动漫里商业街的熙熙攘攘也存在，只是藏在各个角落中，需要慢慢去找寻</p><p><img src="/2023/09/18/japan-travel-note-kyoto/kyoto-04.JPG" alt="飛び石"></p><p><img src="/2023/09/18/japan-travel-note-kyoto/kyoto-05.JPG" alt="飛び石"></p><p><img src="/2023/09/18/japan-travel-note-kyoto/kyoto-06.JPG" alt="似乎每天都会充满活力的商业街"></p><p><img src="/2023/09/18/japan-travel-note-kyoto/kyoto-07.JPG" alt="佑子！"></p><p><img src="/2023/09/18/japan-travel-note-kyoto/kyoto-08.JPG" alt="佑子的那个段子属实没看懂"></p><!-- https://m.youtube.com/watch?v=u8GjG51XzJ8 --><p><img src="/2023/09/18/japan-travel-note-kyoto/kyoto-09.JPG" alt="有点不好找的迪拉"></p><h2 id="二年坂三年坂"><a href="#二年坂三年坂" class="headerlink" title="二年坂三年坂"></a>二年坂三年坂</h2><p>熙熙攘攘的小长街，逛不完的小吃，需要耐心去发现惊喜的伴手礼店</p><p>去清水寺的必经之路，值得回味每一个转角，值得期待每次回头的那瞬间，看着坡下熙熙攘攘的人群和两边的商店融为一体，仿佛在东京之外，找到了人和自然的另一种共存方式</p><p><img src="/2023/09/18/japan-travel-note-kyoto/kyoto-11.JPG" alt="二年坂"></p><p><img src="/2023/09/18/japan-travel-note-kyoto/kyoto-14.JPG" alt="边走边在纪念品店乘凉，生肖不倒翁挺可爱的"></p><p>![快到清水寺，俯瞰上来的路](kyoto-13 .JPG)</p><h2 id="清水寺"><a href="#清水寺" class="headerlink" title="清水寺"></a>清水寺</h2><p>到清水寺刚好是正午，充分感受了一波猛烈的夏日，实在是没有再上清水舞台的欲望了，还是就给远处的京都之景打个卡吧</p><p><img src="/2023/09/18/japan-travel-note-kyoto/kyoto-13.JPG" alt="远眺京都"></p>]]></content>
      
      
      <categories>
          
          <category> 旅游 </category>
          
          <category> 日本 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 旅游 </tag>
            
            <tag> 日本 </tag>
            
            <tag> 日记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>鹿横行注意！</title>
      <link href="/2023/09/18/japan-travel-note-nara/"/>
      <url>/2023/09/18/japan-travel-note-nara/</url>
      
        <content type="html"><![CDATA[<p><a href="https://mp.weixin.qq.com/s/yv01ZUx2JthX30od-AtdLw">本文公众号地址</a></p><p>真的被鹿包围了</p><p><img src="/2023/09/18/japan-travel-note-nara/nara-05.JPG" alt="鹿饼"></p><p><img src="/2023/09/18/japan-travel-note-nara/nara-04.JPG" alt="鹿"></p><p><img src="/2023/09/18/japan-travel-note-nara/nara-01.JPG" alt="鹿"></p><p><img src="/2023/09/18/japan-travel-note-nara/nara-02.JPG" alt="东大寺"></p><p>网上看到一种说法，鹿吃鹿饼，其实是为了讨人类欢心</p><p>还真的从小鹿的身上验证了。别的鹿都像猎物一般地扫视周围有鹿饼的人，但小鹿对此毫无兴趣，递到它们嘴边的鹿饼都不吃，似乎只有青青草地才是它们的钟爱</p><p><img src="/2023/09/18/japan-travel-note-nara/nara-03.JPG" alt="人与自然的和谐共处"></p><p>最后在回程路上，还看到了如此和谐的一幕：共同生活，但又有各自的世界，或许这才是人与自然真正的和谐共处方式</p>]]></content>
      
      
      <categories>
          
          <category> 旅游 </category>
          
          <category> 日本 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 旅游 </tag>
            
            <tag> 日本 </tag>
            
            <tag> 日记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>大阪之烟火气</title>
      <link href="/2023/09/18/japan-travel-note-oosaka/"/>
      <url>/2023/09/18/japan-travel-note-oosaka/</url>
      
        <content type="html"><![CDATA[<p><a href="https://mp.weixin.qq.com/s/M8P4swRyiDYdU2Fb8M6c3g">本文公众号地址</a></p><p>要说东京和大阪有什么区别，从旅游者的角度来说还真体验不太出来，都是一线城市，都有很繁华的地方和朴素的居民区，工作和生活每天都交织在一起</p><p>但大阪的生活，是那种真正和工作区分开的生活，称得上慢节奏，东京的生活感和这座城市紧密相关，而说到大阪则必定离不开大阪人</p><h3 id="心斋桥和道顿堀"><a href="#心斋桥和道顿堀" class="headerlink" title="心斋桥和道顿堀"></a>心斋桥和道顿堀</h3><p>从心斋桥开始，走过长长的一段街道，两边是各种店铺，有点像在京都那时逛的商业街，不过显然免税店和化妆品店更多点</p><p><img src="/2023/09/18/japan-travel-note-oosaka/oosaka-02.JPG" alt="心斋桥"></p><p>到了格力高，很想拍一张不带人的照片，但实在是没办法 😂 看来台风刚过也不能阻挡大家来打卡的热情</p><p><img src="/2023/09/18/japan-travel-note-oosaka/oosaka-01.JPG" alt="格力高"></p><p>在这里的一家小店点了点秋葵烤肉和薯条，都挺下酒的。不过最最下酒的还得是咸乌贼（日语：塩辛　しおから）这道菜。光看中文菜名根本感受不到它的威力。托它的福，让我把这一大杯酒喝完毫不费劲（其实吃完还是有点撑了）</p><p><img src="/2023/09/18/japan-travel-note-oosaka/oosaka-03.JPG" alt="生啤喝得还是舒服"></p><p><img src="/2023/09/18/japan-travel-note-oosaka/oosaka-04.JPG" alt="左上角最佳下酒菜"></p><h3 id="大阪城"><a href="#大阪城" class="headerlink" title="大阪城"></a>大阪城</h3><p>天守阁象征了关西曾经是日本的中心，不过毕竟是翻修过的，历史感差点味</p><p>反倒是路边摊小哥的热情让我印象深刻，每想起 3 位小哥在我说买一杯刨冰之后，笑着说“一杯吗？真的只要一杯吗？No no no，three！”都忍不住放松地笑，大阪人的热情真的是名副其实</p><p><img src="/2023/09/18/japan-travel-note-oosaka/oosaka-05.JPG" alt="大阪城"></p><p><img src="/2023/09/18/japan-travel-note-oosaka/oosaka-06.JPG" alt="天守阁远眺"></p><h3 id="大阪烧"><a href="#大阪烧" class="headerlink" title="大阪烧"></a>大阪烧</h3><p>说到热情，大阪烧同样有它的热情直爽，烤得干脆的面饼，软糯的年糕，虾肉和牛杂的共同点缀，成就了这样一道本地特色菜</p><p>不过我也注意到旁边的那对情侣，比我们进来得晚一点，但是点的菜和我们完全不同，一直在点小菜，有烤章鱼，烤玉米，炒面什么的。两人也一直有说有笑，边烤边吃，似乎正享受着他们专属的下班时光</p><p><img src="/2023/09/18/japan-travel-note-oosaka/oosaka-07.JPG" alt="米酒越喝越有"></p><p><img src="/2023/09/18/japan-travel-note-oosaka/oosaka-08.JPG" alt="大阪烧"></p>]]></content>
      
      
      <categories>
          
          <category> 旅游 </category>
          
          <category> 日本 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 旅游 </tag>
            
            <tag> 日本 </tag>
            
            <tag> 日记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>golang 编程规范查漏补缺</title>
      <link href="/2023/09/11/golang-standard-company/"/>
      <url>/2023/09/11/golang-standard-company/</url>
      
        <content type="html"><![CDATA[<p><a href="https://blog.csdn.net/xiaoliizi/article/details/133747191">本文csdn</a></p><h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>公司最近出了 golang 语言规范，大部分参考 uber 的 go 语言规范（<a href="https://github.com/uber-go/guide/blob/master/style.md" title="原版">原版</a>和<a href="https://github.com/xxjwxc/uber_go_guide_cn" title="翻译">翻译</a>），以及官方的 <a href="https://go.dev/doc/effective_go" title="Effective Go">Effective Go</a>。这里分享一下自己之前没注意的点，查漏补缺</p><p>主要内容包括：go 语言特性中 defer、Mutex、interface 和 channel 的使用注意点，高性能场景中 string 和 byte 数组的相互转换，以及协程池的使用</p><h1 id="方法和函数"><a href="#方法和函数" class="headerlink" title="方法和函数"></a>方法和函数</h1><h2 id="defer-和返回值"><a href="#defer-和返回值" class="headerlink" title="defer 和返回值"></a>defer 和返回值</h2><p>对应知识点为方法返回值是有名还是无名的时候，defer 的顺序的差异</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">deferWithAnonymous</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">ret := <span class="number">1</span></span><br><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">ret++</span><br><span class="line">&#125;()</span><br><span class="line"><span class="keyword">return</span> ret</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">deferWithNamed</span><span class="params">()</span> <span class="params">(ret <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">ret = <span class="number">1</span></span><br><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">ret++</span><br><span class="line">&#125;()</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="built_in">println</span>(deferWithAnonymous()) <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">println</span>(deferWithNamed()) <span class="comment">// 2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>defer 和返回值之间的关系: <strong>设置函数返回值 -&gt; 执行 defer -&gt; 最终返回给调用方</strong></p><p>关键在第一步，匿名返回值函数中，设置的返回值就是具体的值，而在有名返回值函数，设置的是返回值的引用（即 ret 的引用）</p><p>所以有名返回值函数的 defer 会影响最后的返回值</p><p>对 defer 的编译后字节码解析可以参考<a href="https://dengchengchao.com/?p=1479" title="这篇文章">这篇文章</a></p><h2 id="sync-Mutex-作为传参的时候，需要传指针，否则可能导致死锁"><a href="#sync-Mutex-作为传参的时候，需要传指针，否则可能导致死锁" class="headerlink" title="sync.Mutex 作为传参的时候，需要传指针，否则可能导致死锁"></a>sync.Mutex 作为传参的时候，需要传指针，否则可能导致死锁</h2><p>Mutex 的加锁和释放锁逻辑是通过内部的s<strong>tate和sema两个整数对象</strong>控制的，直接拷贝 Mutex 只是复制了锁的状态，但和原来的锁并不是同一个，所以释放复制后的 Mutex 并不能解锁原来的 Mutex</p><p>一个复现这个问题的示例，是通过 pointer receiver 占锁，通过 value receiver 释放锁，由于 value receiver 会拷贝调用者对象，所以释放的锁对象和外面的不同，导致死锁</p><p><a href="https://medium.com/golangspec/detect-locks-passed-by-value-in-go-efb4ac9a3f2b" title="参考-Detect locks passed by value in Go">参考-Detect locks passed by value in Go</a></p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;sync&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> T <span class="keyword">struct</span> &#123;</span><br><span class="line">    lock sync.Mutex</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *T)</span> <span class="title">Lock</span><span class="params">()</span></span> &#123;</span><br><span class="line">    t.lock.Lock()</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t T)</span> <span class="title">Unlock</span><span class="params">()</span></span> &#123;</span><br><span class="line">   t.lock.Unlock()</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    t := T&#123;lock: sync.Mutex&#123;&#125;&#125;</span><br><span class="line">    t.Lock()</span><br><span class="line">    t.Unlock()</span><br><span class="line">    t.Lock() <span class="comment">// 死锁</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="基本类型"><a href="#基本类型" class="headerlink" title="基本类型"></a>基本类型</h1><h2 id="interface-的判空"><a href="#interface-的判空" class="headerlink" title="interface 的判空"></a>interface 的判空</h2><p>interface 表示 golang 的接口类型，它和其他语言的“基类”（如 Java 的 interface）相比，在空对象的判空和调用方法的表现上不太一样</p><p>示例代码: 思考以下代码会输出什么</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> MyError <span class="keyword">struct</span> &#123;</span><br><span class="line">msg <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(err *MyError)</span> <span class="title">Error</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> err.msg</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">workWithBalance</span><span class="params">()</span> <span class="title">bool</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">workTooHard</span><span class="params">()</span> <span class="title">bool</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getError</span><span class="params">(f <span class="keyword">func</span>()</span> <span class="title">bool</span>) <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> err *MyError</span><br><span class="line"><span class="keyword">if</span> !f() &#123;</span><br><span class="line">err = &amp;MyError&#123;</span><br><span class="line">msg: <span class="string">&quot;need relax&quot;</span>,</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> err := getError(workTooHard); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">println</span>(<span class="string">&quot;work too hard caused &quot;</span> + err.Error())</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> getError(workWithBalance) == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">println</span>(<span class="string">&quot;work with balance&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码对自定义错误 MyError 进行了判空，预期 getError(workWithBalance) 获取到的 error 为空，但结果却不为空（work with balance 不会打印）</p><p>那么为什么声明未赋值的 err 判空得到的是 false 呢？我们可以从 interface 的内部结构 iface、eface 可以了解到端倪</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// runtime/runtime2.go</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> eface <span class="keyword">struct</span> &#123;</span><br><span class="line">    _type *_type</span><br><span class="line">    data  unsafe.Pointer</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> iface <span class="keyword">struct</span> &#123;</span><br><span class="line">    tab  *itab</span><br><span class="line">    data unsafe.Pointer</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中，iface 包含了<strong>接口的类型、方法和数据</strong>，iface 的 tab 描述了接口的类型和方法，data 则指向实际的接口数据</p><p>itab 的结构如下:</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> itab <span class="keyword">struct</span> &#123;</span><br><span class="line">inter *interfacetype <span class="comment">// abi.InterfaceType（abi: application binary interface 二进制接口），包含接口类型，pkg path（import 的路径）和接口方法（Imethod）</span></span><br><span class="line">_type *_type <span class="comment">// abi.Type，实体类型</span></span><br><span class="line">hash  <span class="keyword">uint32</span> <span class="comment">// _type.hash 拷贝而来</span></span><br><span class="line">_     [<span class="number">4</span>]<span class="keyword">byte</span> <span class="comment">// 占位，留给以后可能用到的对象</span></span><br><span class="line">fun   [<span class="number">1</span>]<span class="keyword">uintptr</span> <span class="comment">// 接口方法对应的地址，多个方法则在这个数组后面继续添加，fun[0] == 0 表示未实现接口的方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而 eface 的数据结构就简单很多了，只包含<strong>具体类型 _type 和数据指针 data</strong>，不包含方法信息</p><p>不包含方法的 eface 对应 var i interface{} 这种对象声明，主要用于<strong>传参、序列化和泛型</strong>场景</p><p>那么 go 是如何判断一个 interface 类型对象是否为空呢？需要两个条件：<strong>data 对应的值为空，且 _type 具体类型也为空</strong></p><p>通过 getError(workWithBalance) 获取的 error，虽然没有被初始化，但它有具体实现类型（MyError）而不是原始接口类型（error），所以 err == nil 为 false</p><p>想要判断 interface 背后的对象的值确实为空，有两种办法：先强转成具体的类型指针再判断，或者是通过反射方法 reflact.ValueOf 获取到内部的值来判断</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">e := getError(workWithBalance)</span><br><span class="line">v := reflect.ValueOf(e)</span><br><span class="line"><span class="keyword">if</span> e.(*MyError) == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">println</span>(<span class="string">&quot;err is nil&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 注意: IsNil 对一些无法判断空值的类型，或者未初始化的 interface 会直接 panic，所以需要先判断 value 的 kind</span></span><br><span class="line"><span class="keyword">if</span> v.Kind() == reflect.Pointer &#123;</span><br><span class="line"><span class="keyword">if</span> v.IsNil() &#123;</span><br><span class="line"><span class="built_in">println</span>(<span class="string">&quot;err is nil&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>扩展: 空接口对象，是否可以调用接口方法呢？</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> MyError <span class="keyword">struct</span> &#123;</span><br><span class="line">msg <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(err *MyError)</span> <span class="title">Error</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;empty error&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> err.msg</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> emptyErr *MyError</span><br><span class="line"><span class="built_in">println</span>(emptyErr.Error()) <span class="comment">// 不会 panic</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>结论是可以调用，这一点和其他语言很不同。一个有具体类型的空接口对象调用 pointer receiver 不会报空指针，但注意只是能调用，如果 pointer receiver 内部有获取对象属性的操作，还是会报空指针错误</p><p><a href="https://medium.com/@reetas/nil-receiver-in-golang-9d61ed8fd230" title="参考-nil receiver in GoLang">参考-nil receiver in GoLang</a></p><p><a href="https://stackoverflow.com/questions/42238624/calling-a-method-on-a-nil-struct-pointer-doesnt-panic-why-not" title="参考-Calling a method on a nil struct pointer doesn&#39;t panic. Why not?">参考-Calling a method on a nil struct pointer doesn’t panic. Why not?</a></p><h2 id="nil-channel-的使用场景"><a href="#nil-channel-的使用场景" class="headerlink" title="nil channel 的使用场景"></a>nil channel 的使用场景</h2><p>在公司规范中，说明“禁止对 nil 或已关闭的 channel 进行读写关闭操作”，这算是为数不多需要指正的一点：nil channel 在特定场景也是可以操作的</p><p>先了解一下各种特殊情况下使用 channel 会出现什么情况：</p><p>closed channel: <strong>读不阻塞（会读完剩下的数据，之后返回零值）、写 panic、再次 close panic</strong></p><p>nil channel: <strong>读阻塞、写阻塞、close panic</strong></p><p>对于 nil channel 读写都会阻塞的特性，有一个使用场景是 合并多个 channel 数据的时候，对于已经取完数据的 channel 可以置为空，这样在继续使用 select 的同时也不影响其他还有数据的 channel 的读取，<a href="https://medium.com/justforfunc/why-are-there-nil-channels-in-go-9877cc0b2308" title="参考">参考</a></p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">merge</span><span class="params">(a, b &lt;-<span class="keyword">chan</span> <span class="keyword">int</span>)</span> &lt;-<span class="title">chan</span> <span class="title">int</span></span> &#123;</span><br><span class="line">c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> <span class="built_in">close</span>(c)</span><br><span class="line"><span class="keyword">for</span> a != <span class="literal">nil</span> || b != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> v, ok := &lt;-a:</span><br><span class="line"><span class="keyword">if</span> !ok &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;a is done&quot;</span>)</span><br><span class="line">a = <span class="literal">nil</span></span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line">c &lt;- v</span><br><span class="line"><span class="keyword">case</span> v, ok := &lt;-b:</span><br><span class="line"><span class="keyword">if</span> !ok &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;b is done&quot;</span>)</span><br><span class="line">b = <span class="literal">nil</span></span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line">c &lt;- v</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line"><span class="keyword">return</span> c</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="高性能场景"><a href="#高性能场景" class="headerlink" title="高性能场景"></a>高性能场景</h1><h2 id="使用-sync-Pool-获取需要频繁申请的对象"><a href="#使用-sync-Pool-获取需要频繁申请的对象" class="headerlink" title="使用 sync.Pool 获取需要频繁申请的对象"></a>使用 sync.Pool 获取需要频繁申请的对象</h2><p>比较典型的场景是在高并发的数据流读取和写入场景中，通过 pool 缓存 buffer，避免每次都申请新的 buffer 造成频繁内存资源申请</p><p>在框架层代码中会比较容易看到 pool 的使用，如 gin 用来缓存处理请求的 Context 对象，gorm 用来缓存序列化对象（SerializerInterface）等</p><p>性能测试结果:</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkByteBufferWithoutPool</span><span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; b.N; i++ &#123;</span><br><span class="line">buf := bytes.Buffer&#123;&#125;</span><br><span class="line">buf.WriteString(longStr)</span><br><span class="line">io.Copy(io.Discard, &amp;buf)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkByteBufferWithPool</span><span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line">pool := sync.Pool&#123;</span><br><span class="line">New: <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">any</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">new</span>(bytes.Buffer)</span><br><span class="line">&#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; b.N; i++ &#123;</span><br><span class="line">buf := pool.Get().(*bytes.Buffer)</span><br><span class="line">buf.WriteString(longStr)</span><br><span class="line">io.Copy(io.Discard, buf)</span><br><span class="line">buf.Reset()</span><br><span class="line">pool.Put(buf)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试结果</span></span><br><span class="line"><span class="comment">// BenchmarkByteBufferWithoutPool-8           55544210               211.1 ns/op          1072 B/op          2 allocs/op</span></span><br><span class="line"><span class="comment">// BenchmarkByteBufferWithPool-8           355192696               33.25 ns/op            0 B/op          0 allocs/op</span></span><br></pre></td></tr></table></figure><p>从执行次数和内存开销来看，pool 在多协程下达到的对象复用的效果，都能带来很大的提升</p><p>关于 sync.Pool 值得留意的还有在 1.13 之后的性能提升，可以参考<a href="https://colobu.com/2019/10/08/how-is-sync-Pool-improved-in-Go-1-13" title="这篇文章">这篇文章</a></p><h2 id="bytes-和-string-的-0-内存申请方法"><a href="#bytes-和-string-的-0-内存申请方法" class="headerlink" title="bytes 和 string 的 0 内存申请方法"></a>bytes 和 string 的 0 内存申请方法</h2><p>直接看无内存开销的转换方式:</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ByteSliceToString</span><span class="params">(bytes []<span class="keyword">byte</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> s <span class="keyword">string</span></span><br><span class="line">sliceHeader := (*reflect.SliceHeader)(unsafe.Pointer(&amp;bytes))</span><br><span class="line">stringHeader := (*reflect.StringHeader)(unsafe.Pointer(&amp;s))</span><br><span class="line">stringHeader.Data = sliceHeader.Data</span><br><span class="line">stringHeader.Len = sliceHeader.Len</span><br><span class="line"><span class="keyword">return</span> s</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">StringToByteSlice</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="params">(bytes []<span class="keyword">byte</span>)</span></span> &#123;</span><br><span class="line">bh := (*reflect.SliceHeader)(unsafe.Pointer(&amp;bytes))</span><br><span class="line">sh := *(*reflect.StringHeader)(unsafe.Pointer(&amp;s))</span><br><span class="line">bh.Data = sh.Data</span><br><span class="line">bh.Len = sh.Len</span><br><span class="line">bh.Cap = sh.Len</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://gist.github.com/yakuter/c0df0f4253ea639529f3589e99dc940b" title="参考">参考</a></p><p>两者的相互转换都用到了反射包中表示底层结构的对象，如 slice 的 <strong>SliceHeader</strong>，以及 string 的 <strong>StringHeader</strong></p><p>string 和 byte 数组两者的底层数据结构非常相似，只是 slice 多了 cap，所以转换逻辑并不复杂</p><p>string 和 slice 的底层结构如下：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// runtime/string.go</span></span><br><span class="line"><span class="keyword">type</span> stringStruct <span class="keyword">struct</span> &#123;</span><br><span class="line">str unsafe.Pointer</span><br><span class="line"><span class="built_in">len</span> <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// runtime/slice.go</span></span><br><span class="line"><span class="keyword">type</span> slice <span class="keyword">struct</span> &#123;</span><br><span class="line">array unsafe.Pointer</span><br><span class="line"><span class="built_in">len</span>   <span class="keyword">int</span></span><br><span class="line"><span class="built_in">cap</span>   <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// reflect/value.go</span></span><br><span class="line"><span class="keyword">type</span> StringHeader <span class="keyword">struct</span> &#123;</span><br><span class="line">Data <span class="keyword">uintptr</span></span><br><span class="line">Len  <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> SliceHeader <span class="keyword">struct</span> &#123;</span><br><span class="line">Data <span class="keyword">uintptr</span></span><br><span class="line">Len  <span class="keyword">int</span></span><br><span class="line">Cap  <span class="keyword">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>go 1.20 之后，StringHeader 和 SliceHeader 被标注为 Deprecated，改为推荐使用 <strong>StringData</strong> 和 <strong>SliceData</strong>，写法上更简单了</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">byteSliceToString</span><span class="params">(bytes []<span class="keyword">byte</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> unsafe.String(unsafe.SliceData(bytes), <span class="built_in">len</span>(bytes))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">stringToByteSlice</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="params">(bytes []<span class="keyword">byte</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> unsafe.Slice(unsafe.StringData(s), <span class="built_in">len</span>(s))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实测: 直接强转和通过反射转换的benchmark测试结果对比</p><p>bytes 转 string</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">BenchmarkForceConvertBytesToString-8    66501550               178.7 ns/op          1024 B/op          1 allocs/op</span><br><span class="line"></span><br><span class="line">BenchmarkConvertBytesToString-8         1000000000               0.3236 ns/op          0 B/op          0 allocs/op</span><br></pre></td></tr></table></figure><p>可以看到，强转的方式执行速度（平均每次 178ns）远小于通过反射方式执行的，并且强转每次需要申请 1kb 内存，刚好和转换的字符串大小对应</p><p>string 转 bytes</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">BenchmarkForceConvertStringToBytes-8    67139846               200.6 ns/op          1024 B/op          1 allocs/op</span><br><span class="line"></span><br><span class="line">BenchmarkConvertStringToBytes-8         1000000000               0.3230 ns/op          0 B/op          0 allocs/op</span><br></pre></td></tr></table></figure><p>结果和 bytes 转 string 类似，不再赘述</p><h2 id="高并发的任务（如接口）创建协程池去消费和执行"><a href="#高并发的任务（如接口）创建协程池去消费和执行" class="headerlink" title="高并发的任务（如接口）创建协程池去消费和执行"></a>高并发的任务（如接口）创建协程池去消费和执行</h2><p>协程确实很”轻“，相比操作系统线程默认大小为1M 来说，它的初始大小只有 2k，确实很小（但随着栈空间扩大可能会扩缩容），不过在高并发场景下还是需要对开启协程进行控制的</p><p>协程池的选型有很多，常见的开源项目有 <a href="https://github.com/Jeffail/tunny" title="tunny">tunny</a> 和 <a href="https://github.com/panjf2000/ants" title="ants">ants</a>，两者实现方式略有区别，tunny 提交任务时是同步提交，可以拿到执行后的返回值，ants 是异步提交，不支持获取返回值，要拿到返回值的话得自己实现。示例如下：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;github.com/Jeffail/tunny&quot;</span></span><br><span class="line"><span class="string">&quot;github.com/panjf2000/ants/v2&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestTunnyPool</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">wg := sync.WaitGroup&#123;&#125;</span><br><span class="line">wg.Add(<span class="number">100</span>)</span><br><span class="line">pool := tunny.NewFunc(<span class="number">10</span>, <span class="function"><span class="keyword">func</span><span class="params">(payload <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">interface</span></span>&#123;&#125; &#123;</span><br><span class="line">time.Sleep(<span class="number">3</span> * time.Second)</span><br><span class="line">wg.Done()</span><br><span class="line"><span class="keyword">return</span> payload</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">defer</span> pool.Close()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">100</span>; i++ &#123;</span><br><span class="line"><span class="comment">// tunny.pool.Process 是同步方法，所以需要开启协程才能并发</span></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(i <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">pool.Process(i)</span><br><span class="line">&#125;(i)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">wg.Wait()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestAntsPool</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">wg := sync.WaitGroup&#123;&#125;</span><br><span class="line">wg.Add(<span class="number">100</span>)</span><br><span class="line">pool, _ := ants.NewPoolWithFunc(<span class="number">10</span>, <span class="function"><span class="keyword">func</span><span class="params">(i <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;%d execute\n&quot;</span>, i)</span><br><span class="line">time.Sleep(<span class="number">3</span> * time.Second)</span><br><span class="line">fmt.Printf(<span class="string">&quot;%d finish\n&quot;</span>, i)</span><br><span class="line">wg.Done()</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">defer</span> pool.Release()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">100</span>; i++ &#123;</span><br><span class="line">pool.Invoke(i)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">wg.Wait()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然，对于 web 框架来说，这种控制并发的功能官方都有。如 gin 通过 <a href="https://github.com/easonlin404/limit/blob/master/limit.go" title="limit">limit</a> 插件，本质也是通过 channel 控制并发协程数</p>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
          <category> golang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> golang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hive 创建 s3 外表</title>
      <link href="/2023/09/11/hive-s3/"/>
      <url>/2023/09/11/hive-s3/</url>
      
        <content type="html"><![CDATA[<p><a href="https://blog.csdn.net/xiaoliizi/article/details/132985118">本文csdn地址</a></p><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>有个比较大的技术侧需求: 将数据从 HDFS 迁移到 s3。当然在真正迁移之前，还需要验证迁移到 s3 的数据，和上层查询器（hive、presto 之间的兼容性）</p><p>这里我们对一张业务表的数据做个简单的迁移测试</p><h2 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h2><h3 id="数据迁移"><a href="#数据迁移" class="headerlink" title="数据迁移"></a>数据迁移</h3><p>为了让 hdfs 指令能直接操作 s3 的数据，参考 <a href="https://docs.cloudera.com/runtime/7.2.7/scaling-namespaces/topics/hdfs-distcp-with-amazon-s3.html">Using DistCp with Amazon S3</a><br>先在 hdfs-site 中添加配置 fs.s3a.access.key 、 fs.s3a.secret.key 、 fs.s3a.endpoint 和 fs.s3a.connection.ssl.enabled 四个配置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fs.s3a.access.key=s3_key</span><br><span class="line">fs.s3a.secret.key=s3_secret</span><br><span class="line">fs.s3a.endpoint=s3服务端地址</span><br><span class="line">fs.s3a.connection.ssl.enabled=false（因为公司内部 s3 服务没开 ssl）</span><br></pre></td></tr></table></figure><p>重启 hdfs 使得配置生效后，通过 distcp 将 hdfs 数据搬到 s3</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hadoop distcp hdfs://emr/data/db_name/table_name s3a://bucket_name/data/db_name/table_name</span><br></pre></td></tr></table></figure><p>如上，我们尽量保证了迁移后数据的路径和原路径保持一致</p><p>通过 s3cmd 确认数据是否搬过来了:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s3cmd ls s3://bucket_name/data/db_name/table_name/</span><br></pre></td></tr></table></figure><h3 id="查询验证"><a href="#查询验证" class="headerlink" title="查询验证"></a>查询验证</h3><p>新建 hive 外表并指向 s3 路径：<br>（注意：s3 路径一定要正确，否则建表和查询数据都不会报错，但查出的数据为空）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">CREATE EXTERNAL TABLE `db_name`.`table_name`(</span><br><span class="line">  `id` bigint COMMENT &#x27;&#x27;,</span><br><span class="line">  ...)</span><br><span class="line">ROW FORMAT SERDE </span><br><span class="line">  &#x27;org.apache.hadoop.hive.serde2.avro.AvroSerDe&#x27; </span><br><span class="line">STORED AS INPUTFORMAT </span><br><span class="line">  &#x27;org.apache.hadoop.hive.ql.io.avro.AvroContainerInputFormat&#x27; </span><br><span class="line">OUTPUTFORMAT </span><br><span class="line">  &#x27;org.apache.hadoop.hive.ql.io.avro.AvroContainerOutputFormat&#x27;</span><br><span class="line">LOCATION</span><br><span class="line">  &#x27;s3a://bucket_name/data/db_name/table_name&#x27;;</span><br></pre></td></tr></table></figure><h2 id="其他配置"><a href="#其他配置" class="headerlink" title="其他配置"></a>其他配置</h2><p>1、ranger 权限配置</p><p>在 ranger 上集成 hive 插件后，从 hive 权限首页能看到将包含 url、库表、hiveservice 和 udf 四项权限配置。需要在 ‘url’ 配置中添加用户权限</p><p>2、presto、trino 配置</p><p>访问 s3 数据需要额外加上以下配置：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">hive.s3.aws-access-key=s3_key</span><br><span class="line">hive.s3.aws-secret-key=s3_secret</span><br><span class="line">hive.s3.endpoint=s3服务端地址</span><br><span class="line">hive.s3.ssl.enabled=false</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 大数据 </category>
          
          <category> hive </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hadoop </tag>
            
            <tag> s3 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>是时候改变了</title>
      <link href="/2023/09/02/life-basketball-worldcup/"/>
      <url>/2023/09/02/life-basketball-worldcup/</url>
      
        <content type="html"><![CDATA[<p>今天中国男篮输给菲律宾，彻底失去了参加2024奥运会的资格。我觉得难以接受的不是我们没在亚洲排上第一，而是一直以来青黄不接的问题都被反复提起，却要到现在易建联退役，周琦受伤之后暴露出来才发觉<br>思前想后，我也看不到什么解决办法，那就来看看别人是怎么说的吧<br>注意: 论坛我只是原话搬运，很多观点也不是很切合国情，需要明辨是非地看</p><h2 id="1、关于今晚的比赛"><a href="#1、关于今晚的比赛" class="headerlink" title="1、关于今晚的比赛"></a>1、关于今晚的比赛</h2><p><a href="https://www.reddit.com/r/nba/comments/1683494/post_game_thread_philippines_14_def_china_14_9675/?utm_source=share&utm_medium=ios_app&utm_name=ioscss&utm_content=2&utm_term=1">[Post Game Thread] Philippines (1-4) def. China (1-4) 96-75 behind 34 points from Jordan ClarksonPost Game Thread</a></p><p>标题：比赛结果：克拉克森34分，中国75-96不敌菲律宾，以 1-4 成绩结束此次世界杯</p><div class="note black flat"><p>克拉克森就是安德森的亲爹（326赞）</p></div><div class="note black flat"><p>解说员说乔特·雷耶斯（菲律宾主帅）已经递交辞臣，是真的吗？如果是的话那这个消息和今晚赢球一样棒（67赞）</p><ul><li>他已经无数次说过辞职了，但是菲律宾还是选择他做主帅</li></ul></div><div class="note black flat"><p>克拉克森并不认同中国对南海的主张（301赞）（破防了属于是）</p></div><div class="note black flat"><p>当球转移更多的时候克拉克森打得更好，他不会陷入孤立无援的状态，当然这也还因为中国队并不像苏丹、安哥拉和意大利那样天赋这么好（55赞）</p></div><h2 id="2、关于中国篮球"><a href="#2、关于中国篮球" class="headerlink" title="2、关于中国篮球"></a>2、关于中国篮球</h2><p><a href="https://www.reddit.com/r/nba/comments/165mm2a/how_is_china_still_so_weak_in_international/?utm_source=share&utm_medium=ios_app&utm_name=ioscss&utm_content=2&utm_term=1">How is China still so weak in international basketball?</a></p><p>标题：为什么中国队在国际赛场上这么弱？<br>副标题：可能篮球在中国并不是最出名的，但是中国有10亿多人，他们还有一个有竞争力的联赛。然而一旦到了国际赛场，前面所提的好像都和他们的表现无关，这届世界杯他们已经0-3了</p><div class="note black flat"><p>其实他们的联赛其实并不是很有竞争力，有的球员在那里能打出非常好的数据，但是到欧洲有竞争力的联赛就只能是平均水平（有时比平均水平更低）<br>米洛斯拉夫-拉杜利察 在CBA 的平均数据是 24分/11篮板和5助攻（<a href="https://www.sohu.com/a/588895902_121082800">数据来源</a>），但是他在欧洲篮球联赛（Euroleague ，简称EL）和 美国篮球联赛（American Basketball Association，简称 ABA，比 NBA 低级别）的贝尔格莱德红星（ Red Star Belgrade）队因为表现不佳，都没能获得上场机会（DNP）。达拉斯-摩尔 能够以 51%命中率、41%三分命中率和83%罚球命中率（51/41/83）在 CBA 拿到 26+6+4的数据，但之后的一个赛季他在欧洲杯（Eurocup ，比 Euroleague  低一个级别）却只能拿到场均6分的数据<br>CBA 受到关注的很大原因是他们为前 NBA 球员提供非常丰厚的薪水，这让他们在没有压力的情况下打比赛，也导致了中国本土球员水平更差<br>（1.1k赞）</p></div><div class="note black flat"><p>引用姚明的话：<br>“中国有14多亿人，但只有1.3w 注册球员，日本有75w，美国有2300w”（2.7赞）<br>（译者注：不过关于这点要说回来，日美是把学校打篮球的也算进来了，因为他们有校园联赛，我们没统计这部分）</p></div><div class="note black flat"><p>篮球系统太孤立了，当全世界的球员球队都在一起比赛对抗的时候，拥有自己联赛其实代表不了什么。日本有不少球员在美国大学打球，甚至在NBA打球，他们在那里进行高水平的比赛，这提升了他们国家队水平。反观中国球员并没有这样的（译者注：校园篮球还是有的，只是都没打出来，今年NBA三个落选秀）（349赞）</p></div><div class="note black flat"><p>我所看到的是他们的培养系统非常糟糕（428赞）</p><ul><li>中国人在这里回复一下，这正是原因所在<br>在美国，如果你表现出了篮球天赋，球探会在你上学的时候，甚至是读小学的时候就注意到你，让你加入更好的球队，跟着更好的教练接受培养，直到你在NBA选秀被选中。整个系统都致力于培养学生成为职业运动员，并且不会放过任何一个有天赋的学生，不管TA来自哪里<br>在中国打篮球的青年男生不计其数，我也确定在他们中一定有天赋优秀的孩子。但是这里并没有将他们看中并培养到top水平运动员的体系。绝大多数小孩只是会被教导把学习放在首要位置上，篮球当作爱好就好。我们也有一些和职业道路紧密相关的体育学校，但只有很小一部分小孩能够选择这条路，而不是常规的进学路，而且这些体育学校往往会被家长当作是垃圾学校<br>所以说，尽管中国有很多小孩在打篮球，但有可能成为职业运动员的人才库却非常干涸，这导致了现在的中国篮球缺少拿得出手的成绩（65赞）</li></ul></div><div class="note black flat"><p>据我了解，他们的篮球文化非常不同。除了 CBA，他们大部分的比赛就只是来自不同城市的业余球队之间，甚至这些业余比赛相比CBA，在民间更火，所以他们并不会把成为职业运动员当作自己的理想。他们更希望有一个普通的工作，为自己城市的球队参与比赛（58赞）</p></div><div class="note black flat"><p>他们在团体运动上表现都很差，不只是篮球（752赞）</p><ul><li>你说的一点毛病没有，从1984 年以来中国拿到的546枚奥运奖牌中，只有13枚来自团队球类项目（<a href="https://en.wikipedia.org/wiki/China_at_the_Olympics">来源</a>）（566赞）</li></ul></div><div class="note black flat"><p>在中国很多体育项目都集中精力于奥运会上，因为这对政府来说最能体现它的强大。他们的奥运团队也主要集中精力在那些能用较少精力，较大概率获得金牌的项目上（参考 <a href="https://www.nytimes.com/2021/07/29/world/asia/china-olympics.html">The Chinese Sports Machine’s Single Goal: The Most Golds, at Any Cost</a>）。从这个角度看，投资篮球或者其他大部分团队体育项目都是非常糟糕的：构建一个具有竞争力的篮球队，需要投入到基础设施的建设太多了，而且你是在参与整个奥运会上最有含金量（是真的含金）的运动，但只能获得一枚奖牌（84赞）</p></div><div class="note black flat"><p>我曾经在美国一个很大的州的高校工作，这个学校专门为有钱的国际学生开设。这个学校在我入职的那一年拿到了州冠军。一半的国际生来自亚洲（其中90%来自中国），大约3/4 的亚洲男孩会在放学后进行投篮训练，他们是真的痴迷于篮球。大部分学生都会尝试校队选拔，只有一个能进入到新生校队，没人能进入二级校队或主力校队（新生校队 -&gt; 二级校队 -&gt; 主力校队：Freshman -&gt; JV -&gt; Varsity）</p><p>我经常和他们一起打球，大部分在基础投篮表现上都不差。大部分学生运球也还可以，少数人投篮也很好，但他们完全不擅长在 5V5 这种常规，需要团队组织的模式下打球。我的一位朋友是他们的教练，他会在选拔周的时候进行一些技能特训，比如3V3，这对这些学生来说非常困难。比如他们不清楚在无球状态下如何跑位，他们知道挡拆怎么做，但并不知道背后的原理，以及应该什么时候做挡拆，什么方向去做挡拆。更不懂如何卡板，对防守的投入也很少。他们模仿的是一个并不适合实战的篮球法则，更像是游戏里面的（他们喜欢玩 2K 和 lol）。尽管这50个学生只是他们庞大人口的很小一部分，但是来自其他国家的学生更懂如何取胜（140赞）</p><ul><li>我是美籍华人，并在06年的大学暑假，在上海做过交换生（是的我上年纪了）。我的两个接近6英尺4英寸（194左右）的白人同学都喜欢打篮球，所以我们去找了一个本地球场打球。所有本地人都大声想要 And one，像机器人一样地运球，并想在高大的老美面前炫技。其次是只要我们提升一点防守强度，他们总是不停地叫犯规，甚至为这还差点打起来，直到我这个老家伙盯着他们，让他们闭嘴。好像你只要不让他们做这些行为，让他们打得爽，他们就随时要拿着球回家。真是非常非常奇怪的经历了（译者：这段比较扯淡，野球场也不能代表国家队的表现）</li></ul></div><div class="note black flat"><p>最大的原因还是他们的基层培养体系不完善。在中国，篮球系统集中依赖于体育学院运作，并且通常以身高作为新秀选拔标准。引用姚明的话，中国只有13w篮球注册人口，不及美国的 1/100 甚至还没有日本多，这真的讲到痛点上了。</p><p>他们没有像美国在初中、高中、业余体育联合会（AAU）这样组织的联赛。只有很小一部分年轻人接受了组织指导和训练。专业学院之外的培训系统几乎就是不存在的。中国大学生的技术平均水平就和美国普通高中学生差不多（我和中国大学校队打过球）</p><p>这也意味着，当中国以高个子为选拔标准的时候，真正有天赋的控卫和前锋就只能从很少的一部分人中挑选了，甚至比大部分国家的选择标准都要少。这也符合了大部分中国球星都是内线（姚明、易建联、周琦、巴特尔等）的情况，他们还小就通过身高容易被发掘并进入到体教体系。举另一个例子，林书豪来自5百万美籍华裔中，而不是14亿中国人口中（280倍之差）（46赞）</p></div><h2 id="自己再说两句"><a href="#自己再说两句" class="headerlink" title="自己再说两句"></a>自己再说两句</h2><p>reddit 上的言论看一圈下来，倒是和国内讨论的八九不离十，基本离不开青训体系建设、联赛对抗水平、海外打球的球员数量等方向。但就只是看这三点，从08到现在我们也几乎没有进步。海外打球的本土球员现在为0，大学生联赛培养出的新秀在CBA都难以立足，整个联赛水平也在退步：以前多少王牌外援，多少本土响当当的球星，现在呢？那反映在大赛上，成绩能好吗？</p><p>网上也看到不少把输球原因归结到某个球员，或者是教练，又甚至是篮协主席身上</p><p>我特别反感这种出现问题就把锅全甩给一个人的言论，除了能宣泄负面情绪没有任何用处，另外我们所看到的输球只是一瞬间的事，那我们是做了什么，为什么会制定这样的规划政策，为什么联赛会培养出这些在国际赛场打不出水平的球员，为什么要频繁换教练，导致永远没有一套自己的技战术体系，这和背后的决策、体系规划、培养方式方方面面都离不开关系</p><p>你说李凯尔打得不好，那就假设把他换了，换成场均能拿30多分的，这种水平在国际比赛赛场已经很猛了。但是我们输的三场比赛，分别输了 42分，20分，18分和21分，归化就算能多拿10多分也是无济于事。看一下隔壁的比赛，渡边雄太这场拉垮了，但是他们还有两个球员拿了20多分，我们呢？</p><p>你说教练有问题，那就说他现在手里的牌又有多少。你说他用人不当调整不及时，那就说现在中国队球员全部加起来，有一个像样的首发阵容吗？真到了比赛要紧时刻，该换谁，能换谁呢？。另一方面是没有个人能力特别突出的球员，球员之间形成不了很好的化学反应，这也直接导致了没有稳定的球队技战术体系。那这怪教练也没用，巧妇也难为无米之炊</p><p>最后，我们到底会怎么发展呢？从08年到现在，已经退步了15年了，现在还看不到答案的话，4年后再参加预选的我们又真的能找到答案吗？我不好说。</p>]]></content>
      
      
      <categories>
          
          <category> 生活 </category>
          
          <category> 篮球 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 生活 </tag>
            
            <tag> 篮球 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>开源项目观察8月报</title>
      <link href="/2023/08/23/opensource-monthly-202308/"/>
      <url>/2023/08/23/opensource-monthly-202308/</url>
      
        <content type="html"><![CDATA[<p><a href="https://blog.csdn.net/xiaoliizi/article/details/132702146">本文csdn地址</a></p><p><a href="https://mp.weixin.qq.com/s/z7elA1hgWTRgzsIt_R_4QQ">本文公众号地址</a></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>要问对一门技术感兴趣的最好办法是什么，必然不是直接揪着原理、源码一点点读，那很容易只见其木不见其林。不妨从新特性去了解，先俯瞰森林全貌，再细看每一棵树的变化</p><p>于是刚旅游回来的我在想，已经这么久没关注技术行情了，那就看看这个月的更新呗，了解一下接触过的技术都有哪些更新</p><p>总览: 大数据: hue、starrocks、airflow、presto、jupyter、seatunnel、starrocks；编程语言: golang、c++</p><h2 id="大数据"><a href="#大数据" class="headerlink" title="大数据"></a>大数据</h2><h3 id="hue"><a href="#hue" class="headerlink" title="hue"></a>hue</h3><p><a href="https://github.com/cloudera/hue/releases/tag/release-4.11.0">1月19: 4.11</a><br><a href="https://docs.gethue.com/releases/release-notes-4.11.0/">https://docs.gethue.com/releases/release-notes-4.11.0/</a></p><p><img src="/2023/08/23/opensource-monthly-202308/hue-01.png" alt="hue release"></p><ul><li><p><a href="https://gethue.com/blog/2022-10-11-creating-iceberg-tables-in-hue/">支持 iceberg 数据源</a></p></li><li><p>通过缓存 Livy session 中的信息来加速 SparkSQL，并适配 Spark UDF</p></li><li><p><a href="https://gethue.com/blog/2022-02-01-hplsql-support/">支持 HPL/SQL: hive sql 的高级语法，支持中间结果保存、循环等</a>, <a href="http://www.hplsql.org/doc">HPL</a></p></li></ul><p>总结: 基本是小改进，界面样式和4.10一致</p><h3 id="starrocks"><a href="#starrocks" class="headerlink" title="starrocks"></a>starrocks</h3><p><a href="https://docs.starrocks.io/zh-cn/main/release_notes/release-3.1">8月25: 3.1.2</a></p><p><img src="/2023/08/23/opensource-monthly-202308/starrocks-01.png" alt="starrocks release"></p><p>3.1 版本相关的新特性（部分）</p><ul><li><p>存算分离: 支持主键模型</p></li><li><p>存算分离: 抽象 存储卷（Storage Volume） 概念，方便在不重启集群的情况下，对对象存储的配置进行修改</p></li><li><p>Catalog: 支持 ES、Paimon</p></li><li><p>​物化视图: 可以通过ALTER手动重新激活失效的物化视图（之前在 base 表重建后，物化视图需要重建）</p></li><li><p>物化视图: 通过 swap 可进行视图替换（目前还不支持直接 alter 视图 sql）</p></li><li><p>物化视图: 支持随机分桶（Random Bucketing）</p></li><li><p>物化视图: 支持通过 ORDER BY 指定排序键</p></li><li><p>建表: 支持自增列属性 AUTO_INCREMENT，提供表内全局唯一 ID</p></li><li><p>建表: 通过分区表达式自动创建分区，比如 day 表示按天分区</p></li><li><p>建表: 支持随机分桶（仅支持明细表）</p></li><li><p>建表: 支持使用 colocate_group、storage_medium（存储介质 如：SSD）、storage_cooldown_time 等属性</p></li><li><p>建表: 支持生成列（generated column），自动计算表达式结果，提升查询性能</p></li><li><p>导入数据: 通过 insert into 导入数据的时候支持 files 函数，不需要先建 catalog</p></li></ul><p>总结: starrocks 作为目前比较流行的实时数仓服务，3.0 版本在物化视图的改进还是很足的，非常建议尝试</p><h3 id="airflow"><a href="#airflow" class="headerlink" title="airflow"></a>airflow</h3><p><a href="https://airflow.apache.org/docs/apache-airflow/stable/release_notes.html#airflow-2-7-0-2023-08-18">8月18: 2.7.0</a></p><p><img src="/2023/08/23/opensource-monthly-202308/airflow-04.png" alt="airflow release"></p><ul><li><p>python基础版本: 不再支持 3.7, 支持 3.8, 3.9, 3.10, 3.11</p></li><li><p>UI: 新 graph 界面</p></li><li><p>smtp: 默认使用 <a href="https://docs.python.org/3/library/ssl.html#ssl.create_default_context">ssl.create_default_context</a> 创建 ssl 客户端，可通过 <a href="https://airflow.apache.org/docs/apache-airflow/stable/configurations-ref.html#ssl-context">ssl_context</a> 配置其他校验级别<br><a href="https://github.com/apache/airflow/pull/33075">参考: Allows to choose SSL context for SMTP provider #33075</a></p></li><li><p>UI：出于安全性考虑，默认禁用在界面、API 和 CLI 侧<a href="https://airflow.apache.org/docs/apache-airflow/stable/howto/connection.html#testing-connections">对 connection 触发测试</a>，可通过 <a href="https://airflow.apache.org/docs/apache-airflow/stable/configurations-ref.html#test-connection">test_connection</a> 选项配置<br>可选值: Disabled, Enabled, Hidden</p></li></ul><p>之前版本的dag界面:<br><img src="/2023/08/23/opensource-monthly-202308/airflow-02.png" alt="airflow"></p><p>新版本dag界面:<br><img src="/2023/08/23/opensource-monthly-202308/airflow-03.png" alt="airflow"></p><p>总结: 基本功能改动不大，有两个主要特性都和安全性相关</p><h3 id="presto"><a href="#presto" class="headerlink" title="presto"></a>presto</h3><p><a href="https://prestodb.io/docs/current/release/release-0.283.html">8月8: 0.283</a></p><p>0.276 ~ 0.283 的部分改进</p><ul><li><p>JDBC: 增加 metadata 的缓存，通过三个配置控制: metadata-cache-ttl, metadata-cache-refresh-interval 和 metadata-cache-size<br><a href="https://prestodb.io/docs/current/connector/hive.html?highlight=metadata%20cache%20ttl#metastore-configuration-properties">参考 hive 配置</a></p></li><li><p><a href="https://github.com/prestodb/presto/issues/15909">ES: 支持配置用户密码校验</a>，参数将透传给ES</p></li></ul><h3 id="jupyter"><a href="#jupyter" class="headerlink" title="jupyter"></a>jupyter</h3><p><a href="https://jupyterlab.readthedocs.io/en/stable/getting_started/changelog.html#v4-0">4.0</a></p><p>快速使用:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -it --rm -p 8888:8888 jupyter/datascience-notebook:lab-4.0.5</span><br></pre></td></tr></table></figure><p><img src="/2023/08/23/opensource-monthly-202308/jupyter-02.png" alt="jupyterlab"></p><ul><li><p>code editor: 使用新版 codemirror 6，配置更有效和方便，比如只隐藏 markdown 格式的左侧行数</p></li><li><p>extension: 可以直接引用通过 pip 安装的依赖，不再需要本地再把 extension 项目重新 build 的过程</p></li><li><p>基本操作: 优化搜索功能，支持选中搜索、多行搜索</p></li><li><p>UI: 增加 ctrl + shift + H 快捷键查看热键，在 notebook 底部增加创建新代码块按钮等</p></li></ul><p><img src="/2023/08/23/opensource-monthly-202308/jupyter-01.png" alt="add cell"></p><ul><li>协作: 通过 <a href="https://github.com/jupyterlab/jupyter-collaboration">jupyter-collaboration</a> 支持多用户协作编辑同个 notebook</li></ul><p>总结: 4.0 版本之后界面样式和 3 差不多，不过还是能看到很明显的一些细节改进，值得尝试</p><h3 id="seatunnel"><a href="#seatunnel" class="headerlink" title="seatunnel"></a>seatunnel</h3><p><a href="https://github.com/apache/seatunnel/releases/tag/2.3.3">2.3.3</a></p><p><a href="https://mp.weixin.qq.com/s/vEh-n_8Oe050hm1pA47bbg">参考: Apache SeaTunnel 2.3.3 版本发布，CDC 支持 Schema Evolution！</a><br><a href="https://apacheseatunnel.medium.com/apache-seatunnel-2-3-3-released-with-cdc-support-for-schema-evolution-2fd78c81f2d6">Apache SeaTunnel 2.3.3 Released with CDC Support for Schema Evolution!</a></p><ul><li><p>实时同步: flink cdc 支持表结构同步（DDL）</p></li><li><p>实时同步: flink cdc 支持对无主键表的唯一索引列进行 split 拆分</p></li><li><p>mongo: 支持 mongo cdc</p></li></ul><h2 id="编程语言"><a href="#编程语言" class="headerlink" title="编程语言"></a>编程语言</h2><h3 id="golang"><a href="#golang" class="headerlink" title="golang"></a>golang</h3><p><a href="https://tip.golang.org/doc/go1.21">1.21</a></p><p><a href="https://go.dev/blog/go1.21">Go 1.21 is released!(8月8日)</a></p><p><a href="https://mp.weixin.qq.com/s/Nuj_cYFvBesaBbSSz5PuBg">Go1.21 那些事：泛型库、for 语义变更、统一 log/slog、WASI 等新特性，你知道多少？</a></p><p><a href="https://appliedgo.com/blog/go1-21">Is Go 1.21 already on your upgrade list? It should be!</a></p><ul><li><p>日志: 标准库新增 slog，支持格式化日志输出、自定义 handler 和 日志等级<br><a href="https://www.reddit.com/r/golang/comments/11sdqia/slog_proposal_accepted_for_go_121/">reddit 上的讨论</a>: 大部分开发者都很欢迎 go 官方支持了slog</p></li><li><p>内置函数: 新增 max、min、clear。不再需要通过 math.Max 调用，且通过泛型支持不同基础类型传参</p></li><li><p>内置函数: <a href="https://pkg.go.dev/cmp">cmp</a> 支持泛型</p></li><li><p>基础类型: map、slice 支持泛型，并提供支持泛型的 <a href="https://pkg.go.dev/maps">maps</a>、<a href="https://pkg.go.dev/slices@master">slices</a> 工具库<br>常用方法: slices.Sort、maps.Equal 等</p></li><li><p>泛型: 性能提升<br><a href="https://encore.dev/blog/go1.21-generics">Understanding Go 1.21 generics type inference</a></p></li><li><p>基本语法: for 循环变量赋值语义变更，可通过添加 <a href="https://github.com/golang/go/wiki/LoopvarExperiment">GOEXPERIMENT=loopvar</a> 参数控制让局部变量每次赋予新值，避免在循环内开启协程、使用指针时出现不符预期的结果，<a href="https://github.com/golang/go/wiki/CommonMistakes#using-reference-to-loop-iterator-variable">参考: Using reference to loop iterator variable</a></p></li><li><p>编译: <a href="https://go.dev/doc/pgo">PGO（Profile Guided Optimization）</a> 正式发布，通过在 main 代码目录放置 default.pgo（可通过 /debug/pprof/profile 接口生成的 profile）文件来开启 PGO build，将对程序性能有 2% - 7% 的提升</p></li><li><p>命令行和工具: go tool 支持向前（旧版本）兼容和向后（新版本）兼容<br>向前: 如设置 GODEBUG=http2client=0,http2server=0 可禁用 net/http 库的 http2 功能，<a href="https://go.dev/doc/godebug">参考</a><br>向后: 如通过 GOTOOLCHAIN=go1.21rc3 go test 参数设定 go tool 使用的版本，<a href="https://go.dev/doc/toolchain">参考</a></p></li><li><p>Context: context 新增 WithoutCancel 、WithDeadlineCause 、 WithTimeoutCause、<a href="https://github.com/golang/go/issues/57928">AfterFunc</a> 等方法</p></li><li><p>其他特性等: 支持 WASI；增加全局的 <a href="https://github.com/golang/go/issues/57179">$GOROOT/go.env</a> 配置解析（优先级: 系统环境变量 &gt; 用户路径下的 go.env，即 $HOME/.config/go/env &gt; $GOROOT/go.env）等</p></li></ul><p>总结: 相比泛型，像日志库、一些内置函数和 context 新增方法反而更让笔者眼前一亮，这些是在旧功能上进行的添彩功能，可能在平时更能用上</p><h3 id="c"><a href="#c" class="headerlink" title="c++"></a>c++</h3><p><a href="https://zhuanlan.zhihu.com/p/137646370">10分钟速览 C++20 新增特性</a></p><p><a href="https://oi-wiki.org/lang/new">新版 C++ 特性(c++11)</a></p><p><a href="https://blogs.embarcadero.com/what-is-modern-c-in-2023">What Is Modern C++ in 2023?</a></p><p><a href="https://blog.devgenius.io/what-is-new-in-c-20-a5ba62a28b9a">What is new in C++20</a></p><p><a href="https://en.cppreference.com/w/cpp/20">官方-C++20</a></p><p>注意: 使用 gcc 编译需要先升级到 10 以上版本 - <a href="https://stackoverflow.com/a/60515907">参考</a></p><ul><li><p>模块管理: 通过模块进行依赖引用，减小编译后文件大小<br><a href="https://zhuanlan.zhihu.com/p/350136757">扩展: C++20 新特性: modules 及实现现状</a><br><a href="https://github.com/Cpp-Club/Cxx_HOPL4_zh/blob/main/09.md#931-%E6%A8%A1%E5%9D%97">扩展: C++ 之父 Bjarne Stroustrup 对模块功能的介绍</a><br><a href="https://zhuanlan.zhihu.com/p/350136757">C++20 新特性: modules 及实现现状</a></p></li><li><p>基础语法: 支持 coroutine（协程）</p></li><li><p>基础语法: 支持 concept+requires 语法，可以更方便地使用泛型，<a href="https://zhuanlan.zhihu.com/p/107610017">参考</a></p></li><li><p>基础语法: <a href="https://zhuanlan.zhihu.com/p/86809598">Ranges</a>: 更方便地编写迭代器、过滤器的语法<br>但是对 ranges 的看法五花八门，<a href="https://zhuanlan.zhihu.com/p/603431999">参考一篇知乎</a></p></li><li><p>基础语法: 支持条件约束（<a href="https://www.modernescpp.com/index.php/c-core-guidelines-a-detour-to-contracts/">Contract Programming</a>）: 可定义前置条件、后置条件、错误、断言和不变量等，可以更早地在编译阶段发现程序问题<br>如: <a href="https://www.cppstories.com/2017/11/nodiscard/">nodiscard</a>: 规定方法返回值要获取，<a href="https://gavinray97.github.io/blog/adding-invariant-to-cpp-design-by-contract#implementing-the-invariant-call-code-generation">invariant</a>: 规定方法内部不对入参进行修改<br>注意: 只是在编译产生警告，不会直接导致编译错误</p></li><li><p>基础类型: 原子类型，操作方法有 store、load、fetch_add 等</p></li></ul><p>总结: 更新虽然很多，但是 coroutine 使用起来需要引入相关的如此多的关键字，着实让我敬而远之。<a href="https://news.ycombinator.com/item?id=26222342">类似的吐槽</a>，其中有人建议使用封装后的库 如 <a href="https://github.com/lewissbaker/cppcoro">cppcoro</a>，以及对比 Rust 语言的 Async 和 Await 用法: <a href="https://lights0123.com/blog/2020/07/25/async-await-for-avr-with-rust/">Async/Await for AVR with Rust</a></p>]]></content>
      
      
      <categories>
          
          <category> 开源 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 大数据 </tag>
            
            <tag> golang </tag>
            
            <tag> 开源 </tag>
            
            <tag> starrocks </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>富士山与水</title>
      <link href="/2023/08/10/japan-travel-note-fujisan/"/>
      <url>/2023/08/10/japan-travel-note-fujisan/</url>
      
        <content type="html"><![CDATA[<p><a href="https://mp.weixin.qq.com/s/JDD-hAGgrzmrKvodmFqJeA">本文公众号地址</a></p><!--## JRJR 票买起来还是挺麻烦的，支付方式只能选择本地网络支付app，现金或者是实体西瓜卡。苹果钱包里面的西瓜卡在这个时候就没什么用了--><h2 id="景观列车"><a href="#景观列车" class="headerlink" title="景观列车"></a>景观列车</h2><p>坐JR到上月再坐景观列车到河口湖，慢慢从城市走向自然的感觉</p><p><img src="/2023/08/10/japan-travel-note-fujisan/fujisan-01.JPG" alt="居民房都差不多一个样"></p><p><img src="/2023/08/10/japan-travel-note-fujisan/fujisan-02.JPG" alt="景观列车"></p><p><img src="/2023/08/10/japan-travel-note-fujisan/fujisan-03.JPG" alt="快到景区"></p><p><img src="/2023/08/10/japan-travel-note-fujisan/fujisan-04.JPG" alt="公交上拍的富士山"></p><p>不过话说回来，JR 其实也不算慢了，只是相对于新干线（对应国内的高铁）来说稍微慢一点</p><h2 id="富士山的水"><a href="#富士山的水" class="headerlink" title="富士山的水"></a>富士山的水</h2><p>保持了很久的“养胃”模式，被沁人心脾的富士山水打破了</p><p><img src="/2023/08/10/japan-travel-note-fujisan/fujisan-05.JPG" alt="清澈得还在冒泡的水"></p><h2 id="富士山"><a href="#富士山" class="headerlink" title="富士山"></a>富士山</h2><p>从天上山公园，天晴号再到自然生活馆，从安然隐居山林，到山顶和山脚的风格相衬，总能发现不一样的的富士山</p><p><img src="/2023/08/10/japan-travel-note-fujisan/fujisan-06.JPG" alt="fujisan"></p><p><img src="/2023/08/10/japan-travel-note-fujisan/fujisan-07.JPG" alt="fujisan"></p><p><img src="/2023/08/10/japan-travel-note-fujisan/fujisan-08.JPG" alt="fujisan"></p><p><img src="/2023/08/10/japan-travel-note-fujisan/fujisan-09.JPG" alt="fujisan"></p><p><img src="/2023/08/10/japan-travel-note-fujisan/fujisan-10.JPG" alt="fujisan"></p>]]></content>
      
      
      <categories>
          
          <category> 旅游 </category>
          
          <category> 日本 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 旅游 </tag>
            
            <tag> 日本 </tag>
            
            <tag> 日记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>東京の日々</title>
      <link href="/2023/08/10/japan-travel-note-tokyo/"/>
      <url>/2023/08/10/japan-travel-note-tokyo/</url>
      
        <content type="html"><![CDATA[<p><a href="https://mp.weixin.qq.com/s/P1CZG06HA9ZI6BXlPyOR0g">本文公众号地址</a></p><h2 id="花火大会"><a href="#花火大会" class="headerlink" title="花火大会"></a>花火大会</h2><p>百闻不如一见，虽然过程有一点不小的插曲，还好把最精彩的一段看完了</p><p>当时就很好奇放出笑脸的烟花是怎么做出来的，正好今晚的 NHK 节目还科普了一下</p><p><img src="/2023/08/10/japan-travel-note-tokyo/tokyo-travel-note-01.jpg" alt="提前一个半小时已经来了不少人"></p><p><img src="/2023/08/10/japan-travel-note-tokyo/tokyo-travel-note-02.png" alt="回来后看到关于火灾的报道"></p><p><a href="https://www.nhk.jp/p/chicochan/ts/R12Z9955V3/episode/te/JYZGRL8W3W">NHK 节目: 拡大版SP▽花火の謎▽なぜ正座▽不思議なジャンプ</a></p><h2 id="新宿"><a href="#新宿" class="headerlink" title="新宿"></a>新宿</h2><p>希望是最后一次被红蓝遍天的カラオケ广告牌吸引吧😂</p><p><img src="/2023/08/10/japan-travel-note-tokyo/tokyo-travel-note-03.png" alt="歌舞伎町"></p><h2 id="浅草寺"><a href="#浅草寺" class="headerlink" title="浅草寺"></a>浅草寺</h2><p>也许是个抽签小技巧：在去浅草寺的仲见世通路边摊上，先抽中一个4等奖的小奖品，再去抽浅草寺的签</p><p><img src="/2023/08/10/japan-travel-note-tokyo/tokyo-travel-note-04.png" alt="雷门"></p><p><img src="/2023/08/10/japan-travel-note-tokyo/tokyo-travel-note-05.png" alt="背面的风神雷神"></p><h2 id="秋叶原"><a href="#秋叶原" class="headerlink" title="秋叶原"></a>秋叶原</h2><p>相比起二次元，它更配得上的符号应该是技术阿宅的天堂，包括 softmap 在内的电器店卖的各种电脑配件，能细到焊板用的各种元器件，DLY大神应该什么​电器都能做出来了</p><p><img src="/2023/08/10/japan-travel-note-tokyo/tokyo-travel-note-06.png" alt="秋叶原"></p><h2 id="J联赛"><a href="#J联赛" class="headerlink" title="J联赛"></a>J联赛</h2><p>川崎前锋主场对阵大阪钢巴，本以为是一场主队轻松把控局势的对阵，却变成了到补时阶段都一直跌宕起伏的比赛</p><p>混入客场球迷区的我们 也结结实实的被大阪球迷的欢庆包围了</p><p><img src="/2023/08/10/japan-travel-note-tokyo/tokyo-travel-note-07.png" alt="看完比赛从球场回去"></p><h2 id="东京塔-amp-东京树"><a href="#东京塔-amp-东京树" class="headerlink" title="东京塔 &amp; 东京树"></a>东京塔 &amp; 东京树</h2><p>同样是电视塔，东京塔有它的历史感，东京树有它的朝气和活力</p><p>对我来说 可能商业气氛没那么浓的东京塔更中意点吧</p><p><img src="/2023/08/10/japan-travel-note-tokyo/tokyo-travel-note-08.png" alt="从芝公园看东京塔"></p><p><img src="/2023/08/10/japan-travel-note-tokyo/tokyo-travel-note-09.png" alt="东京树"></p><h2 id="东京地铁"><a href="#东京地铁" class="headerlink" title="东京地铁"></a>东京地铁</h2><p>除了找换站难的问题，东京地铁给我最大的印象还得是座位太舒服了，所有座位都有软坐垫和靠背。要是国内也有这样的配套，家人再也不用担心我加班多晚回来了</p><h2 id="吃的"><a href="#吃的" class="headerlink" title="吃的"></a>吃的</h2><p>来东京的第一顿正餐就是拉面，差点要咸哭我了</p><p>后面吃的口味比较正常，好不好喝关键还是得在汤</p><p><img src="/2023/08/10/japan-travel-note-tokyo/tokyo-travel-note-11.png" alt="东京树下吃的还不错的拉面"></p><p>寿司和国内相比，好吃并不在肉而是在米。在筑地市场吃的这家也好，在车站买的也好，米的口感都挺不错的</p><p><img src="/2023/08/10/japan-travel-note-tokyo/tokyo-travel-note-10.png" alt="筑地市场吃的寿司"></p><p><img src="/2023/08/10/japan-travel-note-tokyo/tokyo-travel-note-12.png" alt="坐JR吃的寿司"></p><p>当然，我承认自己还是更喜欢便利店的东西，这几天把泡面、寿司、零食都吃了个遍，什么吃的都不重样，不得不感叹这就是便利店大国的实力吗</p><h2 id="一点感想"><a href="#一点感想" class="headerlink" title="一点感想"></a>一点感想</h2><p>在亲身来到了东亚之光，一个真正包容开放的大城市之后，不禁还是想写点什么。东京之所以能成为东京，有客观的原因，也有它自己的东西，而且东京在从里到外很自信地展示着，有无数抬头就能看到的现代化元素，也在行走街道的转角处，看到的历史和潮流的碰撞（神社、老房子、窄窄的小巷、地铁的设施）。这些元素可能看着和东京的定位格格不入，但是东京毫不吝啬地让我们看到。它的包容性，也不只是体现在有多少外国人在这里，而是能让任何一个来东京旅游的人，都看得到关于它的一切</p><p>一味地否定自己的文化和历史，连自己该展示的精华都没搞明白，也很难让别人看得起自己</p>]]></content>
      
      
      <categories>
          
          <category> 旅游 </category>
          
          <category> 日本 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 旅游 </tag>
            
            <tag> 日本 </tag>
            
            <tag> 日记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>东京景点</title>
      <link href="/2023/07/14/japan-travel-guide-tokyo/"/>
      <url>/2023/07/14/japan-travel-guide-tokyo/</url>
      
        <content type="html"><![CDATA[<h2 id="本文共享文档"><a href="#本文共享文档" class="headerlink" title="本文共享文档"></a>本文共享文档</h2><p><a href="https://thorn-silkworm-729.notion.site/dd52fddbc33d43fa93b272c0544d1ea6">日本景点</a></p><h2 id="东京介绍"><a href="#东京介绍" class="headerlink" title="东京介绍"></a>东京介绍</h2><p><a href="https://zh.wikipedia.org/zh-hans/%E4%B8%9C%E4%BA%AC">东京-维基百科</a></p><p>东京（日语：東京 / とうきょう Tōkyō */?）是位于日本关东地方的都市，一般指东京都、狭义上东京都区部（即东京市区），亦可泛指东京都及周边卫星都市相连而成的“首都圈”（东京都会区）。是日本事实上的首都。<strong>东京都人口数达1399万</strong>（2022年4月），首都圈的人口数则达3800万，是目前全球规模最大的都会区。<strong>东京的GDP为全球第二</strong>，在2016年达9730亿美元，而同时东京都会区（一都三县）则高达1.8兆美元，若将东京视为一个国家，其GDP总量高于加拿大、韩国、俄罗斯等，位列世界第八。东京为亚洲最重要的世界级城市，也是传统上的全球四大世界级城市之一，全球城市指数排名前四。此外，东京亦为世界最宜居城市（英国Monocle生活品质调查）。</p><p>东京古称江户，自德川幕府时代以来开始成为日本主要都市之一，明治维新时期改为现名后，更发展为日本政治、经济、文化、交通等众多领域的枢纽中心。经过二战后的继续发展，东京不仅成为世界商业金融、流行文化与时尚重镇，亦为世界经济发展及富裕程度最高的都市之一。此外，东京还拥有复杂且密集的城市轨道交通系统，其中单就东京的两大地铁系统管辖区段每日平均运量达880万人次，繁忙程度居全球地铁第三位；如将地铁直通运转路线、私铁通勤路线及JR通勤路线纳入计算，则每日平均运量位居世界城市轨道交通运输系统第一位。</p><p>在正式的行政区划定义上，东京仅限于东京都，与道、府、县同为日本的一级行政区，辖区包含东京都区部、多摩地方以及伊豆群岛、小笠原群岛等离岛；其中，<strong>东京都区部为日本中央政府所在地</strong>。东京都同时也囊括了日本最南端（冲之鸟礁）和最东端（南鸟岛）等地理极点，拥有日本各都道府县中最多的人口数，同时也是日本人口密度最高的都道府县。</p><h2 id="23区地图"><a href="#23区地图" class="headerlink" title="23区地图"></a>23区地图</h2><p><img src="/2023/07/14/japan-travel-guide-tokyo/tokyo-area-02.webp" alt="东京23区地图"></p><h2 id="景点游玩整理"><a href="#景点游玩整理" class="headerlink" title="景点游玩整理"></a>景点游玩整理</h2><table><thead><tr><th>方向</th><th>区域</th><th>景点</th><th>特点</th><th>交通</th><th>开放时间</th><th>门票/购票方式</th><th>周边住宿/景点</th><th>美食</th><th>时间</th><th>其他</th></tr></thead><tbody><tr><td>中心<div style="width: 30pt"></td><td><div style="width: 40pt">新宿区</td><td><div style="width: 100pt"><a href="https://www.mafengwo.cn/poi/22535.html">新宿御苑 しんじゅくぎょえん</a></td><td><div style="width: 100pt">大型公园，赏樱花，赏枫，言叶之庭取景地</td><td><div style="width: 150pt">大江户线-国立竞技场、新宿站</td><td><a href="https://www.gotokyo.org/cn/spot/75/index.html">全日，9:00～16:30</a></td><td><div style="width: 150pt">普通票:成人500日元 (1月1日-12月31日 周一-周日) ; 半票:250日元(15岁以上青少年、65岁以上老年人)</td><td><div style="width: 250pt">新宿站步行7分钟</td><td><div style="width: 250pt">待补充</td><td><div style="width: 50pt">1-3小时</td><td></td></tr><tr><td>中心</td><td>新宿区</td><td><a href="https://www.mafengwo.cn/poi/6151659.html">新宿黄金街 新宿ゴールデン街</a></td><td>老街，居酒屋街</td><td>紧邻歌舞伎町街与花园神社，JR山手线新宿站</td><td>全年开放</td><td>无门票</td><td><a href="https://www.gotokyo.org/cn/story/guide/shinjuku-shop/index.html">购物</a>: LUMINE: 年轻潮流<br>大黑屋: 中古店<br>京王百货店:销售化妆品、时装、饰品、玩具、家居用品、日本传统工艺品</td><td><a href="https://www.gltjp.com/zh-hans/directory/item/10362/">超厉害的煮干拉面（すごい煮干(にぼし)ラーメン）</a><br><a href="https://www.klook.com/zh-TW/activity/13174-yakiniku-tei-rokkasen-shinjuku-tokyo/?aid=77&utm_medium=affiliate-alwayson&utm_source=non-network&utm_campaign=77&utm_term=">燒肉亭六歌仙</a>: 烤肉吃到饱, <a href="https://ajgogo.com/2019-09-04-2191/">具体订位方式分享</a><br><a href="https://livejapan.com/zh-tw/in-tokyo/in-pref-tokyo/in-shinjuku/article-a0002669/">其他</a></td><td>2小时</td><td>位于歌舞伎町内，晚上才热闹</td></tr><tr><td>中心</td><td>新宿区</td><td><a href="https://www.mafengwo.cn/poi/6151659.html">歌舞伎町 かぶきちょう</a></td><td>各种娱乐、风俗店</td><td>同上</td><td>全年开放</td><td>无门票</td><td>参考其他</td><td><a href="https://www.mafengwo.cn/poi/6414404.html">矶丸水产(新宿3丁目店) （Isomaru Suisan）</a>: 知名，也有人评价一般；<a href="https://www.mafengwo.cn/poi/8093848.html">蟹道乐(新宿本店)</a>: 蟹的各种吃法，味道可能一般</td><td>3小时以上</td><td>晚上热闹，人很多，也很多黑社会，最好小心，<a href="https://www.cnkirito.moe/tokyo-travel/#%E6%AD%8C%E8%88%9E%E4%BC%8E%E7%94%BA">参考</a></td></tr><tr><td>中心</td><td>千代田区</td><td><a href="https://www.mafengwo.cn/poi/6151659.html">秋叶原 秋葉原 あきはばら アキバ</a></td><td>日本三大电器街<a href="https://www.momoda8.com/morank/54.html">(另一个: 日本桥)</a>、二次元</td><td>中央、总武线 / 银座线: 秋叶原站，步行5分钟，从新宿出发公交30分钟</td><td>全年开放</td><td>无门票</td><td><a href="https://livejapan.com/zh-cn/in-tokyo/in-pref-tokyo/in-akihabara/article-a0004361/">sofmap</a>: 电脑配件</td><td><a href="https://tabelog.com/tokyo/A1310/A131001/13021102">粋な一生ラーメン</a>（评分一般）、<a href="https://tabelog.com/tw/tokyo/A1310/A131001/13219278/dtlrvwlst/">BENGAL</a>（评分居中）</td><td>3小时以上</td><td>打卡点: <a href="https://www.animate.co.jp/shop/akihabara/">ANIMATE: 漫画书、漫画周边</a></td></tr><tr><td>中心</td><td>千代田区</td><td><a href="https://www.gotokyo.org/cn/story/guide/a-noble-look-at-tokyos-imperial-palace-a-guide-to-the-royal-residence/index.html">皇居 こうきょ / 江户城 えどじょう</a></td><td>日本皇室的住所，可以参观 东御苑和外苑</td><td>千代田线 - 大手町站; 中央线 - 东京站</td><td><a href="https://zh.wikipedia.org/zh-hans/%E7%9A%87%E5%B1%85%E6%9D%B1%E5%BE%A1%E8%8B%91">东御苑</a>（皇居東御苑/こうきょひがしぎょえん）全年开放，观光游从周二到周六每天各有2次，可以<a href="https://www.bring-you.info/zh-hans/tokyo-imperial-palace#spot2">在线申请</a>（从<a href="https://sankan.kunaicho.go.jp/index.html">这里</a>看已经申请满了）</td><td><a href="https://cn.tripadvisor.com/Attraction_Review-g1066443-d479262-Reviews-Two_tiered_Bridge_Ni_ju_Bashi-Chiyoda_Tokyo_Tokyo_Prefecture_Kanto.html">二重桥 にじゅうばし</a>（需要先申请）、<a href="https://www.japan-travel.cn/spot/1736/">千鸟渊 千鳥ヶ淵 ちどりがふち</a>（皇居的护城河，赏樱）、<a href="https://www.japan-travel.cn/spot/1718/">日本武道馆</a></td><td>参考其他</td><td>1小时</td><td></td><td></td></tr><tr><td>中心</td><td>涩谷区</td><td><a href="https://www.japan-travel.cn/spot/1666/">明治神宫 明治神宮 めいじじんぐう</a></td><td>明治天皇(1852-1912)与昭宪皇太后，涩谷区中最大的一块绿地</td><td>山手线 - 原宿站; 千代田线或副都心线 - 明治神宫前站</td><td>全年开放</td><td>无门票</td><td>代代木公园</td><td>参考其他</td><td>1小时</td><td></td></tr><tr><td>中心</td><td>涩谷区</td><td><a href="https://www.japan-travel.cn/spot/2177/">涩谷全向十字路口 渋谷スクランブル交差点 Scramble</a></td><td>最经典的十字路口</td><td>涩谷车站八公出口</td><td>全年开放</td><td>无门票</td><td>参考其他</td><td>参考其他</td><td>几分钟</td><td></td></tr><tr><td>中心</td><td>涩谷区</td><td><a href="https://livejapan.com/zh-cn/in-tokyo/in-pref-tokyo/in-shibuya/spot-lj0001987">忠犬八公像 忠犬ハチ公像 ちゅうけんハチ</a></td><td><a href="https://zh.wikipedia.org/zh-sg/%E5%BF%A0%E7%8A%AC%E5%85%AB%E5%85%AC">故事</a>: 为生前习惯去东京涩谷车站迎接其主人上野英三郎教授归来，甚至在主人死后也一直等待了约10年</td><td>涩谷站</td><td>全年开放</td><td>无门票</td><td>参考其他</td><td>参考其他</td><td>几分钟</td><td></td></tr><tr><td>中心</td><td>涩谷区</td><td><a href="https://cn.tripadvisor.com/Attraction_Review-g1066456-d1373790-Reviews-Takeshita_Street-Shibuya_Tokyo_Tokyo_Prefecture_Kanto.html">竹下通 竹下通り たけしたどおり</a></td><td>时装店，小吃</td><td>山手线 - 原宿站</td><td>10:30-20:30</td><td>无门票</td><td>店: ＠cosme TOKYO 旗舰店（美妆）、WITH HARAJUKU 复合式商场</td><td><a href="https://tabelog.com/tokyo/A1306/A130601/13186805/">トッティ キャンディ ファクトリー 原宿店 （Totti Candy Factory）</a>: 巨型彩色棉花糖和粉红少女装<br><a href="https://tabelog.com/tokyo/A1306/A130601/13088711/">マリオンクレープ 原宿竹下通り店 / MARION Crepes 可丽饼</a> 招牌: 特制草莓布朗尼蛋糕＆巧克力生鲜奶油2倍<br><a href="https://tabelog.com/tokyo/A1306/A130601/13218655/">LONG! LONGER!! LONGEST</a>: 日本最长的吉拿棒、日本最长的棉花糖等</td><td>1-2小时</td><td></td></tr><tr><td>中心</td><td>港区</td><td><a href="https://www.japan-travel.cn/spot/1709/">东京塔 东京铁塔 東京タワー / とうきょうタワー</a></td><td>建于1958年，广播塔，东京第二高（2010年晴空塔建成之后），333 米（1,029 英尺），红白相间</td><td>大江户线-赤羽桥; 日比谷线-霞关</td><td>9:00-23:00</td><td>Main Deck（大眺望厅）的入场费为 1200 日元，Top Deck（特别眺望厅）的行程门票是 3,000 日元<br>在<a href="https://www.tokyotower.co.jp/cn/price/">tokyotower（官网）</a>或者<a href="https://www.klook.com/zh-CN/activity/4911-tokyo-tower-main-observatory-ticket-tokyo/">klook</a>可以预定</td><td><a href="https://tokyo.letsgojp.cn/archives/321054/">拍摄地点</a>: 芝公园4号地、赤羽桥车站～「东京铁塔下」（东京タワー下）路口、<a href="https://www.gltjp.com/zh-hant/article/item/12052/#zh-1-12">東京鐵塔停車場樓梯</a>、増上寺（增上寺） × 東京鐵塔、彩虹大橋北側遊步道</td><td><a href="https://beauty-upgrade.tw/23723">东京铁塔内美食</a></td><td>1-2小时</td><td>晚上的票可能比较火爆，需要提前1-2周预订<br>可购买礼品: 千分之一東京鐵塔</td></tr><tr><td>中心</td><td>港区</td><td><a href="https://www.gltjp.com/zh-hans/directory/item/10114/">芝公园 芝公園 しばこうえん</a></td><td>1873 年建成，日本最早的公园，赏花，东京铁塔拍摄地</td><td>浅草线-大门<br>三田线-御成门</td><td>全年开放</td><td>无门票</td><td>东京塔</td><td><a href="https://tabelog.com/matome/3394">参考</a>: クレッセント(法国料理)<br><a href="https://majohouse.com/2016/01/07/nodaiwa-minato/">野田岩</a>（鳗鱼之神）</td><td>1小时</td><td></td></tr><tr><td>中心</td><td>港区</td><td><a href="https://www.mafengwo.cn/poi/6151659.html">台场 台場 だいば</a></td><td>东京湾右下角，看整个东京湾</td><td>山手线-&gt;临海线-东京电讯; 新宿出发约50分钟</td><td>全年开放</td><td>空中列车百合鸥号，可现场或者<a href="https://www.kkday.com/zh-cn/product/28490-asakusa-to-odaiba-tokyo-waterside-water-bus-ride-japan">kkday</a>购买</td><td><a href="https://livejapan.com/zh-cn/in-tokyo/in-pref-tokyo/in-odaiba/spot-lj0002127/?sc_lid=lj_pc_article_spot01">调色板城大摩天轮 パレットタウン</a>（现场购票）<br><a href="https://www.gotokyo.org/cn/spot/39/index.html">台场海滨公园</a>（人工岛，风景不错）<br><a href="https://www.gotokyo.org/cn/story/walks-and-tours/waterfront/rainbow-bridge/index.html">彩虹大桥 レインボーブリッジ，Rainbow Bridge</a>（眺望整个东京湾，看东京塔，步行30分钟）</td><td>参考其他</td><td>2-3小时</td><td><a href="https://japantravel.navitime.com/zh-cn/area/jp/guide/NTJarea0120-zh-cn/">线路推荐: ①筑地→②丰洲→③有明→④台场</a></td></tr><tr><td>中心</td><td>港区</td><td><a href="https://bobby.tw/blog/post/227736584-%E3%80%90%E6%9D%B1%E4%BA%AC%E6%99%AF%E9%BB%9E%E3%80%91%E5%85%AD%E6%9C%AC%E6%9C%A8%E4%B9%8B%E4%B8%98hills%28%E6%96%B0%E5%9F%8E%E5%B1%95%E6%9C%9B%E5%8F%B0%29%EF%BC%9A">六本木之丘 六本木新城森大楼 ろっぽんヒルズ森タワー</a></td><td>观景台，六本木: 最多企业总部的区域，新城</td><td>日比谷线-六本木; 大江户线-六本木</td><td>全年开放</td><td>最晚8点，<a href="https://www.kkday.com/zh-my/product/18946-tokyo-roppongi-hills-mori-tower-observation-deck-ticket-japan">kkday预订</a>，可提前一个月，93元</td><td>参考其他</td><td><a href="https://www.bring-you.info/zh-hans/afuri-ramen">AFURI阿夫利</a>: 拉面店</td><td>1-3小时</td><td><a href="https://www.bring-you.info/zh-hans/roppongi-hot-spots#spot9">【东京六本木景点】六本木之丘、夜景拍摄、逛街、美食、交通、一日游攻略</a></td></tr><tr><td>中心</td><td>中央区</td><td><a href="https://www.mafengwo.cn/poi/6151659.html">银座 銀座 / ぎんざ</a></td><td>逛街<br>主要街区: 銀座通り<br>四丁目</td><td>丸之内线-银座<br>银座线-银座</td><td>全年开放</td><td>无门票</td><td><a href="https://www.gotokyo.org/cn/destinations/central-tokyo/nihombashi/index.html">日本桥 日本橋 / にほんばし</a>: 江户时代，历史和现代的融合</td><td><a href="https://tabelog.com/tokyo/A1301/A130101/13228602/">银座八五</a>: 米其林，「无酱油」淡丽系拉面<br><a href="https://www.bring-you.info/zh-hans/ginzakagari">银座篝(gou)(かがり) 松露鸡白汤拉面</a>: 鸡白汤（鶏パイタン）拉面<br><a href="https://www.bigfang.tw/blog/post/hanayamaudon-ginza">五代目 花山乌冬 银座店</a>: 五公分宽的「鬼ひも川」</td><td>3小时</td><td><a href="https://www.bring-you.info/zh-hans/ginza#musteat">【银座景点】银座一日游逛街去：必逛购物百货公司 &amp; 美食餐厅 &amp; 下午茶甜点 &amp; 住宿推荐</a></td></tr><tr><td>中心</td><td>中央区</td><td><a href="https://www.gotokyo.org/cn/spot/65/index.html">筑地场外市场 築地場外市場 築地市場 / つきじしじょう </a></td><td>海鲜街，小吃</td><td>银座走路7分钟</td><td>全年开放</td><td>无门票</td><td>银座</td><td><a href="https://venuslin.tw/tamagoyaki-tsukiji">筑地山长玉子烧</a><br><a href="https://www.tsukiji.or.jp/shoplist/cat-b/cat-4/230/">吉澤商店 よしざわしょうてん</a>: 肉饼（6:00～13:00）<br><a href="https://tabelog.com/tokyo/A1313/A131301/13145358/">まぐろのみやこ</a>: 海鲜烧<br><a href="https://tabelog.com/tokyo/A1313/A131301/13180099/">そらつき</a>: 草莓大福</td><td>1-3小时</td><td>考虑到吃的东西多，建议早上来<br>参考<a href="https://www.youtube.com/watch?v=ImqrkgHIXGw">自由行视频</a>: 筑地场外市场 -&gt; 东京塔 -&gt; 银座篝</td></tr><tr><td>城南</td><td>世田谷区</td><td><a href="https://www.klook.com/zh-TW/blog/gotokuji-temple-tokyo/">豪德寺 ごうとくじ</a></td><td>充满猫的神社</td><td>千代田线-代代木上原 -&gt; odakyu line: 豪德寺</td><td>全年开放</td><td>无门票</td><td>附近好像没啥其他景点</td><td>参考其他</td><td>1小时，从中心出发时间半小时+</td><td></td></tr><tr><td>城南</td><td>世田谷区</td><td><a href="https://www.mafengwo.cn/poi/6151659.html">下北泽 下北沢 / しもきたざわ</a></td><td>复古安静的购物街道，文艺风</td><td>京王井之头线</td><td>全年开放</td><td>无门票</td><td>明治大学、东京大学</td><td><a href="https://tokyo.letsgojp.cn/archives/72489/">推荐美食</a>: <a href="https://tabelog.com/tokyo/A1318/A131802/13164953/">ポニピリカ: 异国风情汤咖哩</a><br><a href="https://tabelog.com/tokyo/A1318/A131802/13054105/">シティー カントリー シティ （CITY COUNTRY CITY）</a>: 民谣，意大利面，咖啡</td><td>1-2小时</td><td>适合中午下午逛</td></tr><tr><td>城南</td><td>品川区</td><td><a href="https://www.gltjp.com/zh-hant/directory/item/12810/">品川花海道</a></td><td>长2公里的花田</td><td>山手线-&gt;京滨东北线 大井町, 新宿出发1小时</td><td>全年开放</td><td>无门票</td><td>无</td><td><a href="https://www.gltjp.com/zh-hant/directory/item/10742/">東京洋食屋神田Grill Atre大井町店</a>: 洋食老店<br><a href="https://www.gltjp.com/zh-hant/directory/item/12914/">南品川茶箱</a>: 茶屋、甜品，日本茶: 深蒸煎茶; 草莓餡蜜<br><a href="https://www.gltjp.com/zh-hant/directory/item/10221/">Homemade Ramen麥苗</a>: 豚骨汤拉面</td><td>1小时</td><td></td></tr><tr><td>城南</td><td>大田区</td><td><a href="https://www.gotokyo.org/cn/spot/494/index.html">Jonanjima Seaside Park 城南岛海滨公园 城南島海浜公園 じょうなんじまかいひんこうえん</a></td><td>东京湾边缘，沙滩和飞机</td><td>山手线-&gt;京滨东北线 大大森 -&gt; 森32公交, 城南岛四丁目</td><td>全年开放</td><td>无门票</td><td>参考其他</td><td>参考其他</td><td>1-2小时</td><td></td></tr><tr><td>城西</td><td>中野区</td><td><a href="https://www.gotokyo.org/cn/spot/72/index.html">中野百老汇 中野ブロードウェイ</a></td><td>比秋叶原更安静的动漫周边店</td><td>宿08<br>东西线-中野</td><td>全年开放</td><td>无门票</td><td>无</td><td><a href="https://tabelog.com/tokyo/P000094/premiseLst/">参考tabelog</a>: 都比较普通</td><td>1-3小时</td><td></td></tr><tr><td>城北</td><td>板桥区</td><td><a href="https://www.gotokyo.org/cn/spot/ev046/index.html">板桥花火大会</a></td><td><a href="https://itabashihanabi.jp/">官网</a>: 7:00-8:30; <a href="https://itabashihanabi.jp/guide.html">荒天中止</a>, <a href="https://trip.iko-yo.net/events/1404">时隔四年</a>，约 1w3k 发</td><td><a href="https://itabashihanabi.jp/access.html">官方交通说明</a><br>河川敷（カセンシキ）: 从市区出发，银座线-&gt;中阳线-&gt;南武线-&gt;矢川</td><td>8月5日</td><td><a href="https://itabashihanabi.jp/paidseat.html">付费: 陸上競技場席</a>: 凳子 5500 日元</td><td>参考其他</td><td>参考其他</td><td>2小时</td><td><a href="https://cn.tripadvisor.com/Attraction_Review-g1066446-d8820262-Reviews-Itabashi_Fireworks-Itabashi_Tokyo_Tokyo_Prefecture_Kanto.html">观景免费的</a>: 河川敷, Kasenjikikouen Soccer Field<br>需要提前1-2个小时</td></tr><tr><td>城东</td><td>台东区</td><td><a href="https://www.bring-you.info/zh-hans/sensoji-temple">浅草寺 せんそうじ</a></td><td>浅草寺创建于628年，是东京都内最古老的寺院。东京都历史最早的寺院</td><td>银座线; 从住宿出发20分钟, 神田-&gt;浅草 6个站</td><td>全年开放</td><td><a href="https://www.bring-you.info/zh-hans/asakusa-hana-kimono">和服出租(需要提前预约)</a></td><td>路线建议: 雷门 → 接仲见世通（边吃边买约0.5~1hr）  → 穿过宝藏门 → 到浅草寺参拜 → 旁边的浅草神社 → 前往上野、阿美横町、谷中银座、晴空塔<br>雷门: 670公斤重, 1960年重建, 写着风雷神门，象征了两侧的风神和雷神<br><a href="https://www.gotokyo.org/cn/spot/73/index.html">仲见世通(なかみせどおり)</a>: 小吃，工艺品<br>宝藏门后的大草鞋，400公斤重<br>进入浅草寺之前: 把香炉（こうろ）的烟揽到自己身上<br><a href="https://japantravel.navitime.com/zh-cn/area/jp/guide/NTJhowto0142-zh-cn/">洗手</a>: 鞠躬-&gt;右手拿勺清洗左手，左手拿勺清洗右手-&gt;右手拿勺清洗左手-&gt;右手给左手盛水漱口（流过嘴唇就好了）-&gt; 剩下点水清洗左手 -&gt; 倒水，直立柄勺清洗柄勺 -&gt; 再次鞠躬<br>进入神社时尽量靠两边走，中间留给神明<br>参拜:因为是佛教寺院，因此进入山门前鞠躬一次即可，不用击掌<br>投入100元鞠躬-&gt;抽签<br>买御守<br>浅草神社, 1945年空袭中幸免于难 ｜ 参考其他</td><td><a href="https://www.bring-you.info/zh-hans/sensoji-temple">UNIQLO浅草概念店</a>: 浅草寺风格的寺庙</td><td>3小时</td><td></td></tr><tr><td>城东</td><td>台东区</td><td><a href="https://www.japan-travel.cn/spot/1673/">上野公园 上野公園 / うえのこうえん</a></td><td>交通枢纽区的公园，寺庙、各种美术馆和博物馆（东京国立博物馆、国立西洋美术馆、国立科学博物馆、上野动物园）、赏樱，日本的第一座公园</td><td>大江户线-上野御徒町，新宿出发35分钟</td><td>全年开放</td><td>无门票</td><td>阿美横丁、镰仓小町通、上野恩赐公园上野樱花祭</td><td>参考其他</td><td>1小时</td><td></td></tr><tr><td>城东</td><td>台东区</td><td><a href="https://www.japan-travel.cn/spot/1706/">雨横购物街 上野阿美横町 アメヤ横丁 アメヤよこちょう</a></td><td>曾经的黑市，现在的购物天堂</td><td>上野公园走路10分钟</td><td>全年开放</td><td>无门票</td><td><a href="https://www.bring-you.info/zh-hans/ame-yoko">参考</a><br>药妆店: OS drug（オーエスドラッグ）、松本清一店（薬 マツモトキヨシ）、Sundrug（サンドラッグ）<br><a href="https://www.daikokudrug.com/">大国药妆 大國藥妝</a><br><a href="https://bobby.tw/blog/post/228013178-%E3%80%90%E6%9D%B1%E4%BA%AC%E3%80%91%E4%B8%8A%E9%87%8E%E4%BA%8C%E6%9C%A8%E8%8F%93%E5%AD%90%E5%BF%85%E8%B2%B7%EF%BC%9A%E6%9C%80%E5%A4%AF%E6%9A%A2%E9%8A%B7%E6%B8%85%E5%96%AE%EF%BC%8C">二木的菓子 二木の菓子</a>: Alfort帆船餅乾（巧克力）、明治果汁軟糖（100%果汁）、ORIHIRO蒟蒻果凍、iFactory梅干片、UHA味覺糖、日清兵衛豆皮烏龍麵、干贝</td><td><a href="https://www.bring-you.info/zh-hans/yakitori-bunraku">やきとり文乐</a>: 烤鸡</td><td>1-2小时</td><td></td></tr><tr><td>城东</td><td>墨田区</td><td><a href="https://www.gotokyo.org/cn/destinations/eastern-tokyo/skytree-and-around/index.html">东京天空树 东京晴空塔 東京スカイツリー とうきょうスカイツリー</a></td><td>世界第三高，可远观富士山</td><td>从浅草寺出发走路17分钟<br>半藏门线-押上<br>浅草线-押上</td><td>10:00~21:00</td><td><a href="https://www.tokyo-skytree.jp/cn_s/ticket/individual/">官方在线购买</a>, 比线下优惠300日元<br>天望回廊+天望甲板: 2700<br>天望甲板: 1800</td><td>参考其他</td><td>参考其他</td><td>1-2小时</td><td></td></tr><tr><td>城东</td><td>墨田区</td><td><a href="https://www.tokyo-solamachi.jp/cn/">晴空街道 晴空塔城 東京スカイツリータウン Tokyo Skytree Town</a></td><td>商业中心</td><td>东京树旁</td><td>全年开放</td><td>无门票</td><td>晴空街道3楼: 西馆（JUMP SHOP 等动漫专卖店、美食街）、东馆（Uniqlo等平价品牌）<br>4楼: 纪念品</td><td>参考<a href="https://www.tokyo-solamachi.jp/cn/restaurant/">官方推荐</a></td><td>1小时</td><td></td></tr><tr><td>城东</td><td>墨田区</td><td><a href="https://www.gotokyo.org/cn/spot/1745/index.html">江户东京博物馆 東京都江戸東京博物館 とうきょうとえどとうきょうはくぶつかん</a></td><td>江户时代的文物展示</td><td>大江户线-Ryogoku Sta.<br>门33-TOEI-RYŌGOKU-EKI-MAE</td><td>除周一</td><td>600日元门票</td><td>参考其他</td><td>参考其他</td><td>1-2小时</td><td></td></tr><tr><td>城东</td><td>江户川区</td><td><a href="https://www.gltjp.com/zh-hans/directory/item/13909/">Diamond and Flower Ferris Wheel 钻石与花之大摩天轮 ダイヤと花の大観覧车</a></td><td>日本最大的摩天轮，每圈17分钟，东京的右下角</td><td>新宿出发: 新宿线-市谷-&gt;有乐町线-新木场-&gt;京叶线-葛西临海公园</td><td>平时10:00 - 19:00 节假日 10:00 - 20:00</td><td>800日元</td><td>无</td><td>无</td><td>1小时</td><td></td></tr></tbody></table><h3 id="各个景区图片和评论参考"><a href="#各个景区图片和评论参考" class="headerlink" title="各个景区图片和评论参考"></a>各个景区图片和评论参考</h3><h4 id="新宿-新宿御苑"><a href="#新宿-新宿御苑" class="headerlink" title="新宿-新宿御苑"></a>新宿-新宿御苑</h4><p><img src="/2023/07/14/japan-travel-guide-tokyo/tokyo-gyoen-01.jpeg" alt="新宿御苑"></p><p><img src="/2023/07/14/japan-travel-guide-tokyo/tokyo-gyoen-02.jpeg" alt="新宿御苑"></p><h4 id="新宿-新宿黄金街"><a href="#新宿-新宿黄金街" class="headerlink" title="新宿-新宿黄金街"></a>新宿-新宿黄金街</h4><p><img src="/2023/07/14/japan-travel-guide-tokyo/tokyo-shinjukugoruden-01.jpeg" alt="新宿黄金街"></p><h4 id="新宿-歌舞伎町"><a href="#新宿-歌舞伎町" class="headerlink" title="新宿-歌舞伎町"></a>新宿-歌舞伎町</h4><p><img src="/2023/07/14/japan-travel-guide-tokyo/tokyo-kabukicho-01.jpeg" alt="歌舞伎町"></p><h4 id="千代田-秋叶原"><a href="#千代田-秋叶原" class="headerlink" title="千代田-秋叶原"></a>千代田-秋叶原</h4><p><img src="/2023/07/14/japan-travel-guide-tokyo/tokyo-akihabara-01.jpeg" alt="秋叶原"></p><h4 id="千代田-皇居"><a href="#千代田-皇居" class="headerlink" title="千代田-皇居"></a>千代田-皇居</h4><p><img src="/2023/07/14/japan-travel-guide-tokyo/tokyo-koukyo-01.jpeg" alt="皇居"></p><p><img src="/2023/07/14/japan-travel-guide-tokyo/tokyo-koukyo-02.webp" alt="皇居"></p><h4 id="涩谷-明治神宫"><a href="#涩谷-明治神宫" class="headerlink" title="涩谷-明治神宫"></a>涩谷-明治神宫</h4><p><img src="/2023/07/14/japan-travel-guide-tokyo/tokyo-meijijinguu-01.jpeg" alt="明治神宫"></p><p><img src="/2023/07/14/japan-travel-guide-tokyo/tokyo-meijijinguu-02.jpeg" alt="明治神宫"></p><h4 id="涩谷-渋谷スクランブル交差点"><a href="#涩谷-渋谷スクランブル交差点" class="headerlink" title="涩谷-渋谷スクランブル交差点"></a>涩谷-渋谷スクランブル交差点</h4><p><img src="/2023/07/14/japan-travel-guide-tokyo/tokyo-scramble-01.jpeg" alt="涩谷全向十字路口"></p><h4 id="涩谷-忠犬ハチ公像"><a href="#涩谷-忠犬ハチ公像" class="headerlink" title="涩谷-忠犬ハチ公像"></a>涩谷-忠犬ハチ公像</h4><p><img src="/2023/07/14/japan-travel-guide-tokyo/tokyo-chukenhachi-01.jpeg" alt="忠犬ハチ公像"></p><h4 id="涩谷-竹下通り"><a href="#涩谷-竹下通り" class="headerlink" title="涩谷-竹下通り"></a>涩谷-竹下通り</h4><p><img src="/2023/07/14/japan-travel-guide-tokyo/tokyo-takeshitadoori-01.jpeg" alt="竹下通り"></p><p><img src="/2023/07/14/japan-travel-guide-tokyo/tokyo-takeshitadoori-02.jpeg" alt="竹下通り"></p><p>Totti Candy Factory</p><p><img src="/2023/07/14/japan-travel-guide-tokyo/tokyo-takeshitadoori-03.jpeg" alt="竹下通り"></p><p>MARION Crepes</p><p><img src="/2023/07/14/japan-travel-guide-tokyo/tokyo-takeshitadoori-04.jpeg" alt="竹下通り"></p><h4 id="港区-东京塔"><a href="#港区-东京塔" class="headerlink" title="港区-东京塔"></a>港区-东京塔</h4><p><img src="/2023/07/14/japan-travel-guide-tokyo/tokyo-tokyotawa-01.webp" alt="东京塔"></p><p><img src="/2023/07/14/japan-travel-guide-tokyo/tokyo-tokyotawa-02.jpeg" alt="东京塔"></p><h4 id="港区-芝公园"><a href="#港区-芝公园" class="headerlink" title="港区-芝公园"></a>港区-芝公园</h4><p><img src="/2023/07/14/japan-travel-guide-tokyo/tokyo-shibakouen-01.jpeg" alt="芝公园"></p><h4 id="港区-台场"><a href="#港区-台场" class="headerlink" title="港区-台场"></a>港区-台场</h4><p><img src="/2023/07/14/japan-travel-guide-tokyo/tokyo-daiba-01.jpeg" alt="台场"></p><p><img src="/2023/07/14/japan-travel-guide-tokyo/tokyo-daiba-02.jpeg" alt="台场"></p><p><img src="/2023/07/14/japan-travel-guide-tokyo/tokyo-daiba-03.jpeg" alt="台场"></p><p><img src="/2023/07/14/japan-travel-guide-tokyo/tokyo-daiba-04.jpeg" alt="台场"></p><h4 id="中央区-银座"><a href="#中央区-银座" class="headerlink" title="中央区-银座"></a>中央区-银座</h4><p><img src="/2023/07/14/japan-travel-guide-tokyo/tokyo-ginza-01.webp" alt="银座"></p><p><img src="/2023/07/14/japan-travel-guide-tokyo/tokyo-ginza-02.jpeg" alt="银座"></p><p><img src="/2023/07/14/japan-travel-guide-tokyo/tokyo-nihonbashi-01.jpeg" alt="日本桥"></p><p><img src="/2023/07/14/japan-travel-guide-tokyo/tokyo-nihonbashi-02.jpeg" alt="日本桥"></p><h4 id="中央区-筑地场外市场"><a href="#中央区-筑地场外市场" class="headerlink" title="中央区-筑地场外市场"></a>中央区-筑地场外市场</h4><p><img src="/2023/07/14/japan-travel-guide-tokyo/tokyo-tukijishi-01.jpeg" alt="築地場外市場"></p><p><img src="/2023/07/14/japan-travel-guide-tokyo/tokyo-tukijishi-02.jpeg" alt="築地場外市場"></p><h4 id="千代田区-豪德寺"><a href="#千代田区-豪德寺" class="headerlink" title="千代田区-豪德寺"></a>千代田区-豪德寺</h4><p><img src="/2023/07/14/japan-travel-guide-tokyo/tokyo-goutokuji-01.jpeg" alt="豪德寺"></p><h4 id="千代田区-下北泽"><a href="#千代田区-下北泽" class="headerlink" title="千代田区-下北泽"></a>千代田区-下北泽</h4><p><img src="/2023/07/14/japan-travel-guide-tokyo/tokyo-shimokitazawa-01.jpeg" alt="下北泽"></p><p><img src="/2023/07/14/japan-travel-guide-tokyo/tokyo-shimokitazawa-02.jpeg" alt="下北泽"></p><h4 id="板桥区-板桥花火大会"><a href="#板桥区-板桥花火大会" class="headerlink" title="板桥区-板桥花火大会"></a>板桥区-板桥花火大会</h4><p><img src="/2023/07/14/japan-travel-guide-tokyo/tokyo-itabashi-hanabitaikai-01.jpeg" alt="板桥花火大会"></p><p><img src="/2023/07/14/japan-travel-guide-tokyo/tokyo-itabashi-hanabitaikai-02.png" alt="板桥花火大会"></p><h4 id="台东区-浅草寺"><a href="#台东区-浅草寺" class="headerlink" title="台东区-浅草寺"></a>台东区-浅草寺</h4><p><img src="/2023/07/14/japan-travel-guide-tokyo/tokyo-sensouji-01.jpeg" alt="浅草寺"></p><p><img src="/2023/07/14/japan-travel-guide-tokyo/tokyo-sensouji-02.jpeg" alt="浅草寺"></p><h4 id="台东区-上野公园"><a href="#台东区-上野公园" class="headerlink" title="台东区-上野公园"></a>台东区-上野公园</h4><p><img src="/2023/07/14/japan-travel-guide-tokyo/tokyo-uenokouen-01.webp" alt="上野公园"></p><h4 id="台东区-上野阿美横町"><a href="#台东区-上野阿美横町" class="headerlink" title="台东区-上野阿美横町"></a>台东区-上野阿美横町</h4><p><img src="/2023/07/14/japan-travel-guide-tokyo/tokyo-ameya-01.jpeg" alt="上野阿美横町"></p><p><img src="/2023/07/14/japan-travel-guide-tokyo/tokyo-ameya-02.jpeg" alt="上野阿美横町"></p><h4 id="墨田区-东京天空树"><a href="#墨田区-东京天空树" class="headerlink" title="墨田区-东京天空树"></a>墨田区-东京天空树</h4><p><img src="/2023/07/14/japan-travel-guide-tokyo/tokyo-skytree-01.jpeg" alt="东京天空树"></p><p><img src="/2023/07/14/japan-travel-guide-tokyo/tokyo-skytree-02.jpeg" alt="东京天空树"></p><h4 id="墨田区-晴空塔城"><a href="#墨田区-晴空塔城" class="headerlink" title="墨田区-晴空塔城"></a>墨田区-晴空塔城</h4><p><img src="/2023/07/14/japan-travel-guide-tokyo/tokyo-skytree-town-01.jpeg" alt="晴空塔城"></p><h4 id="墨田区-東京都江戸東京博物館"><a href="#墨田区-東京都江戸東京博物館" class="headerlink" title="墨田区-東京都江戸東京博物館"></a>墨田区-東京都江戸東京博物館</h4><p><img src="/2023/07/14/japan-travel-guide-tokyo/tokyo-tokyohakubutukan-01.jpeg" alt="東京都江戸東京博物館"></p><h4 id="江户川区-钻石与花之大摩天轮"><a href="#江户川区-钻石与花之大摩天轮" class="headerlink" title="江户川区-钻石与花之大摩天轮"></a>江户川区-钻石与花之大摩天轮</h4><p><img src="/2023/07/14/japan-travel-guide-tokyo/tokyo-diamondkanlansha-01.jpeg" alt="钻石与花之大摩天轮"></p><h3 id="其他非必逛-未整理景区"><a href="#其他非必逛-未整理景区" class="headerlink" title="其他非必逛/未整理景区"></a>其他非必逛/未整理景区</h3><p>新宿区<br><a href="https://www.gltjp.com/zh-hans/directory/item/10148/">东京都厅观景台</a><br>原因: 开放时间非常少: 每月第1・第3个星期二，观景台</p><p><a href="https://cn.tripadvisor.com/Attraction_Review-g1066457-d1373765-Reviews-Meijijingu_Gaien-Shinjuku_Tokyo_Tokyo_Prefecture_Kanto.html">明治神宫外苑</a><br>原因: 公园类型，赏银杏，秋季比较适合</p><p><a href="https://cn.tripadvisor.com/Attraction_Review-g14133673-d1173749-Reviews-Omoide_Yokocho-Nishishinjuku_Shinjuku_Tokyo_Tokyo_Prefecture_Kanto.html">新宿西口照相机街</a><br>原因: 逛街类型</p><p><a href="https://cn.tripadvisor.com/Attraction_Review-g14133673-d1594916-Reviews-Shinjuku_Chuo_Park-Nishishinjuku_Shinjuku_Tokyo_Tokyo_Prefecture_Kanto.html">新宿中央公园</a><br>公园</p><p>千代田区</p><p><a href="https://www.mafengwo.cn/gonglve/ziyouxing/283852.html">东京站</a><br>最繁忙车站，很复杂，可以购物，打个卡就好，周围的景点适合逛（皇居外苑）</p><p><img src="/2023/07/14/japan-travel-guide-tokyo/tokyo-tokyoeki-01.webp" alt="东京站"></p><p><a href="https://cn.tripadvisor.com/Attraction_Review-g1066443-d555799-Reviews-Yasukuni_Shrine-Chiyoda_Tokyo_Tokyo_Prefecture_Kanto.html">靖国神社</a><br>你懂的</p><p><a href="https://ikidane-nippon.com/zh-Hans/spots/nippon-budokan">日本武道馆</a><br>竞技场，演唱会</p><p>涩谷区<br><a href="https://cn.tripadvisor.com/Attraction_Review-g1066456-d561514-Reviews-Yoyogi_Park-Shibuya_Tokyo_Tokyo_Prefecture_Kanto.html">代代木公园</a></p><p>港区</p><p><a href="https://cn.tripadvisor.com/Attraction_Review-g14129743-d1574646-Reviews-Tokyo_Midtown-Akasaka_Minato_Tokyo_Tokyo_Prefecture_Kanto.html">东京中城</a><br>购物中心，奢侈品</p><p>中央区</p><p><a href="https://cn.tripadvisor.com/Attraction_Review-g14129573-d1373683-Reviews-Kabukiza_Theater-Ginza_Chuo_Tokyo_Tokyo_Prefecture_Kanto.html">歌舞伎剧场</a></p><p><a href="https://www.japan-travel.cn/spot/1653/">滨离宫恩赐庭园</a><br>曾经的皇家庭园</p><p>文京区</p><p><a href="https://www.gotokyo.org/cn/spot/22/index.html">六义园</a><br>江户代表性回游式假山泉水庭园</p><p><a href="https://www.gotokyo.org/cn/spot/24/index.html">小石川后乐园 小石川後楽園</a><br>东京最美的日本庭园</p><p><a href="https://www.gotokyo.org/tc/destinations/central-tokyo/tokyo-dome-and-around/index.html">东京巨蛋</a><br>体育项目，餐厅</p><p>世田谷区<br><a href="https://www.gotokyo.org/cn/spot/901/index.html">Kinuta Park 砧公园 砧公園 / きぬたこうえん</a><br>840棵樱花树</p><p>目黑区</p><p><a href="https://topmuseum.jp/chi/contents/pages/about_history.html">东京摄影美术馆</a><br>摄影和影像作品的综合性美术馆</p><p><a href="https://www.aquarium.gr.jp/">品川水族馆</a><br>水族馆<br>门票: <a href="https://www.klook.com/zh-CN/activity/5609-aqua-park-shinagawa-ticket-tokyo/">klook</a>、<a href="https://www.kkday.com/zh-cn/product/18689-tokyo-maxell-aqua-park-shinagawa-ticket-japan">kkday</a></p><p>杉并区</p><p><a href="https://cn.tripadvisor.com/Attraction_Review-g1066458-d1594552-Reviews-Wadabori_Park-Suginami_Tokyo_Tokyo_Prefecture_Kanto.html">Wadabori Park 和田堀公園</a><br>赏樱</p><p>练马区</p><p><a href="https://www.gotokyo.org/cn/spot/656/index.html">东京千寻美术馆 ちひろ美術館</a><br>水彩画主题展，美术作品</p><p><a href="https://www.gotokyo.org/cn/spot/433/index.html">石神井公园</a><br>东京最大的绿地, 新宿40分钟</p><p>荒川区</p><p><a href="https://www.gotokyo.org/jp/destinations/northern-tokyo/nippori/index.html">日暮里繊維街 日暮里ガイド</a><br>购物</p><p>丰岛区<br><a href="https://cn.tripadvisor.com/Attraction_Review-g1066460-d1425386-Reviews-Sunshine_Aquarium-Toshima_Tokyo_Tokyo_Prefecture_Kanto.html">阳光水族馆</a></p><p>台东区<br><a href="https://cn.tripadvisor.com/Attraction_Review-g14134311-d2492312-Reviews-Asakusa_Shrine-Asakusa_Taito_Tokyo_Tokyo_Prefecture_Kanto.html">浅草神社</a><br>可以体验和服</p><p><a href="https://www.japan-travel.cn/spot/663/">东京国立博物馆</a><br>日本艺术、其他国家的文物, <a href="https://www.mafengwo.cn/poi/7408.html">东洋馆</a>中展示的大部分中国的，如<a href="https://zh.wikipedia.org/zh-sg/%E7%A5%AD%E5%A7%AA%E6%96%87%E7%A8%BF">祭侄文稿</a></p><p>丰岛区</p><p><a href="https://www.gltjp.com/zh-hans/directory/item/10844/">目白庭园</a><br>典型日本庭院</p><p>参考资料:</p><p><a href="https://zhuanlan.zhihu.com/p/457227817">你了解东京吗？全方位详解日本东京23个区</a></p><p><a href="https://cn.tripadvisor.com/Attractions-g1066444-Activities-a_allAttractions.true-Chuo_Tokyo_Tokyo_Prefecture_Kanto.html">中央区景点玩乐</a></p><p><a href="https://travo.guide/japan/tokyo/best-attractions-in-minato/">【2023東京旅遊攻略】東京港區熱門景點推薦 (東京鐵塔、台場、六本木之丘)</a></p><p><a href="https://zhuanlan.zhihu.com/p/429339891">东京大田区，这些漂亮的小众拍照景点，不要错过</a></p><p>新宿区</p><p><a href="https://cn.tripadvisor.com/Attractions-g1066457-Activities-Shinjuku_Tokyo_Tokyo_Prefecture_Kanto.html">新宿区景点玩乐</a></p><p><a href="https://livejapan.com/zh-cn/in-tokyo/in-pref-tokyo/in-shinjuku/article-a0003768/">新宿散策必备！新宿各区域必访推荐景点指南</a></p><p>涩谷区</p><p><a href="https://www.bring-you.info/zh-hans/harajuku">【原宿逛街地图】原宿、竹下通好逛平价潮流服饰&amp;美食攻略，东京年轻人的购物景点</a></p><p><a href="https://tabelog.com/matome/22451/">tabelog-竹下通りで人気の食べ物！食べ歩き・イートイングルメ20選</a></p><p><a href="https://cn.tripadvisor.com/Tourism-g1066854-Shinagawa_Tokyo_Tokyo_Prefecture_Kanto-Vacations.html">品川区</a></p><p><a href="https://tokyo.letsgojp.cn/archives/525311/">东京「练马区」景点推荐！朝圣动漫圣地、松屋创始店、哈利波特主题乐园</a></p><p><a href="https://newtaipei.travel/zh-cn/regional/sightseeing/1">newtaipei-板桥</a></p><p><a href="https://www.adachikanko.net/zh-CHS/recommend/adachi_spot">足立区的观光路线和景点介绍</a></p><p>目黑区<br><a href="https://resources.realestate.co.jp/zh_CN/area-guide/%E7%9B%AE%E9%BB%91%E5%8C%BA%E6%8C%87%E5%8D%97-%E4%B8%9C%E4%BA%AC%E5%9C%B0%E5%8C%BA%E6%8C%87%E5%8D%97/">樱花道</a></p><p><a href="http://www.bytravel.cn/view/top10/index4091.html">台东区十大旅游景点</a></p><p><a href="https://www.gltjp.com/zh-hans/article/item/20114/">观光&amp;体验&amp;购物&amp;美食！东京都江东区观光指南！</a></p><p><a href="http://digjapan.travel/zh_cn/digest/katsushika.html">东 京 葛 饰</a></p><h2 id="东京地图和区域介绍"><a href="#东京地图和区域介绍" class="headerlink" title="东京地图和区域介绍"></a>东京地图和区域介绍</h2><p><img src="/2023/07/14/japan-travel-guide-tokyo/tokyo-area-03.jpeg" alt="东京23区治安地图"></p><p><a href="https://tokyo.letsgojp.com/archives/459880/">参考: 東京23區「治安最差」是哪區？喜歡一人旅行的要注意！</a></p><h3 id="23区"><a href="#23区" class="headerlink" title="23区"></a>23区</h3><h4 id="基本划分"><a href="#基本划分" class="headerlink" title="基本划分"></a>基本划分</h4><p>城南地区<br>世田谷区、目黑区、品川区、大田区</p><p>城西地区<br>杉並区、中野区</p><p>都心六区<br>新宿区、千代田区、涩谷区、港区、中央区、文京区</p><p>城北地区<br>练马区、板桥区、北区、豊岛区</p><p>城东地区<br>足立区、荒川区、台东区、墨田区、江东区、葛饰区、江户川区</p><p><a href="https://zhuanlan.zhihu.com/p/355390878">日本东京城南地区、城西地区（解析）</a></p><p><a href="https://zhuanlan.zhihu.com/p/357462159">日本东京城北地区、城东地区（解析）</a></p><h4 id="表格整理"><a href="#表格整理" class="headerlink" title="表格整理"></a>表格整理</h4><p><a href="https://www.zhihu.com/question/24494333">东京各区的特点是怎样的？</a></p><table><thead><tr><th>方向</th><th>区域</th><th>特点</th><th>主要景点</th></tr></thead><tbody><tr><td>中心<div style="width: 30pt"></td><td>新宿区</td><td>交通枢纽，商业街，不眠</td><td>歌舞伎町，新宿车站</td></tr><tr><td>中心</td><td>千代田区</td><td>大部分行政机关所在地，大型企业</td><td>东京展、秋叶原、日本武道馆</td></tr><tr><td>中心</td><td>涩谷区</td><td>商业百货</td><td>井ノ頭通り（十字路口）</td></tr><tr><td>中心</td><td>港区</td><td>最有逼格，电视台总部</td><td>六本木，东京塔，芝公园</td></tr><tr><td>中心</td><td>中央区</td><td>位于东京中心，经济中心</td><td>日本桥、银座</td></tr><tr><td>中心</td><td>文京区</td><td>文化和住宅</td><td>东京大学，东京巨蛋</td></tr><tr><td>城南</td><td>世田谷区</td><td>人口最多，密集住宅</td><td>豪德寺，下北泽</td></tr><tr><td>城南</td><td>目黑区</td><td>住宅，樱花</td><td>东京摄影美术馆，品川水族馆</td></tr><tr><td>城南</td><td>品川区</td><td>港口</td><td>品川花海道</td></tr><tr><td>城南</td><td>大田区</td><td>机场，高档住宅</td><td>城南岛海滨公园</td></tr><tr><td>城东</td><td>足立区</td><td>人气不高，治安不好</td><td>タカラ湯 Takarayu</td></tr><tr><td>城东</td><td>荒川区</td><td>穷，路面电车</td><td>Nippori Fabric Town</td></tr><tr><td>城东</td><td>台东区</td><td>以前也穷，日本人不想住</td><td>浅草寺，上野公园，上野阿美横町</td></tr><tr><td>城东</td><td>墨田区</td><td>相扑文化</td><td>江户东京博物馆，东京晴空塔</td></tr><tr><td>城东</td><td>江东区</td><td>东南面，填海，年轻人喜欢</td><td>丰洲市场，森大厦数位艺术美术馆：teamLab无界，日本科学未来馆</td></tr><tr><td>城东</td><td>葛饰区</td><td>老东京，安静，漫画家</td><td>葛饰纳凉花火大会，水元公园</td></tr><tr><td>城东</td><td>江户川区</td><td>外国人多</td><td>葛西临海水族园、东京葛西临海公园、钻石与花之大摩天轮</td></tr><tr><td>城西</td><td>杉並区</td><td>高级住宅，文化底蕴</td><td>大田黑公園、大宮八幡宮</td></tr><tr><td>城西</td><td>中野区</td><td>交通非常方便，人口密度高，低层住宅</td><td>中野百老匯、薬師あいロード商店街、昭和新道</td></tr></tbody></table><h4 id="千代田区"><a href="#千代田区" class="headerlink" title="千代田区"></a>千代田区</h4><p><a href="https://zh.wikipedia.org/wiki/%E5%8D%83%E4%BB%A3%E7%94%B0%E5%8D%80">千代田区</a>（日语：千代田区／ちよだく Chiyoda ku */?）是日本东京都的特别区之一，位于东京都区部的中心位置，在1947年（昭和22年）3月15日由麹町区与神田区合并而来，名称来自于江户城的别名“千代田城”。日本国会、首相官邸、最高法院、大部分中央行政机关，以及天皇住所皆座落于此，而区内的<strong>大手町、丸之内、有乐町</strong>等商圈，是许多日本大型企业总部的聚集地，因而使该区成为日本首屈一指的政治与经济中枢。<strong>东京站、秋叶原</strong>、靖国神社、神保町古书街、<strong>日本武道馆</strong>等著名景点亦位于该区内，该区住有许多政治家及公务员</p><p><img src="/2023/07/14/japan-travel-guide-tokyo/tokyo-chiyoda-01.png" alt="千代田区"></p><p><img src="/2023/07/14/japan-travel-guide-tokyo/tokyo-chiyoda-02.webp" alt="千代田区"></p><h4 id="中央区"><a href="#中央区" class="headerlink" title="中央区"></a>中央区</h4><p><a href="https://zh.wikipedia.org/zh-sg/%E4%B8%AD%E5%A4%AE%E5%8D%80_(%E6%9D%B1%E4%BA%AC%E9%83%BD)">中央区</a>（日语：中央区／ちゅうおうく Chūō ku */?）是日本东京都内的23个特别区之一，由于其位于23区的正中央位置之故，因而得名。</p><p>中央区不仅地理位置处于东京的中心地，更是日本经济、信息、商业等的中心。著名的日本银行、东京证券交易所等日本经济核心都位于中央区。除此之外，包括银座、大型布庄与百货公司总社聚集的<strong>日本桥</strong>、以及以鱼货市场闻名的筑地皆位于本区范围之内。</p><p>大约位于东京23区的中央。区内有日本桥、八重洲・筑地、月岛、银座等街区。</p><p>面积为10.094km²，是东京23区中第二小的特别区，仅次于台东区。</p><p>人口130,483人，次于千代田区（2013年6月1日）。（2013年4月定居人口达13万人，是1967年以来的新高）区内有日本桥与银座等大型商业区域，让日间人口达60.6万人。此外，本区商业强烈，高楼林立，住宅方面以高层公寓与团地等集合住宅为主，独户低层住宅或低层分租公寓较为少见（多在南部的佃和月岛附近）。</p><p>道路呈现棋盘状，与他区相比较为整齐。</p><p><img src="/2023/07/14/japan-travel-guide-tokyo/tokyo-chuo-01.png" alt="中央区"></p><h4 id="港区"><a href="#港区" class="headerlink" title="港区"></a>港区</h4><p><a href="https://zhuanlan.zhihu.com/p/508954033">港区</a>（日语：港区 みなとく Minato ku */?）是日本东京都23个特别区之一，位于东京都心东南方、紧邻东京湾，以聚集诸多外国大使馆、<strong>国际气氛浓厚</strong>著称。区内较著名的商圈，包括聚集众多企业的赤坂、新桥、滨松町等商务街，外国观光客与酒吧云集的<strong>六本木</strong>，高级住宅区的麻布和白金台，高级商店街的青山，新兴观光区台场、以及进入2002年以来逐步开发完成的三个大型复合开发区——六本木新城、东京中城、以及汐留SIO-SITE。东京地标之一的东京铁塔亦位于区内</p><p>港区设立于1947年，由旧芝区、旧麻布区、旧赤坂区三区合并诞生。港区位于东京23区中央偏南，是拥有最多企业总部的区域，可说是日本企业的中心。其中、虎之门、新桥、芝为重要的办公商区，经济活动十分活跃。青山、赤坂等商业地区，六本木等娱乐重镇，麻布、白金台等住宅区，汐留、台场等大规模开发区，为港区展现各种不同风貌。东宫御所、迎宾馆（赤坂离宫）与芝公园、白金台的国立科学博物馆附属自然教育园等绿色地带带来丰富的自然环境。驻日大使馆与外资企业的大量进驻，让本地的外国人居住者比例达一成之多</p><p><img src="/2023/07/14/japan-travel-guide-tokyo/tokyo-minato-01.png" alt="港区"></p><h4 id="新宿"><a href="#新宿" class="headerlink" title="新宿"></a>新宿</h4><p><a href="https://zh.wikipedia.org/zh-sg/%E6%96%B0%E5%AE%BF%E5%8D%80">新宿区</a>（日语：新宿区／しんじゅくく Shinjuku ku */?）是日本东京都的特别区之一，为东京都厅（都政府）所在地。区内的新宿站为东京主要的交通枢纽之一，而以新宿站为中心的商圈（包括新宿副都心），为东京乃至于整个日本首要的中心商业区</p><p>新宿区位在东京市区内中央偏西的地带，区内的新宿车站是东京市区西侧最重要的交通要冲之一，包括JR山手线、JR中央本线、JR总武线与私铁公司京王电铁、小田急电铁的总部都位在新宿车站，周围还有数条地铁线行经。日本各地往来东京的长途巴士也大多停靠新宿，或以新宿为起站、终站。</p><p>以新宿车站为中心，以西（新宿西口）的西新宿是东京都政府在战后规划的中心商业区，又称为“新宿新都心”，东京都的行政中心东京都厅舍就位在此处，除此之外周遭还包围了许多大型企业总部所使用的摩天大楼，此超高层建筑群是东京最早形成的类似区域。新宿车站南口方向则是百货公司与商店街云集的商业地区，其中最著名的包括连锁百货公司高岛屋的旗舰店“高岛屋时代广场”（Takashimaya Times Square）与知名日本连锁书店纪伊国屋的总店。</p><p>相对于西新宿的现代化与整齐，新宿车站以东的东新宿地区（新宿东口），则是最热闹也是最混乱的传统商业街地区，其中，闻名海外的红灯区——<strong>歌舞伎町</strong>，便位于新宿东口范围内。</p><p>在非常受欢迎的日本漫画《城市猎人》中，就是以新宿车站东口公园作为最主要的舞台。</p><p>2016年大卖的动画电影《你的名字。》中，新海诚导演从新宿区多处景点取景，如：新宿警察署地景、<strong>新宿车站</strong>、千駄谷站、信浓町陆桥、四谷须贺町等</p><p><img src="/2023/07/14/japan-travel-guide-tokyo/tokyo-shinjuku-01.png" alt="新宿"></p><p><img src="/2023/07/14/japan-travel-guide-tokyo/tokyo-shinjuku-02.png" alt="新宿"></p><h4 id="文京区"><a href="#文京区" class="headerlink" title="文京区"></a>文京区</h4><p><a href="https://zhuanlan.zhihu.com/p/510447669">文京区</a>（日语：文京区／ぶんきょうく Bunkyō ku */?）是日本东京都的23个特别区之一，划分上属于23区西部，实际位于中央偏北的位置，现任区长是成泽广修[2]。文京区的面积11.31平方千米，在23区中位列倒数第4，占东京都区部的50分之一[3]。</p><p>该区以文化教育机关和住宅街区为主，有“文之京”的美名。从明治时期以来，这里居住过夏目漱石、森鸥外、宫泽贤治等著名的文人、学者和政治家。除此以外出版、印刷业也很繁盛，并设有先进医疗设施和大型医院。区内著名的设施包括日本最高学府东京大学本部（本乡校区）、<strong>东京巨蛋</strong>和讲道馆等，六义园、后乐园和小石川植物园等古老而宽广的日本庭园也坐落于文京区内</p><p><img src="/2023/07/14/japan-travel-guide-tokyo/tokyo-bunkyo-01.png" alt="文京区"></p><h4 id="品川区"><a href="#品川区" class="headerlink" title="品川区"></a>品川区</h4><p><a href="https://zhuanlan.zhihu.com/p/506260123">品川区</a>（日语：品川区 しながわく Shinagawa ku */?）是日本东京都的特别区之一，位于东京都的南部，东濒东京湾，为东京市区聚集较多<strong>港口及工业设施</strong>的地带。名称是由境内河川目黑川的别名“品川”而来</p><p><img src="/2023/07/14/japan-travel-guide-tokyo/tokyo-shinagawa-01.jpeg" alt="品川"></p><p><img src="/2023/07/14/japan-travel-guide-tokyo/tokyo-shinagawa-02.png" alt="品川"></p><h4 id="目黑区"><a href="#目黑区" class="headerlink" title="目黑区"></a>目黑区</h4><p><a href="https://zhuanlan.zhihu.com/p/513564096">目黑区</a>（日语：目黒区／めぐろく Meguro ku */?）是日本东京都下辖的特别区之一<br>东京23区西南部，主要为住宅区</p><p>目黑区位于东京的中央六区的西侧、涩谷区的南侧，是东京主要的住宅行政区之一。目黑区内有许多以低调高级住宅区而闻名的社区，例如柿之木坂、碑文谷、青叶台和驹场，以及自由之丘和中目黑等住商混合的区域。目黑区以其宁静悠闲的居住环境、富饶绿地、池塘和河川以及靠近涩谷、代官山、惠比寿和六本木的便利交通位置，成为居住在东京的欧美人士的人气居住选择</p><p>目黑区最广为人知的是目黑川沿岸种植的<strong>樱花树道</strong>，在一年一度的樱花季，河川两旁的人行道上挤满了前来赏樱花盛开的游客。目黑川沿岸也是受欢迎的高档住宅区，这里可以找到许多适合外国人居住的买/租房选择。 例如，距离目黑车站仅7分钟路程、位于目黑川畔、25层高的高层塔楼公寓MFPR目黑塔（MFPR目黒タワー）。目黑川畔沿岸还有许多中低层的公寓楼，很适合外国人的生活</p><p><img src="/2023/07/14/japan-travel-guide-tokyo/tokyo-meguro-01.png" alt="目黑"></p><h4 id="大田区"><a href="#大田区" class="headerlink" title="大田区"></a>大田区</h4><p><a href="https://zh.wikipedia.org/wiki/%E5%A4%A7%E7%94%B0%E5%8C%BA">大田区</a>（日语：大田区／おおたく Ōta ku */?）是日本东京都的特别区之一，位于东京都<strong>东南、正对东京湾</strong>。自古以来是捕鱼业发达的地区、大正时代以后形成小作坊的聚集地、至今形成了京滨工业地带。区内的东京国际机场（羽田机场）是东京的空中门户。</p><p>日本著名的高级住宅区田园调布的部分地区位于该区西部。</p><p><img src="/2023/07/14/japan-travel-guide-tokyo/tokyo-oota-02.png" alt="大田"></p><h4 id="世田谷区"><a href="#世田谷区" class="headerlink" title="世田谷区"></a>世田谷区</h4><p><a href="https://zhuanlan.zhihu.com/p/514865103">世田谷区</a>（日语：世田谷区／せたがやく Setagaya ku */?），是日本东京都区部之一，位于东京23区的<strong>西南</strong>部，以其居住环境良好的住宅区而闻名。世田谷区为东京都特别区中面积第2大，也是全日本人口最多的特别区；人口密度亦排在第14位。</p><p>世田谷区是东京23区中人口最多、面积第二大的行政区。不仅日本人，对于外国人来说也是广为人知的高档<strong>住宅区</strong>所在地，距离新宿和涩谷的车程极短，非常方便通往东京市中心。世田谷区位于东京23区的西南部，其南侧的多摩川邻接神奈川县，在地理上和象征意义上是东京郊区与市中心的边界线。</p><p>世田谷区由北到南可以分为五个地域：乌山、北泽、砧、世田谷和玉川。世田谷区域相当辽阔，从充满文青艺术气息的下北泽个性商店街（北泽地域）、寺庙群聚有如小京都的千岁乌山（乌山地域）、东京人理想居住街区的三轩茶屋（世田谷地域）、东京知名高级住宅区的成城（砧地域）、到乐天总部所在地、商业购物大楼、家庭社区和自然公园一应具全的二子玉川（玉川地域）。</p><p><img src="/2023/07/14/japan-travel-guide-tokyo/tokyo-setagaya-01.jpeg" alt="世田谷区"></p><h4 id="涩谷区"><a href="#涩谷区" class="headerlink" title="涩谷区"></a>涩谷区</h4><p><a href="https://zh.wikipedia.org/zh-sg/%E6%BE%80%E8%B0%B7%E5%8D%80">涩谷区</a>（日语：渋谷区／しぶやく Shibuya ku */?）[1]是日本东京都的特别区之一，其名称源自于位于该区<strong>中央</strong>、以涩谷站为中心的涩谷地区。</p><p>与新宿、池袋等因为位处于交通要冲上而发展出的商业街相同，涩谷也是因为位居山手线重要转运站的地位而发展成今日的盛况。其为东急集团的大本营，且各种商业活动兴旺，这尤其表现在涩谷站忠犬八公出口处，著名的百货店、时装专卖店、饮食店、咖啡店、休闲设施、特种行业等密集如云，是与新宿同样并列为“24小时不眠之街”的地区。另外，以西武百货、东急百货、巴而可（パルコ）与109百货为中心，再加上周边许多服饰店所构成的商店街街区，是最受东京年轻消费族群喜爱的购物胜地，向来拥有“年轻人之街”之美称，也使得涩谷成为日本国内外各种流行风尚的发源地。而<strong>涩谷车站八公口外</strong>、具有行人保护时相配置、属井之头通（<strong>井ノ頭通り いのかしらどおり</strong>）一部分的大型五叉路口，由于超高的行人穿越量经常被誉称为“全世界最大的交叉路口”，其庞大的行人流通量成为许多观光客参访与摄影、拍照的圣地，也经常出现在电视或电影剧情中，成为东京的象征</p><p><img src="/2023/07/14/japan-travel-guide-tokyo/tokyo-shibuya-01.png" alt="涩谷区"></p><p><img src="/2023/07/14/japan-travel-guide-tokyo/tokyo-shibuya-02.png" alt="涩谷区"></p><p><a href="https://bienetrevoyage.blogspot.com/2016/04/shibuya-map.html">图片来源</a></p><h4 id="中野区"><a href="#中野区" class="headerlink" title="中野区"></a>中野区</h4><p><a href="https://zh.wikipedia.org/zh-sg/%E4%B8%AD%E9%87%8E%E5%8D%80">中野区</a>（日语：中野区／なかのく Nakano ku */?）是日本人口密度最高的底层住宅区域，位处东京都<strong>西部</strong>。区内产业主要以<strong>第三产业的服务业</strong>为中心，而事业所及从业人员个数则处于东京23区的中下位。</p><p><img src="/2023/07/14/japan-travel-guide-tokyo/tokyo-nakano-01.png" alt="中野区"></p><h4 id="杉并区"><a href="#杉并区" class="headerlink" title="杉并区"></a>杉并区</h4><p><a href="https://zhuanlan.zhihu.com/p/514857580">杉并区</a>（すぎなみく）是东京23个特别区中最内陆的行政区之一，它被夹在同属属于城西地区的练马区和世田谷区之间。对于在东京市区上班或念书的人来说，此区是一个相当不错的住宅区选择。因为 JR中央线上的许多车站位于杉并区（例如荻洼、阿佐谷、高圆寺）。</p><p><img src="/2023/07/14/japan-travel-guide-tokyo/tokyo-suginami-01.png" alt="中野区"></p><h4 id="丰岛区"><a href="#丰岛区" class="headerlink" title="丰岛区"></a>丰岛区</h4><p>丰岛区（日语：豊島区／としまく Toshima ku */?）是日本东京都内23个特别区之一，位在旧东京市的区域内西北角一带。其命名由来源自日本政府进行“废藩置县”之前，武藏国丰岛郡的古名，当东京市在进行行政区域扩大时，四个原属北丰岛郡的町被合并划入东京市的范围之内，而赋予丰岛区的命名。</p><p>丰岛区是一个人口密度高，且集时尚与传统、年轻与老年于一体、富有个性的区域。境内最重要的市街为<strong>池袋</strong>车站为中心的商业区，除此之外，驹込、有“老年人的原宿”之称的巢鸭、大冢、高级住宅区的目白等地区都是丰岛区境内比较知名的市街，东京市区内最重要的铁路路线JR山手线在这几个地区都设有车站。</p><p>曾经是东京都内第一高楼的太阳城（サンシャインシティ）就位在区内的池袋地区。区役所位于JR山手线池袋站东口。</p><p>根据1965年的国势调查结果，本区为日本人口密度最高的自治体（前回调查的第一名为1东京都台东区）[1]（页面存档备份，存于互联网档案馆）。2005年的国势调查，仅次于东京都中野区为全日本第二位，2010年再次成为第一。</p><p><img src="/2023/07/14/japan-travel-guide-tokyo/tokyo-toshima-01.jpeg" alt="丰岛区"></p><h4 id="北区"><a href="#北区" class="headerlink" title="北区"></a>北区</h4><p><a href="https://zhuanlan.zhihu.com/p/514567481">北区</a>实际上就是东南西北的“北区”，因其地处东京最北端的地区之一，北侧隔着荒川与埼玉县的川口市和户田市相邻，东侧隔着隅田川与足立区相邻、东南侧和荒川区接壤、西侧和板桥区接壤、南侧则和丰岛区和文京区接壤。</p><p>与东京北部的大部分地区一样，北区的居民主要是劳工阶级家庭、单身上班族以及越来越多的外国居民（主要来自亚洲国家）。北区有四条河川纵横交错，拥有富饶的绿色空间，并且平民化的物价，使其成为非常适合家庭居住的行政区。</p><p>北区是东京23区中车站最多的行政区，主要车站前往崎玉县、东京市中心甚至神奈川县都相当方便。北区的主要住宅区包括：十条、赤羽和王子。北区的外国居民主要来自亚洲（依序是中国、韩国、越南、菲律宾、尼泊尔和台湾）。当东京国际法国学校（Lycée Français International de Tokyo）于2012年将校舍迁移至北区泷野川时，也为北区增添了点西洋国际色彩。但总体而言，北区给人蓝领阶级和下町风情的印象。</p><p><img src="/2023/07/14/japan-travel-guide-tokyo/tokyo-kita-01.png" alt="北区"></p><h4 id="板桥区"><a href="#板桥区" class="headerlink" title="板桥区"></a>板桥区</h4><p><a href="https://zhuanlan.zhihu.com/p/512959361">板桥区</a>（いたばし）是东京北部行政区之一，其北侧隔着荒川和埼玉县户田市相邻、西侧和埼玉县和光市接壤。板桥区的气氛宁静、朴素低调、适合家庭居住，许多自然公园和河川河堤蜿蜒穿过恬静住宅区。</p><p>板桥区的外国居民主要来自亚洲（依序是中国、韩国、越南、菲律宾、尼泊尔）板桥区是东京23区中，中国居民第3多的行政区。但东京国际法国学校（Lycée Français International de Tokyo）于当2012年将校舍迁移至北区泷野川时，由于板桥区的新板桥站实际上是离该校最近的车站，大多数乘电车上下课的法国学生都会在新板桥站或板桥站上下车，因此也为板桥区添增了西方色彩。</p><p>板桥区虽然不是东京市中心（除了住宅区就是以日用品制造业为主的中小工场）。但是，这种远离城市喧嚷的环境提供当地居民悠闲生活和亲近绿色空间的优势。板桥区主要车站都在搭电车至池袋、新宿和大手町等主要车站不到30分钟或约30分钟的通勤范围内</p><p><img src="/2023/07/14/japan-travel-guide-tokyo/tokyo-itabashi-01.png" alt="板桥区"></p><h4 id="练马区"><a href="#练马区" class="headerlink" title="练马区"></a>练马区</h4><p><a href="https://zhuanlan.zhihu.com/p/510946883">练马区</a>（日语：練馬区／ねりまく Nerima ku */?）是东京23区中人口第二多的行政区（仅次于世田谷区），突显了其作为住宅区的受欢迎程度。练马区北侧与埼玉县和光市接壤、东侧为板桥区、其西侧与西东京市接壤，南侧则与中野区、杉并区和武藏野市接壤。练马区和这些相邻接的地区都是东京西郊的主要居住社区。</p><p>练马区以拥有众多的漫画家而闻名，有“日本动漫发祥地”之称。著名的日本漫画《哆啦A梦》《忍者小灵精》以及《机器人少女Z》、《四月是你的谎言》的故事场景就在本区（光丘）。这里是《东京食尸鬼》故事的主要舞台，包括著名经典恐怖片《咒怨》的那座“鬼屋”也在此行凶作恶。闻名的游乐地丰岛园亦在本区。练马区是加速世界(AW)中日珥（Prominence) 的领土</p><p><img src="/2023/07/14/japan-travel-guide-tokyo/tokyo-rerimaku-01.png" alt="练马区"></p><h4 id="城东地区"><a href="#城东地区" class="headerlink" title="城东地区"></a>城东地区</h4><h4 id="台东区"><a href="#台东区" class="headerlink" title="台东区"></a>台东区</h4><p><a href="https://zhuanlan.zhihu.com/p/511277935">台东区</a>（日语：台東区／たいとうく Taitō ku */?）是东京23区中面积最小的行政区，却是最古老最著名的江户下町街区所在地。广受外国游客欢迎的<strong>浅草</strong>位于台东，在那里可以找到东京历史最悠久的寺庙“<strong>浅草寺</strong>”。探索浅草周边地区是了解东京历史的绝佳方式，因为这里是东京最古老的市街区许多神社每年都会举行各种传统节日祭典，例如每年5月于浅草神社举行的三社祭。</p><p>台东区也是<strong>上野阿美横丁、上野恩赐公园</strong>（含博物馆、美术馆）和<strong>上野动物园</strong>的所在地，非常受当地居民和国内外游客欢迎。台东区以商业市街主，也有一部分住宅区。商业市街和观光区以外的街区大都安静并保有昭和初期东京市街风貌。住宅以公寓和大厦居多，但也有部分独栋住宅。由于台东区<strong>近邻文京区和千代田区的学术和商业区</strong>，因此对于在东京市中心工作/念书又喜爱传统下町的人来说，住在台东区是个不错的选择</p><p><img src="/2023/07/14/japan-travel-guide-tokyo/tokyo-taitou-01.jpeg" alt="台东区"></p><p><img src="/2023/07/14/japan-travel-guide-tokyo/tokyo-taitou-02.png" alt="台东区"></p><h4 id="墨田区"><a href="#墨田区" class="headerlink" title="墨田区"></a>墨田区</h4><p><a href="https://zhuanlan.zhihu.com/p/511823310">墨田区</a>（日语：墨田区／すみだく Sumida ku */?）是夹于荒川和隅田川之间的行政区，区内有许多知名地标，例如两国国技馆、江户东京博物馆和<strong>东京晴空塔</strong>。晴空塔是到访东京的外国游客的人气观光景点，由押上(晴空塔)搭乘电车可直达羽田机场或成田机场，因此晴空塔附近有许多住宿比市中心便宜的短期出租公寓。江户东京博物馆和大相扑比赛会场的两国国技馆位在两国，到访这些设施可以了解昔日东京的悠久历史。</p><p>墨田区除了作为观光区受欢迎之外，墨田区的住宅区相当适合居住，由于部分车站通勤至主要商业区相当快速，是个可以享受观光休闲和交通之便的宜居之地</p><p><img src="/2023/07/14/japan-travel-guide-tokyo/tokyo-sumida-02.png" alt="墨田区"></p><h4 id="江东区"><a href="#江东区" class="headerlink" title="江东区"></a>江东区</h4><p><a href="https://zhuanlan.zhihu.com/p/504335320">江东区</a> （日语：江東区／こうとうく Kōtō ku */?） 位于中央区以东、墨田区以南，隅田川和荒川分别构成了江东区的西边和东边的天然边界。由于区内运河与桥梁众多，亦被称作为“水彩都市”。以海产闻名的<strong>筑地市场</strong>（场内市场）也在2018年10月搬迁至此区，成为丰洲市场。该区有七成面积都是通过填海产生。历史上，江东区的内陆地区是庶民社区，随着日本现代化，江东区出现许多中小型下町工厂，龟户与锦糸町（墨田区）周边形成了繁华的副都心商业区。近年，随着都市开发，东京湾岸的填海地兴建了许多高层办公大楼、公园绿地与超高层公寓大楼，吸引了许多白领阶级家庭在此置产居住。</p><p><img src="/2023/07/14/japan-travel-guide-tokyo/tokyo-koutou-01.png" alt="江东区"></p><h4 id="荒川区"><a href="#荒川区" class="headerlink" title="荒川区"></a>荒川区</h4><p><a href="https://zhuanlan.zhihu.com/p/502047369">荒川区</a>（日语：荒川区／あらかわく Arakawa ku */?）位于东京的东北部，北面是足立区，南面是台东区和文京区。荒川区的区名来自”荒川”，但荒川区北面边境实为”隅田川”。荒川是老市区和新兴住宅区的混合体，可以找到<strong>日暮里纤维街</strong>和南千住的高层塔楼公寓。荒川区最南端的<strong>日暮里</strong>是区内最大的交通枢纽，搭乘京成Skyliner（Keisei Skyliner）前往成田机场仅约36分钟车程。</p><p><img src="/2023/07/14/japan-travel-guide-tokyo/tokyo-arakawa-01.png" alt="荒川区"></p><p><img src="/2023/07/14/japan-travel-guide-tokyo/tokyo-arakawa-02.png" alt="荒川区"></p><h4 id="足立区"><a href="#足立区" class="headerlink" title="足立区"></a>足立区</h4><p><a href="https://zhuanlan.zhihu.com/p/512370279">足立区</a> （日语：足立区／あだちく Adachi ku */?）是以住宅为主的行政区，是东京23区中平均租金最便宜的区之一。虽然足立区被认为是庶民居住的下町，但足立区最具代表性的北千住是一个相当发达且繁忙的转运站、商业区、大学城和住宅区。车站有两家百货公司和充满活力的商店街。</p><p><img src="/2023/07/14/japan-travel-guide-tokyo/tokyo-adachi-01.png" alt="足立区"></p><h4 id="葛饰区"><a href="#葛饰区" class="headerlink" title="葛饰区"></a>葛饰区</h4><p>位于东京23区东北角的葛饰区给人的印象与新宿都心摩天高楼相去甚远。<a href="https://zhuanlan.zhihu.com/p/505021340">葛饰区</a> （日语：葛飾区／かつしかく Katsushika ku */?）与周围的台东区、足立区、墨田区和江户川区都被视为下町（下町地区在历史上被认为是庶民居住的工商社区、老街、老社区）。但与经过规划、观光业盛行的台东区和墨田区相比，葛饰区的下町给人一种更传统、安静、更慢活的老东京生活方式。</p><p><img src="/2023/07/14/japan-travel-guide-tokyo/tokyo-katushika-01.png" alt="葛饰区"></p><h4 id="江户川区"><a href="#江户川区" class="headerlink" title="江户川区"></a>江户川区</h4><p><a href="https://zhuanlan.zhihu.com/p/517606696">江户川区</a>（日语：江戸川区／えどがわく Edogawa ku */?）位于东京23区的最东侧，为荒川和江户川之间的狭长地带。江户川区区名来自东侧的江户川，区的西侧为荒川、南侧面向东京湾、北侧与葛饰区接壤。江户川区的中心地区由中川南北向贯穿，南部地区的葛西临海公园一带则主要为海埔新生地。</p><p>由于江户川区东西南侧面向河川和海洋，区内有非常多公园和绿地，例如河堤公园和葛西临海公园，这些绿地提供了当地居民非常多的户外活动选项，希望远离城市喧嚣的家庭非常适合在此悠闲生活。</p><p>除了公园绿地，房租低廉、适合养育子女以及前往东京市中心的便利通勤等条件也使江户川区发展成以家庭居住为主的行政区。该区大多数社区拥有安静住宅氛围，吸引许多追求较低住房成本的日本、中国、印度家庭搬到这里。</p><p><img src="/2023/07/14/japan-travel-guide-tokyo/tokyo-edogawa-01.png" alt="江户川区"></p><h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><h3 id="2023之后的新景点"><a href="#2023之后的新景点" class="headerlink" title="2023之后的新景点"></a>2023之后的新景点</h3><p><a href="https://www.bring-you.info/zh-hans/harry-potter-studio-tour-tokyo">板桥区-阿利波特地方</a></p>]]></content>
      
      
      <categories>
          
          <category> 旅游 </category>
          
          <category> 日本 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 旅游 </tag>
            
            <tag> 日本 </tag>
            
            <tag> 攻略 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>献给朝阳下的你</title>
      <link href="/2023/06/14/tomoo-yoake/"/>
      <url>/2023/06/14/tomoo-yoake/</url>
      
        <content type="html"><![CDATA[<p><a href="https://mp.weixin.qq.com/s/g64NCHwgzFON62VFrU9I1w">本文公众号</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line">夜明けの君へ</span><br><span class="line">作词 &amp; 作曲：TOMOO</span><br><span class="line">编曲：アイコトバ</span><br><span class="line"></span><br><span class="line">あの丸い月によく似た瞳が笑う</span><br><span class="line">「めんどくさい」ってからかう声を追いかけた</span><br><span class="line">おどけたポーズも　震えるため息も</span><br><span class="line">見逃せない流星と同じ</span><br><span class="line"></span><br><span class="line">那双好似满月般微笑的眼睛</span><br><span class="line">伴随着“真麻烦啊”这样的笑侃</span><br><span class="line">不熟练的摆姿势也好，颤抖着的叹息声也好</span><br><span class="line">漫天闪耀的流星们也是如此吧</span><br><span class="line"></span><br><span class="line">かっこいいって思わずにはいられなくてさ</span><br><span class="line">呆気にとられて　色づいてく日々</span><br><span class="line">頭の中では　鳴り続けるシャッター</span><br><span class="line">でも少しも伝えきれてない</span><br><span class="line"></span><br><span class="line">抑制不住的觉得你很帅气的想法</span><br><span class="line">不觉中惊讶发现 每一天都过得五彩缤纷</span><br><span class="line">脑海中闪过的快门声也从不停止鸣响</span><br><span class="line">然而这份心情，还从未能让你感受到</span><br><span class="line"></span><br><span class="line">ああ</span><br><span class="line">今　君の光を受け取ったなら</span><br><span class="line">その時からもう　消えない光</span><br><span class="line">不安も　迷いも　追い越してきた</span><br><span class="line">眠れぬ夜に　届いた光</span><br><span class="line"></span><br><span class="line">啊啊</span><br><span class="line">如果现在的我 可以沐浴在你的光亮下</span><br><span class="line">从这时起 这束光就再不会消失</span><br><span class="line">翻越了不安和迷茫</span><br><span class="line">我的无眠之夜，也将洒下光芒</span><br><span class="line"></span><br><span class="line">怖かったのは僕だけじゃなかった</span><br><span class="line">一番聞いてほしい一言ほど</span><br><span class="line">だれにも言えずに　しまいこんだまま</span><br><span class="line">開け方すら忘れかけて</span><br><span class="line"></span><br><span class="line">对未来害怕的 或许不止我一个</span><br><span class="line">仅仅是这样一句大家最想听到的话</span><br><span class="line">我却没有对任何人说，只是藏在心里</span><br><span class="line">就连如何开口，都快要忘记</span><br><span class="line"></span><br><span class="line">一体いつからどこに隠れてたんだろう</span><br><span class="line">きっと迷子になってただけの涙</span><br><span class="line">君の前で僕は　こんな顔してるんだな</span><br><span class="line">止まってた時間が走り出す</span><br><span class="line"></span><br><span class="line">到底是何时开始把自己深藏在某处</span><br><span class="line">一定是因为迷茫而只顾顿足落泪吧</span><br><span class="line">在你面前的我，原来也是这样的神情</span><br><span class="line">凝固的时间，再一次向前出发了</span><br><span class="line"></span><br><span class="line">ああ　君が見つけてくれた時から</span><br><span class="line">僕はもう一度　僕になれたよ</span><br><span class="line">ひとりきりでは気付けないまま</span><br><span class="line">こんな景色も　愛されてたこと</span><br><span class="line"></span><br><span class="line">啊啊，从你发现我的那一刻开始</span><br><span class="line">我再一次找回了我自己</span><br><span class="line">一个人的时候或许永远不会发现</span><br><span class="line">还有这样的风景，一直爱抚着我</span><br><span class="line"></span><br><span class="line">僕らの日々は</span><br><span class="line">暗闇がなくちゃ　星が見えなくて</span><br><span class="line">完璧じゃないから　君に出会えた</span><br><span class="line">完璧じゃないから、</span><br><span class="line"></span><br><span class="line">我们所经历的每一天</span><br><span class="line">如果没有黑暗，也不会看到漫天星光</span><br><span class="line">正是不完美的我，才能遇见你</span><br><span class="line">不完美的我…</span><br><span class="line"></span><br><span class="line">今　ほんとの声を聴き合えたなら</span><br><span class="line">やっと僕らは　夜明けの星座</span><br><span class="line">ただ君がいて　ただ僕がいて</span><br><span class="line">ここにしかない　意味になってく</span><br><span class="line">如果现在 我们可以倾听彼此真正的声音</span><br><span class="line">我们终将拥有那黎明之际的星座</span><br><span class="line">只要你我相伴在这里</span><br><span class="line">终会创造独属我们的意义</span><br><span class="line">君と朝日を迎えにいくよ</span><br><span class="line">愿同你一起，去迎接新一缕朝阳</span><br></pre></td></tr></table></figure><h2 id="碎碎念"><a href="#碎碎念" class="headerlink" title="碎碎念"></a>碎碎念</h2><p>MV 的胶片感十足</p>]]></content>
      
      
      <categories>
          
          <category> 音乐 </category>
          
          <category> TOMOO </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 音乐 </tag>
            
            <tag> 日语 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ES数据同步到hive</title>
      <link href="/2023/06/10/emr-es-to-hive/"/>
      <url>/2023/06/10/emr-es-to-hive/</url>
      
        <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>来自用户的需求: 用户有一部分数据来自 elasticsearch ，我们已经支持了通过 presto 查询 es 数据。但是用户需要将 es 表 和 hive 表做关联查询，而 presto 是不能跨数据源进行 join 查询的。所以需要先把 es 数据导入到 hive 中</p><p>用户对数据同步周期的要求并不高 一天1-2次就可以了，所以继续使用我们emr集群中已有的 azkaban 服务进行调度，把 es 数据同步到 hive 的过程写到 azkaban 中，实现了7张表的定期同步</p><h2 id="hive-创建-es-外表"><a href="#hive-创建-es-外表" class="headerlink" title="hive 创建 es 外表"></a>hive 创建 es 外表</h2><p><a href="https://blog.csdn.net/baichoufei90/article/details/104246011">参考教程-Elasticsearch-Hive</a></p><h3 id="hive-引入-elasticsearch-hadoop-依赖包"><a href="#hive-引入-elasticsearch-hadoop-依赖包" class="headerlink" title="hive 引入 elasticsearch-hadoop 依赖包"></a>hive 引入 elasticsearch-hadoop 依赖包</h3><p>hive 默认不支持创建 es 外表，需要引入 <a href="https://mvnrepository.com/artifact/org.elasticsearch/elasticsearch-hadoop">elasticsearch-hadoop</a> 依赖包</p><p>修改 hive.aux.jars.path 配置, 多个可以用逗号分隔，如下:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hive.aux.jars.path=file:///usr/hdp/2.6.3.0-235/hive/auxlib/elasticsearch-hadoop-hive-8.8.0.jar</span><br></pre></td></tr></table></figure><h3 id="创建-hive-外表"><a href="#创建-hive-外表" class="headerlink" title="创建 hive 外表"></a>创建 hive 外表</h3><p>sql 示例:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">EXTERNAL</span> <span class="keyword">TABLE</span> temp.es_external_table ( fieldNameA STRING, fieldNameB STRING ) STORED <span class="keyword">BY</span> <span class="string">&#x27;org.elasticsearch.hadoop.hive.EsStorageHandler&#x27;</span></span><br><span class="line">TBLPROPERTIES(</span><br><span class="line">    <span class="string">&#x27;es.resource&#x27;</span><span class="operator">=</span><span class="string">&#x27;es索引名&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;es.nodes&#x27;</span><span class="operator">=</span><span class="string">&#x27;es_host&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;es.port&#x27;</span><span class="operator">=</span><span class="string">&#x27;es_port&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;es.mapping.names&#x27;</span><span class="operator">=</span><span class="string">&#x27;fieldNameA:fieldNameA,fieldNameB:fieldNameB&#x27;</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>这里踩了一个坑: 由于 hive 创建表会忽略大小写，不管 sql 中定义的字段是什么样子，都会统一转成小写。所以导致es 中的驼峰名称字段 会映射失败，最后查出的数据都是 null</p><p><a href="https://blog.csdn.net/qq_40999403/article/details/103929305">类似的坑</a>-创建mongodb 外表时遇到的</p><p>因此需要显式地通过 <strong>es.mapping.names</strong> 配置指定字段名称的关联关系，像示例那样</p><h2 id="同步脚本"><a href="#同步脚本" class="headerlink" title="同步脚本"></a>同步脚本</h2><p>从 es 表到 hive 表，大致步骤为: 创建 hive 外表，关联 es 数据 =&gt; 创建 hive 内表 =&gt; 同步外表数据到内表</p><p>过程写到脚本中如下: (create_hive_to_es_table.sh)</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## 获取指定索引的所有 es 表字段</span></span><br><span class="line">get_index_field_ret=`curl http://<span class="variable">$&#123;es_address&#125;</span>/<span class="variable">$&#123;index_name&#125;</span>?pretty=<span class="literal">true</span>`</span><br><span class="line">field_arr=`<span class="built_in">echo</span> <span class="variable">$&#123;get_index_field_ret&#125;</span> | jq -r <span class="string">&quot;.<span class="variable">$&#123;index_name&#125;</span>.mappings.properties | keys | join(\&quot; \&quot;)&quot;</span>`</span><br><span class="line"></span><br><span class="line"><span class="comment">## 创建 hive 外表</span></span><br><span class="line">temp_table_name=<span class="string">&quot;temp.es_<span class="variable">$&#123;index_name&#125;</span>&quot;</span></span><br><span class="line">temp_rename_table_name=<span class="string">&quot;<span class="variable">$&#123;hive_db&#125;</span>.es_<span class="variable">$&#123;index_name&#125;</span>_bak&quot;</span></span><br><span class="line">actual_table_name=<span class="string">&quot;<span class="variable">$&#123;hive_db&#125;</span>.es_<span class="variable">$&#123;index_name&#125;</span>&quot;</span></span><br><span class="line"></span><br><span class="line">create_external_table_sql=<span class="string">&quot;CREATE EXTERNAL TABLE <span class="variable">$&#123;temp_table_name&#125;</span> (&quot;</span></span><br><span class="line"><span class="keyword">for</span> current_field <span class="keyword">in</span> <span class="variable">$&#123;field_arr[@]&#125;</span></span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    create_external_table_sql=<span class="string">&quot;<span class="variable">$&#123;create_external_table_sql&#125;</span> <span class="variable">$&#123;current_field&#125;</span> STRING,&quot;</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line">create_external_table_sql=`<span class="built_in">echo</span> <span class="variable">$&#123;create_external_table_sql&#125;</span> | sed <span class="string">&#x27;s/,$//g&#x27;</span>`</span><br><span class="line"></span><br><span class="line"><span class="comment">### 组装 es.mapping.names</span></span><br><span class="line">create_external_table_sql=<span class="string">&quot;<span class="variable">$&#123;create_external_table_sql&#125;</span>) STORED BY &#x27;org.elasticsearch.hadoop.hive.EsStorageHandler&#x27; TBLPROPERTIES(&#x27;es.resource&#x27;=&#x27;<span class="variable">$&#123;index_name&#125;</span>&#x27;,&#x27;es.nodes&#x27;=&#x27;<span class="variable">$&#123;es_host&#125;</span>&#x27;,&#x27;es.port&#x27;=&#x27;<span class="variable">$&#123;es_port&#125;</span>&#x27;,&#x27;es.mapping.names&#x27;=&#x27;&quot;</span></span><br><span class="line"><span class="keyword">for</span> current_field <span class="keyword">in</span> <span class="variable">$&#123;field_arr[@]&#125;</span></span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    create_external_table_sql=<span class="string">&quot;<span class="variable">$&#123;create_external_table_sql&#125;</span><span class="variable">$&#123;current_field&#125;</span>:<span class="variable">$&#123;current_field&#125;</span>,&quot;</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line">create_external_table_sql=`<span class="built_in">echo</span> <span class="variable">$&#123;create_external_table_sql&#125;</span> | sed <span class="string">&#x27;s/,$//g&#x27;</span>`</span><br><span class="line"></span><br><span class="line">create_external_table_sql=<span class="string">&quot;<span class="variable">$&#123;create_external_table_sql&#125;</span>&#x27;)&quot;</span></span><br><span class="line">drop_external_table_sql=<span class="string">&quot;drop table if exists <span class="variable">$&#123;temp_table_name&#125;</span>&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;create external sql: <span class="variable">$&#123;create_external_table_sql&#125;</span>&quot;</span></span><br><span class="line"></span><br><span class="line">beeline -n <span class="variable">$&#123;hive_user&#125;</span> -u <span class="variable">$&#123;hive_server&#125;</span> -e <span class="string">&quot;<span class="variable">$&#123;drop_external_table_sql&#125;</span>&quot;</span></span><br><span class="line">beeline -n <span class="variable">$&#123;hive_user&#125;</span> -u <span class="variable">$&#123;hive_server&#125;</span> -e <span class="string">&quot;<span class="variable">$&#123;create_external_table_sql&#125;</span>&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## 创建 hive 临时内表</span></span><br><span class="line">create_temp_table_sql=<span class="string">&quot;CREATE TABLE <span class="variable">$&#123;temp_rename_table_name&#125;</span> AS SELECT * FROM <span class="variable">$&#123;temp_table_name&#125;</span>&quot;</span></span><br><span class="line">drop_temp_table_sql=<span class="string">&quot;drop table if exists <span class="variable">$&#123;temp_rename_table_name&#125;</span>&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;create temp table sql: <span class="variable">$&#123;create_temp_table_sql&#125;</span>&quot;</span></span><br><span class="line"></span><br><span class="line">beeline -n <span class="variable">$&#123;hive_user&#125;</span> -u <span class="variable">$&#123;hive_server&#125;</span> -e <span class="string">&quot;<span class="variable">$&#123;drop_temp_table_sql&#125;</span>&quot;</span></span><br><span class="line">beeline -n <span class="variable">$&#123;hive_user&#125;</span> -u <span class="variable">$&#123;hive_server&#125;</span> -e <span class="string">&quot;<span class="variable">$&#123;create_temp_table_sql&#125;</span>&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## 重命名表（用于快速重建用户直接用的表）</span></span><br><span class="line"></span><br><span class="line">create_actual_table_sql=<span class="string">&quot;ALTER TABLE <span class="variable">$&#123;temp_rename_table_name&#125;</span> RENAME TO <span class="variable">$&#123;actual_table_name&#125;</span>&quot;</span></span><br><span class="line">drop_actual_table_sql=<span class="string">&quot;drop table if exists <span class="variable">$&#123;actual_table_name&#125;</span>&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;create actual table sql: <span class="variable">$&#123;create_actual_table_sql&#125;</span>&quot;</span></span><br><span class="line"></span><br><span class="line">beeline -n <span class="variable">$&#123;hive_user&#125;</span> -u <span class="variable">$&#123;hive_server&#125;</span> -e <span class="string">&quot;<span class="variable">$&#123;drop_actual_table_sql&#125;</span>&quot;</span></span><br><span class="line">beeline -n <span class="variable">$&#123;hive_user&#125;</span> -u <span class="variable">$&#123;hive_server&#125;</span> -e <span class="string">&quot;<span class="variable">$&#123;create_actual_table_sql&#125;</span>&quot;</span></span><br></pre></td></tr></table></figure><h2 id="azkaban-任务"><a href="#azkaban-任务" class="headerlink" title="azkaban 任务"></a>azkaban 任务</h2><h3 id="定义任务流程"><a href="#定义任务流程" class="headerlink" title="定义任务流程"></a>定义任务流程</h3><p>需要重建7张表，因此定义成 父任务 -&gt; 7个子任务</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># es_to_hive_parent.job</span></span><br><span class="line"><span class="attr">type</span>=command</span><br><span class="line"></span><br><span class="line"><span class="attr">command</span>=echo <span class="string">&quot;es to hive success!&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">dependencies</span>=table1,table2,table3,table4,table5,table6,table7</span><br></pre></td></tr></table></figure><p>因为前面具体外表的创建流程 已经写在脚本中了，所以子任务这里直接调用 create_hive_to_es_table.sh 就行</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># table1.job</span></span><br><span class="line"><span class="attr">type</span>=flow</span><br><span class="line"></span><br><span class="line"><span class="attr">job.name</span>=table1</span><br><span class="line"><span class="attr">flow.name</span>=ES_TO_HIVE</span><br><span class="line"></span><br><span class="line"><span class="attr">index.name</span>=es索引名</span><br><span class="line"><span class="attr">hive_db</span>=目标 hive 库名</span><br><span class="line"></span><br><span class="line"><span class="comment"># ES_TO_HIVE.job</span></span><br><span class="line"><span class="attr">type</span>=command</span><br><span class="line"></span><br><span class="line"><span class="attr">command</span>=sh create_hive_to_es_table.sh <span class="variable">$&#123;es.address&#125;</span> <span class="variable">$&#123;index.name&#125;</span> <span class="variable">$&#123;hive.server&#125;</span> <span class="variable">$&#123;hive.user&#125;</span> <span class="variable">$&#123;hive.db&#125;</span></span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>基于目前的资料搜索 这种方案应该是 es数据同步到 hive 比较通用的。但是确实不适合大批量数据同步的场景，也不能直接同步增量数据</p><p>想同步增量数据的话 应该需要从数据源头入手了，比如 es 数据是来自 kafka 的，那么需要通过类似 canal 的服务来同步增量数据，架构和这里说到的远远不同</p>]]></content>
      
      
      <categories>
          
          <category> 大数据 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 大数据 </tag>
            
            <tag> azkaban </tag>
            
            <tag> hive </tag>
            
            <tag> emr </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【翻译】世界の秘密 歌曲鉴赏</title>
      <link href="/2023/05/07/vaundy-sekainohimitu/"/>
      <url>/2023/05/07/vaundy-sekainohimitu/</url>
      
        <content type="html"><![CDATA[<p><a href="https://mp.weixin.qq.com/s/Leegilq_cWkseBxgAg25fQ">本文公众号</a></p><p><a href="https://media.framu.world/columns/lyrics_consideration/sekainohimitsu">原文-世界の秘密【Vaundy】歌詞の意味を考察！世界の秘密に気づいても日々を楽しむ方法とは？</a></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>这次我们来欣赏 Vaundy 于2020年12月创作的数字单曲 「世界の秘密」（世界的秘密）。这首后续被作为 大学生SNS 平台 「Dtto」的 CM 曲，WOWOW（日本第一家付费商业卫星电视台）的原创剧 「こころのフフフ」的主题曲，以及 マルハニチロ 冷冻食品公司的新中华街系列电视广告「こだわりが、見えてきた」的主题曲</p><div style="position: relative; padding: 30% 45%;"><iframe style="position: absolute; width: 100%; height: 100%; left: 0; top: 0;" src="https://player.bilibili.com/player.html?id=357742772&bvid=BV1tX4y1q7bt&cid=1174643073&page=1&as_wide=1&high_quality=1&danmaku=1&autoplay=1" frameborder="no" scrolling="no"></iframe></div><h2 id="歌曲部分"><a href="#歌曲部分" class="headerlink" title="歌曲部分"></a>歌曲部分</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">きっと僕ら何かに追われてる</span><br><span class="line">漠然としてるけど</span><br><span class="line">四六時中グダグダと</span><br><span class="line">チクチクが流れる</span><br><span class="line">波に乗せて</span><br><span class="line">ネットサーフィン</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">一直在被什么推着前进的我们</span><br><span class="line">有时也会陷入迷茫</span><br><span class="line">即使这样，也会选择无所事事地度过一天</span><br><span class="line">任由不安的声音拂过耳边</span><br><span class="line">跟着网络的节奏</span><br><span class="line">思想随波逐流</span><br></pre></td></tr></table></figure><p>「世界の秘密」创作于新冠病毒盛行的2020年，当时社会呼吁民众非特殊情况不外出。也正因如此，在家过着孤单无聊、需要靠网络充实生活的人也更多了</p><p>不过即便是新冠之前，年轻人对网络产生依赖的社会问题也已经逐渐浮现出来了</p><p>被时间追赶着，被焦虑推怂着，离开了网络，仿佛就无法生存下去，这首歌主要描绘了这样一群人的样子。也揭示着这样的一种社会现象: 人们对社会形势、日常生活漠不关心，内心时而混乱，时而焦虑，时而感伤。也不限于年轻人，<strong>在当下社会中过得茫然而又不安，只能把内心寄托于网络世界的人们确实是越来越多了</strong></p><p><img src="/2023/05/07/vaundy-sekainohimitu/09.png" alt="MV画面"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">何か、これはあーだこーだ言って</span><br><span class="line">古臭いな</span><br><span class="line">それはそれで、なんだかんだ言って</span><br><span class="line">新しいな</span><br><span class="line">そんな無駄な繰り返しを、また繰り返して</span><br><span class="line">僕ら、生きていくうちに</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">我们总是说着 「啊，这不就是那个啥吗</span><br><span class="line">早就过气了呀」</span><br><span class="line">「咦，快看那个那个</span><br><span class="line">有点新意哦」</span><br><span class="line">就这样无聊的对话，重复来重复去</span><br><span class="line">我们就是按这种方式生活的吧</span><br></pre></td></tr></table></figure><p>接着第一句歌词「在被什么推着前进的我们」，这个东西是什么，相比「时间」来说，社会中的 「流行趋势」可能更加准确</p><p>更具体的，包括网络世界中的各种「话题」、「人气」（打榜）、SNS （social network software）上的 「点赞」等等</p><p><strong>我们每天都要从网络上接收庞大的信息量，（大脑不知疲倦地打着标签），脑海里无休止地做着 「那个是新事物，还是旧东西」的选择题，某种程度上也可以说是 「毫无意义的周而复始」</strong>罢了</p><p>不过，即使是过着日复一日和 SNS 深度绑定的生活，「我」注意到自己身上，还是发生了一些不起眼的变化</p><p><img src="/2023/05/07/vaundy-sekainohimitu/04.png" alt="MV画面"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">アイムソーリー</span><br><span class="line">気づいちゃったよ</span><br><span class="line">アイムソーリー</span><br><span class="line">気づいちゃったよ</span><br><span class="line">世界のこと</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">I am sorry</span><br><span class="line">我注意到了</span><br><span class="line">I am sorry</span><br><span class="line">我发现了</span><br><span class="line">关于世界的事情</span><br></pre></td></tr></table></figure><p>「我」在为 「发现了世界的事情」而“感到抱歉”</p><p>「世界的事情」也照应了歌名「世界的秘密」，不过虽然「我」发现了它，歌词中也没有直接说明是什么。顺着思路联想的话， 「我」或许是对「世界的起源、组成、运作和趋势」有点理解了</p><p>年少时候一直没有发现的「世界的事情」，直到长大（有了一些社会阅历）才理解一些事，那一瞬间多少会感到“遗憾”吧</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">ステップだけ、ステップだけ、置いてきちゃってよ</span><br><span class="line">僕ら、涙に合わせて</span><br><span class="line">リズムに乗っている</span><br><span class="line">はず</span><br><span class="line">ステップだけ、ステップだけ、置いてきちゃっても</span><br><span class="line">僕ら、笑顔の数だけ</span><br><span class="line">ブレイクできるはず</span><br><span class="line">だから</span><br><span class="line">アイムソーリー</span><br><span class="line">気づいちゃっても</span><br><span class="line">アイムソーリー</span><br><span class="line">忘れといてよ</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">唯有前进，唯有前进，放下内心的烦恼</span><br><span class="line">我们啊，就是这样 感动落泪 感同身受</span><br><span class="line">才能跟着旋律，悠然起舞吧</span><br><span class="line">那么</span><br><span class="line">唯有向前，唯有向前，释放内心的负担</span><br><span class="line">我们啊，就是这样 无忧无虑 无数次欢笑</span><br><span class="line">才能了解自己，突破瓶颈吧</span><br><span class="line"></span><br><span class="line">所以啊</span><br><span class="line">I am sorry</span><br><span class="line">即使是注意到了</span><br><span class="line">I am sorry</span><br><span class="line">还是把它忘了吧</span><br></pre></td></tr></table></figure><p>本来很多道理都是简单易懂的，花上大篇幅去解释和表现，反而会适得其反，更难理解。Vaundy 就通过音乐的表现方式，将年轻人比较感性的社会问题通过自由的形式表现了出来</p><p>诸如「step、rhythm、break」这种舞蹈和音乐上的用语，向着同样依托着音乐之力生活下去的人们传递着自己的思考</p><p>思考之后，给出的就是面对这样一个网络世界的答案: 即使是在面对人生的一些重要阶段，比如一个难以迈过的台阶（step），<strong>即使是在这个过程充满着苦涩和悲伤，最后也一定能在某个时刻回身微笑</strong>。所以啊，即使世界上、社会上有让你在意的细枝末节，也请你忘记它们，继续前进</p><!----- bgm: 隐形的翅膀--><p><img src="/2023/05/07/vaundy-sekainohimitu/06.png" alt="MV画面"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">今日どっかで悪者が死んだらしい</span><br><span class="line">でもたくさんの命が救われたらしい</span><br><span class="line">正義と倫理と命を天秤にかけて</span><br><span class="line">量った声明で</span><br><span class="line">難しいことはもう分からない</span><br><span class="line">けれど</span><br><span class="line">実は僕らが悪者だったかもしれない</span><br><span class="line">なんて考えると</span><br><span class="line">彼の気持ちが分かるかもしれない</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">今天好像在哪里有“坏人”离开了世界</span><br><span class="line">但也有很多人的生命因此得救了</span><br><span class="line">我们总是端量着正义、伦理和生命的天平</span><br><span class="line">然后说出自己的见解</span><br><span class="line">复杂点的东西我也说不准</span><br><span class="line">然而</span><br><span class="line">我们是否也曾经站在了坏人那一边呢</span><br><span class="line">有时也这么想着</span><br><span class="line">也许就能理解那个人的心情了吧</span><br></pre></td></tr></table></figure><p>「让我们在疫情管控而百无聊赖的日子里，寻找一些和音乐相关的乐子吧」作者传达着这样的想法。不过有时候呢，本来「我」已经选择「忘记」的「世界的秘密」，还是会让我忍不住又去注意（它到底是什么）</p><p>这一段是对「世界的秘密」逐渐清晰的认识，对应着前面歌词的「感伤之中的笑容和乐趣」。「<strong>善恶的判断和区别并不是绝对的，而是相对的</strong>」，这些「善恶的价值判断」们，也是「世界组成」的一部分</p><p><img src="/2023/05/07/vaundy-sekainohimitu/07.png" alt="MV画面"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">アイムソーリー</span><br><span class="line">気づいちゃったよ</span><br><span class="line">アイムソーリー</span><br><span class="line">気づいちゃったよ</span><br><span class="line">自分のこと</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">I am sorry</span><br><span class="line">我注意到了哦</span><br><span class="line">I am sorry</span><br><span class="line">我发现了哦</span><br><span class="line">关于自己的秘密</span><br></pre></td></tr></table></figure><p>这一段的视角，从「世界」转向了「自己」。<strong>之前对「世界」的思考还是比较宏观的（正义、伦理、生命价值的思考，都是人类的价值取向），把视角缩小到「自身」之后，「我」也有了一些之前没有的见解</strong></p><p>小时候的「我」觉得「善恶的评判标准是绝对的」，认为「正义最后一定会邪恶」，但成了「大人」之后发现，即使是在「坏人」那边，有时也会存在「正义」的一面</p><p>「坏人死了，但是因为他的死，改变了一部分人的想法，从而拯救了他们」如果站在这种「伦理观」，会发现社会需要在人权问题上实现「生命平等」，其实是很难的</p><p>类似这样在「世界」各个国家，各个区域都存在的矛盾问题，在「自身」也会有类似的存在</p><p><img src="/2023/05/07/vaundy-sekainohimitu/11.png" alt="MV画面"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ステップだけ、ステップだけ、置いてきちゃってよ</span><br><span class="line">僕ら、涙に合わせて</span><br><span class="line">リズムに乗っている</span><br><span class="line">はず</span><br><span class="line">ステップだけ、ステップだけ、置いてきちゃっても</span><br><span class="line">僕ら、笑顔の数だけ</span><br><span class="line">ブレイクできるはず</span><br><span class="line">そうだろ？</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">唯有前进，唯有前进，放下内心的烦恼</span><br><span class="line">我们啊，就是这样 感动落泪 感同身受</span><br><span class="line">才能跟着旋律，悠然起舞吧</span><br><span class="line">那么</span><br><span class="line">唯有向前，唯有向前，释放内心的负担</span><br><span class="line">我们啊，就是这样 无忧无虑 无数次欢笑</span><br><span class="line">才能突破自己，创造未来</span><br><span class="line">就是这样的吧？</span><br></pre></td></tr></table></figure><p>和第一段副歌基本相同，「所以…把它忘了吧」变成了「就是这样的吧」</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">探してた未来に追いついて</span><br><span class="line">その時初めて気づいたんだ</span><br><span class="line">これが良い事か悪い事か</span><br><span class="line">これが「世界の秘密」ってやつか</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">向着曾经憧憬的未来追寻而去</span><br><span class="line">到那时，才终于发觉</span><br><span class="line">这种追求，到底是不是个好事呢</span><br><span class="line">这其实就是所谓的「世界的秘密」吧</span><br></pre></td></tr></table></figure><p>作者再对他所追求的「世界的秘密」说明了他的理解: 「<strong>善恶的评判只是相对的，世界就是不停地围绕着正义、伦理和生命的平衡而转</strong>」</p><p>「step」有「阶梯」的一层意味，这里Vaundy或许也表达着一种希望: 「<strong>登上了大人阶梯的我们，如果还能够保持那一份对世界的秘密 不那么深虑的童心，偶尔苦中作乐，欣赏音乐的同时不断寻求突破，那就更好了</strong>」</p><!--## 最后在这个通过「上网冲浪」就能知道「世界发生的事情」的时代，看起来获取一手信息更容易了，但反而因此感到混乱、迷茫的人也更多了随着日复一日的生活，脑海中日积月累地冒出越来越多伤心事情的时候，通过音乐让自己心情放松一些，就显得更加重要了不管发生了什么事，都让我们背起行囊，及时寻乐吧--><p><img src="/2023/05/07/vaundy-sekainohimitu/01.png" alt="MV画面"></p><h2 id="译者后言"><a href="#译者后言" class="headerlink" title="译者后言"></a>译者后言</h2><p>如今在网络媒体看到的各种时事热点，很多都自带着事物的「新旧」，思想的「善恶」，选择的「对错」等等标签，新闻和评论区的吵吵闹闹，仿佛都在让我们做个选择，一定要站队到某一边去</p><p>这种日复一日地打着标签、做着选择的生活，是不是偶尔跳出来看，把这些看似对立的标签放在一起，当作是人们的不同价值观而已。不论对错，而论这些价值观形成的原因，再从当事人角度出发，为什么现实中他做了这个选择，她又做了那种选择，能让我们更看得清这个「世界的秘密」呢</p><!--社会的复杂是不可能改变的，唯一能改变的就是自己。别人，但是自己想变成什么样还是可以决定的其他角度: 想起罗翔所说的，乌托邦的世界是不存在的，但是人类的意义就是去追求，去实现这样的乌托邦--><p><img src="/2023/05/07/vaundy-sekainohimitu/08.png" alt="MV画面"></p>]]></content>
      
      
      <categories>
          
          <category> 音乐 </category>
          
          <category> Vaundy </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 音乐 </tag>
            
            <tag> 日语 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>大数据任务调度和数据同步组件初探</title>
      <link href="/2023/04/30/emr-scheduler/"/>
      <url>/2023/04/30/emr-scheduler/</url>
      
        <content type="html"><![CDATA[<p><a href="https://blog.csdn.net/xiaoliizi/article/details/130569690">本文csdn博客地址</a><br><a href="https://mp.weixin.qq.com/s/peTA227Wt336hWj14wWKwg">本文公众号地址</a></p><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>数据从最原始的状态，可能是一个 excel，一个文本，或者是来自业务数据库的数据，格式各种各样，落地到<a href="https://www.oracle.com/cn/database/what-is-a-data-warehouse/">数据仓库</a>、<a href="https://www.sap.cn/products/technology-platform/hana/what-is-a-data-lake.html">数据湖</a>中，数据的同步过程 是必不可少的</p><p><img src="/2023/04/30/emr-scheduler/16.png" alt="数据同步"></p><p><a href="https://www.cnblogs.com/liugp/p/17297756.html">图片来源</a></p><p>传统的数据同步方式主要是基于定时任务的模式，通过任务调度服务，每天定时将原始数据提取（<strong>extract</strong>），进行清洗处理，比如过滤掉重复数据（<strong>transform</strong>），最后存入数仓（<strong>load</strong>），即 <a href="https://www.ibm.com/cn-zh/topics/etl">ETL</a> 任务模式。这种模式对数据的实时性要求不高，常见的同步工具有 datax、sqoop</p><p><img src="/2023/04/30/emr-scheduler/17.png" alt="ETL"></p><p>实时同步，则需要让同步任务一直处于运行状态，有新数据进来需要在<strong>秒级别内</strong>更新。这种情况下传统的调度模式就不能满足了，需要能时刻监测数据同步状态、管理和启停任务、甚至动态分配任务资源。一种常见的模式是 任务通过 <strong>spark / flink</strong> 等流式任务引擎去执行，然后在上层通过 k8s 或其他任务管理平台 进行调度</p><p>本质上实时同步数据的模式和 ETL 是一样的，对数据依然有 抽取、清洗和写入的操作。只是<strong>时效性、任务管理复杂度、资源动态分配能力</strong>上，要求会更高</p><p><img src="/2023/04/30/emr-scheduler/18.png" alt="流批一体"></p><p><a href="https://zhuanlan.zhihu.com/p/531318115">图片来源-DataFunTalk：阿里建设一站式实时数仓的经验分享</a></p><p>搭建可以在公司内通用的 EMR 平台，除了满足数据同步的功能，还需要提供任务调度的功能，因为用户的任务各种各样，可能是自定义的 spark / flink 任务，python 脚本 对数据自行处理的任务 等等，所以需要提供能让用户自行上传任务、执行任务的平台</p><p><img src="/2023/04/30/emr-scheduler/19.png" alt="xxl-job"></p><p><a href="https://www.cnblogs.com/gaoqiaoliangjie/p/15390703.html">图片来源-xxl-job工作原理解析</a></p><p>不过相比数据同步 离线和实时同步架构相差较大，任务调度平台架构的发展则不离其宗，基本变化不大</p><p>本文将会对业界主流的任务调度服务 和 数据同步服务 做一些介绍，大家可以参考，择优选择更适合自己业务需求的服务 进行尝试</p><h2 id="任务调度组件"><a href="#任务调度组件" class="headerlink" title="任务调度组件"></a>任务调度组件</h2><p>这里列举三个主流的任务调度服务: <a href="https://github.com/azkaban/azkaban">azkaban</a>、<a href="https://github.com/apache/airflow">airflow</a> 和 <a href="https://github.com/apache/dolphinscheduler">dolphinscheduler</a>。我们先分别看基于这三个组件 数仓的架构可能是什么样的，然后系统对比，最后大致看下使用页面</p><h3 id="传统离线数仓-azkaban"><a href="#传统离线数仓-azkaban" class="headerlink" title="传统离线数仓: azkaban"></a>传统离线数仓: azkaban</h3><p><img src="/2023/04/30/emr-scheduler/01.png" alt="离线数仓"></p><p><a href="https://winway.github.io/2022/05/24/bigdata-stack-dw">大数据开发之路-离线数仓</a></p><h3 id="实时离线融合-airflow"><a href="#实时离线融合-airflow" class="headerlink" title="实时离线融合: airflow"></a>实时离线融合: airflow</h3><p><img src="/2023/04/30/emr-scheduler/02.png" alt="airflow"></p><p><a href="https://kids-first.github.io/kf-airflow-dags/warehouse.html">Data Warehouse</a></p><h3 id="实时离线融合-dolphinscheduler"><a href="#实时离线融合-dolphinscheduler" class="headerlink" title="实时离线融合: dolphinscheduler"></a>实时离线融合: dolphinscheduler</h3><p><img src="/2023/04/30/emr-scheduler/03.png" alt="dolphinscheduler"></p><p><a href="https://blog.csdn.net/weixin_42138677/article/details/119685577">基于DolphinScheduler的使用浅谈数仓分层及模型设计</a></p><h3 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h3><p><a href="https://cloud.tencent.com/developer/article/1979180">大数据调度平台分类大对比(Oozie/Azkaban/AirFlow/XXL-Job/DolphinScheduler)</a></p><p><a href="https://blog.csdn.net/kyle0349/article/details/108947115">【大数据】【调度】Airflow 和 Azkaban的选型</a></p><table><thead><tr><th>特性\组件</th><th>airflow</th><th>dolphinscheduler</th><th>azkaban</th></tr></thead><tbody><tr><td>web界面</td><td>有，功能比较多</td><td>有，且支持中文</td><td>有，比较简单</td></tr><tr><td>工作流语法</td><td>python代码内定义，可通过界面查看但不能编辑</td><td>可视化编辑，对小白很友好，但不适合通过代码编排</td><td>配置文件</td></tr><tr><td>跨dag/project依赖</td><td>支持，可通过 <a href="https://airflow.apache.org/docs/apache-airflow/stable/howto/operator/external_task_sensor.html">ExternalTaskSensor</a> 配置</td><td>不支持</td><td>不支持</td></tr><tr><td>易用程度</td><td>安装和维护上手难度高，<a href="https://airflow.apache.org/docs/apache-airflow/stable/core-concepts/overview.html">组件</a>包括 WebServer、Scheduler、Worker</td><td>安装维护上手难度高，<a href="https://dolphinscheduler.apache.org/zh-cn/docs/3.1.5/about/glossary">组件</a>包括 master、api、alert、worker 等，不过界面支持中文，可视化编辑任务比较友好</td><td>上手难度低，只有 webserver、executor 两个组件</td></tr><tr><td>变量定义</td><td>支持全局参数，和一些内置模板变量，如 </td><td>不支持全局变量</td><td>不支持全局变量</td></tr><tr><td>调度中心HA</td><td><a href="https://airflow.apache.org/docs/apache-airflow/stable/administration-and-deployment/scheduler.html#running-more-than-one-scheduler">支持</a> ，对 db 版本有要求（mysql &gt;= 8）</td><td>支持</td><td><a href="https://github.com/azkaban/azkaban/issues/952">不支持</a></td></tr><tr><td>执行器HA</td><td>支持</td><td>支持</td><td>支持</td></tr><tr><td>权限管控</td><td>支持用户、任务级别配置</td><td>用户角色支持管理员、普通用户两种，不支持项目层级配置</td><td>支持用户、任务级别配置</td></tr><tr><td>任务监控</td><td>可通过定义 <a href="https://airflow.apache.org/docs/apache-airflow/stable/administration-and-deployment/logging-monitoring/callbacks.html">on_failure_callback</a> 在任务结束后触发提醒，<a href="https://feijin.github.io/2021/03/14/airflow-alert-example/">示例</a>，支持<a href="https://airflow.apache.org/docs/apache-airflow/stable/administration-and-deployment/logging-monitoring/metrics.html">metrics</a></td><td><a href="https://dolphinscheduler.apache.org/zh-cn/docs/3.1.5/guide/alert/alert_plugin_user_guide">支持任务告警</a>，支持通过企业微信、飞书等方式发送</td><td>可配置 job 的 failure.emails 让任务失败后发送邮件提醒</td></tr></tbody></table><p>总结: ds 对各种 ETL 任务类型的界面化配置支持更好，airflow 更适合 python 基础较好的团队使用，编排任务代码化 笔者认为也是一种趋势。azkaban 较为传统，使用起来更简单，也更适合定义流程简单的 ETL 任务，但是相比前两个组件，更新不是特别活跃</p><h3 id="airflow-架构和界面"><a href="#airflow-架构和界面" class="headerlink" title="airflow 架构和界面"></a>airflow 架构和界面</h3><p><img src="/2023/04/30/emr-scheduler/04.png" alt="airflow"></p><p><img src="/2023/04/30/emr-scheduler/05.png" alt="airflow"></p><p><a href="https://airflow.apache.org/docs/apache-airflow/stable/core-concepts/overview.html">Architecture Overview</a></p><h3 id="dolphinscheduler-界面"><a href="#dolphinscheduler-界面" class="headerlink" title="dolphinscheduler 界面"></a>dolphinscheduler 界面</h3><p><img src="/2023/04/30/emr-scheduler/06.png" alt="dolphinscheduler"></p><h3 id="azkaban-架构和界面"><a href="#azkaban-架构和界面" class="headerlink" title="azkaban 架构和界面"></a>azkaban 架构和界面</h3><p><img src="/2023/04/30/emr-scheduler/07.png" alt="azkaban"></p><p><img src="/2023/04/30/emr-scheduler/08.png" alt="azkaban"></p><p><a href="https://www.hnbian.cn/posts/5d59c988.html">1. Azkaban 介绍</a></p><h2 id="数据同步组件"><a href="#数据同步组件" class="headerlink" title="数据同步组件"></a>数据同步组件</h2><p>对数据同步而言，支持更多的数据源是更重要的，传统数据同步工具，如 <a href="https://github.com/apache/sqoop">sqoop</a>、<a href="https://github.com/alibaba/DataX">datax</a> ，都是对基于hadoop的传统数仓、基于关系型数据库 支持更好，不过对更现代的 <a href="https://en.wikipedia.org/wiki/Online_analytical_processing">OLAP</a>、甚至<a href="https://www.oracle.com/cn/big-data/what-is-data-lakehouse">湖仓一体</a>的架构支持并不够好</p><p>随着发展，功能更强大的同步组件 如 <a href="https://github.com/apache/incubator-seatunnel">seatunnel</a>、<a href="https://github.com/DTStack/chunjun">chunjun</a> 也逐渐占有了一席之地，在业务使用实际场景中可以优先选择它们</p><h3 id="sqoop"><a href="#sqoop" class="headerlink" title="sqoop"></a>sqoop</h3><p><img src="/2023/04/30/emr-scheduler/09.png" alt="sqoop"></p><p><a href="https://blog.csdn.net/mamamalululu00000000/article/details/100013482">Sqoop原理和架构</a></p><p><a href="https://www.jianshu.com/p/23ec3a386dc9">【知识】ETL大数据集成工具Sqoop、dataX、Kettle、Canal、StreamSets大比拼</a></p><p>特点：</p><ul><li>离线全量同步，不支持增量导入</li><li>仅支持关系型数据库，比如从 mysql 同步到 hive</li><li>任务运行方式: mapreduce</li></ul><h3 id="datax"><a href="#datax" class="headerlink" title="datax"></a>datax</h3><p><img src="/2023/04/30/emr-scheduler/10.png" alt="datax"></p><p><a href="https://github.com/alibaba/DataX/blob/master/introduction.md">阿里云开源离线同步工具DataX3.0介绍</a></p><p><img src="/2023/04/30/emr-scheduler/11.png" alt="datax"></p><p><a href="https://dengchuncui.github.io/2020/10/22/%E3%80%90%E6%95%B0%E6%8D%AE%E5%90%8C%E6%AD%A5%E3%80%91DATAX%20%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E5%8F%8A%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/">数据同步 DATAX 工作原理及源码解读</a></p><p>特点：</p><ul><li>相比 sqoop 支持的数据源更丰富，支持非关系型数据库（如从 mysql 写到 hdfs、mongodb、es 等） </li><li>表字段的映射，必须提前写成json配置</li><li>同步任务在单节点运行（在执行 datax 的节点运行）</li></ul><h3 id="canal"><a href="#canal" class="headerlink" title="canal"></a>canal</h3><p><img src="/2023/04/30/emr-scheduler/12.png" alt="canal"></p><p><a href="https://www.cnblogs.com/caoweixiong/p/11824423.html">Canal——原理架构及应用场景</a></p><p>特点：</p><ul><li>只能同步增量数据（本质：模拟 mysql slave 进行数据同步）</li><li>支持数据源: kafka、rocketmq、hbase、elasticsearch</li><li>实时任务管理：需要单独部署管理服务，如 cloudin-datax、Canal Admin</li></ul><h3 id="datalink"><a href="#datalink" class="headerlink" title="datalink"></a>datalink</h3><p><img src="/2023/04/30/emr-scheduler/13.png" alt="datalink"></p><p><a href="https://github.com/ucarGroup/DataLink">git-ucarGroup/DataLink</a></p><p>特点：</p><ul><li>支持增量数据同步任务的管理，基本任务启停、同步状态检查等</li><li>对 canal 、datax 等同步工具进行了封装，支持数据源: mysql、hbase、elasticsearch、kafka、kudu</li><li>神州租车开源，现在不再维护，不过基本功能比较完善</li></ul><p><a href="https://mp.weixin.qq.com/s?__biz=MzkwOTIxNDQ3OA==&mid=2247533077&idx=1&sn=2034a6897883e149b350b39facc98f6a&source=41#wechat_redirect">神州优车数据交换平台的架构、建设与痛点难点详解</a></p><h3 id="seatunnel"><a href="#seatunnel" class="headerlink" title="seatunnel"></a>seatunnel</h3><p><img src="/2023/04/30/emr-scheduler/14.png" alt="seatunnel"></p><p><a href="https://www.cnblogs.com/liugp/p/17297756.html">【大数据】什么是数据集成？（SeaTunnel 集成工具介绍）</a></p><p>特点：</p><ul><li>通过spark / flink 方式同步数据，支持更多现代数据源（clickhouse、doris、iceberg 等）</li><li>UI 还不是很完善</li><li>笔者后续会更详细地体验这个工具，补充和更多实时同步组件的使用对比</li></ul><h3 id="airbyte"><a href="#airbyte" class="headerlink" title="airbyte"></a>airbyte</h3><p><img src="/2023/04/30/emr-scheduler/15.png" alt="airbyte"></p><p><a href="https://docs.airbyte.com/understanding-airbyte/high-level-view">Architecture overview</a></p><p>特点：</p><ul><li>完全云原生化的数据同步服务，一个同步任务对应一个容器</li><li>适用ETL 场景（配置定时任务，最小周期<a href="https://discuss.airbyte.io/t/does-airbyte-sync-near-real-time-or-streaming-syncs/354">5分钟</a>，并不是完全实时）</li><li>上手难度高，学有余力可以尝试</li></ul><h2 id="展望"><a href="#展望" class="headerlink" title="展望"></a>展望</h2><p>对于任务调度平台来说，本质上都是 <strong>定时 + 触发任务 + 管理任务</strong> 的使用机制，基本架构都离不开 <strong>scheduler + task worker</strong>，相差不大</p><p>但对于数据同步组件来说，现在有一种离线往实时迁移的趋势。所以 诸如 sqoop、datax 这种传统离线数据同步方式应该会逐渐淡出，相比较，seatunnel 、 airbyte 这种后起之秀 一定会越来越强大。不过，实时也意味着需要更灵活的资源分配方式，需要掌握更深的技术栈，对开发人员要求也会更高</p><p>Anyway，所有大数据架构的底层都是存储。数据如果是存放在 hdfs + hive 这种传统数仓架构，对实时性要求不高，那么 sqoop + azkaban / airflow 模式就完全足够了。数据需要存放在 clickhouse / kudu 这种 OLAP 存储，业务需要获取实时数据进行分析，那么就需要 seatunnel 这种实时同步的服务。没有绝对的哪个更好，只有更合适</p>]]></content>
      
      
      <categories>
          
          <category> 大数据 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 大数据 </tag>
            
            <tag> emr </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>不妨与众不同</title>
      <link href="/2023/04/17/tomoo-rashiku/"/>
      <url>/2023/04/17/tomoo-rashiku/</url>
      
        <content type="html"><![CDATA[<p><a href="https://mp.weixin.qq.com/s/tn5yrKOxwKbg7vxFuwO3cg">本文公众号</a></p><h2 id="歌词和翻译"><a href="#歌词和翻译" class="headerlink" title="歌词和翻译"></a>歌词和翻译</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line">あの服に 釘付けなのに</span><br><span class="line">なんでまた 後ずさり</span><br><span class="line">僕じゃなくて服が僕をきちゃいそう</span><br><span class="line"></span><br><span class="line">对那件衣服，突然有点爱不释手</span><br><span class="line">但为什么之后又临阵退却</span><br><span class="line">仿佛穿上之后就不是我自己了</span><br><span class="line"></span><br><span class="line">やーやー 続けてみれば</span><br><span class="line">みんなから慣れてくるのさ</span><br><span class="line">おしゃれボーイはそうそそのかしてた</span><br><span class="line"></span><br><span class="line">呀，不过再多保持这种风格的话</span><br><span class="line">大家说不定就能习惯了吧</span><br><span class="line">对面那位帅哥，似乎还在邀请我共舞呢</span><br><span class="line"></span><br><span class="line">らしくもなくたっていいでしょう</span><br><span class="line">着こなせるか NO かはあとじゃない鏡をにらんで迷ううちに</span><br><span class="line">You, your, you, I my, me</span><br><span class="line">季節が変わるよ</span><br><span class="line"></span><br><span class="line">不妨与众不同</span><br><span class="line">合身 Yes or No，这问题就先抛到一边去吧</span><br><span class="line">面对镜子前精心装扮的自己，陶醉之时</span><br><span class="line">身边无数的你和我</span><br><span class="line">还有窗外的季节，仿佛都在改变</span><br><span class="line"></span><br><span class="line">昨日までの僕がこうなら</span><br><span class="line">今日もこうじゃなくちゃ</span><br><span class="line">なんてな訳ないな引っ張られなくていい</span><br><span class="line"></span><br><span class="line">昨天的我是这种风格</span><br><span class="line">今天的我想尝试非同寻常</span><br><span class="line">这种太过勉强的执念，就暂时放在一边好啦</span><br><span class="line"></span><br><span class="line">「あの人」になりたいんじゃない</span><br><span class="line">「パーフェクト」も違うなあ</span><br><span class="line">ただ 僕は僕を引き伸ばしたいだけ</span><br><span class="line"></span><br><span class="line">不能成为「那样的人」为好</span><br><span class="line">达不到「perfect」的程度也罢</span><br><span class="line">只是想展示，就这样原原本本的自我</span><br><span class="line"></span><br><span class="line">あるのはいつも願いだけ</span><br><span class="line">あるのはいつも願いだけ</span><br><span class="line">あるのはいつも願いだけ</span><br><span class="line">残るのはいつも願いだけ</span><br><span class="line"></span><br><span class="line">唯有让我坚持的愿望</span><br><span class="line">唯有期待改变的愿望</span><br><span class="line">唯有和你相关的愿望</span><br><span class="line">唯有这些愿望，留存于心</span><br><span class="line"></span><br><span class="line">らしくもなくたっていいでしょう</span><br><span class="line">真似でもふりでもやって損じゃない</span><br><span class="line">もっと楽しくなれるよ You you</span><br><span class="line">No one knows who I am</span><br><span class="line">No one knows who you are</span><br><span class="line"></span><br><span class="line">不妨与众不同</span><br><span class="line">真心或是伪装，都无计得失</span><br><span class="line">你呀，不妨卸下更多的重负</span><br><span class="line">谁也不会在意我的真面目</span><br><span class="line">也不会在意你酒量有几度</span><br><span class="line"></span><br><span class="line">らしくもなくたっていいでしょう</span><br><span class="line">大通りに出るしかないのさ</span><br><span class="line">しれっと着替えて歩いてれば</span><br><span class="line">You are you, I am I</span><br><span class="line">季節が笑うよ</span><br><span class="line">ドキドキしてるよ</span><br><span class="line"></span><br><span class="line">那就特立独行吧</span><br><span class="line">大道理他们爱说，也没办法</span><br><span class="line">换身轻装，说走就走</span><br><span class="line">你就是你，我还是我</span><br><span class="line">季节随风笑</span><br><span class="line">内心跟你跳</span><br></pre></td></tr></table></figure><h2 id="碎碎念"><a href="#碎碎念" class="headerlink" title="碎碎念"></a>碎碎念</h2><p>现实中真能这么随意任性就好了</p>]]></content>
      
      
      <categories>
          
          <category> 音乐 </category>
          
          <category> TOMOO </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 音乐 </tag>
            
            <tag> 日语 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>shell 常用工具指令</title>
      <link href="/2023/04/14/shell-tools/"/>
      <url>/2023/04/14/shell-tools/</url>
      
        <content type="html"><![CDATA[<p><a href="https://blog.csdn.net/xiaoliizi/article/details/130158402">本文csdn博客地址</a></p><h2 id="常用组件-服务安装"><a href="#常用组件-服务安装" class="headerlink" title="常用组件/服务安装"></a>常用组件/服务安装</h2><p>背景: 不同语言组件开发需求，需要经常快速切换开发环境，或者在新机器安装开发环境。于是将常用开发语言的安装 固化成脚本，方便后续使用</p><p>项目: <a href="https://github.com/smiecj/shell-tools">shell-tools</a></p><p>举例: 安装 trino 较高版本，需要 jdk17，通过这个项目 直接执行 <strong>make java-new</strong> 即可</p><p>安装完成后，环境变量中自动就配置了 jdk17</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># java</span><br><span class="line">export JAVA_HOME=/usr/java/jdk-17.0.6+10 # java</span><br></pre></td></tr></table></figure><h2 id="hive-表迁移"><a href="#hive-表迁移" class="headerlink" title="hive 表迁移"></a>hive 表迁移</h2><p><a href="https://www.jianshu.com/p/82af10e8249e">参考-hive数据迁移</a></p><p>背景: 需要跨集群迁移 hive 表结构，涉及两步: 迁移表数据 和 迁移表结构</p><h3 id="表数据迁移"><a href="#表数据迁移" class="headerlink" title="表数据迁移"></a>表数据迁移</h3><p>如果两个集群环境相通，可直接迁移 hdfs 数据</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">su ods -c &quot;hadoop distcp hdfs://source_cluster/apps/hive/warehouse/db_name.db hdfs://target_cluster/apps/hive/warehouse/db_name/db&quot;</span><br></pre></td></tr></table></figure><p>如果网络不互通，需要先把数据下载下来，再手动传到目标集群。如果数据量不大还是可行的<br>su hdfs -c “hdfs dfs -get hdfs://cluster_name/apps/hive/warehouse/db_name.db/table_name”</p><p>for current_table in ${table_arr[@]}<br>do<br>    su hdfs -c “hdfs dfs -get hdfs://cluster_name/apps/hive/warehouse/db_name.db/${current_table}”<br>done</p><h3 id="表结构迁移"><a href="#表结构迁移" class="headerlink" title="表结构迁移"></a>表结构迁移</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">table_arr=(需要导出的表列表)</span><br><span class="line"></span><br><span class="line">echo &quot;&quot; &gt;&gt; /tmp/ddl.sql</span><br><span class="line">for current_table in $&#123;table_arr[@]&#125;</span><br><span class="line">do</span><br><span class="line">beeline -u jdbc:hive2://hive_server_host:10000/dw -n hive -e &quot;show create table $&#123;current_table&#125;&quot; 2&gt;/dev/null | sed &#x27;s/.*createtab_stmt.*//g&#x27; | sed &#x27;s/.*--.*//g&#x27; | sed &#x27;s/| //g&#x27; | sed -E &#x27;s/ +\|//g&#x27; &gt;&gt; /tmp/ddl.sql</span><br><span class="line">echo &quot;;&quot; &gt;&gt; /tmp/ddl.sql</span><br><span class="line">done</span><br></pre></td></tr></table></figure><p>然后在目标环境 执行导出的 ddl.sql</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">beeline -n user -u jdbc:hive2://hive_server_host:10000/db_name -f /tmp/ddl.txt</span><br></pre></td></tr></table></figure><h2 id="批量添加-ssh-key"><a href="#批量添加-ssh-key" class="headerlink" title="批量添加 ssh key"></a>批量添加 ssh key</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">ip_list=(需要添加的机器列表)</span><br><span class="line">ssh_port=22</span><br><span class="line"></span><br><span class="line">ssh_public_key_arr=(&quot;ssh-rsa ...&quot;)</span><br><span class="line"></span><br><span class="line">IFS=&quot;&quot;</span><br><span class="line">for current_ip in $&#123;ip_list[@]&#125;</span><br><span class="line">do</span><br><span class="line">ssh -p$&#123;ssh_port&#125; $&#123;current_ip&#125; &quot;echo &#x27;&#x27; | sudo tee -a /root/.ssh/authorized_keys&quot;</span><br><span class="line">for current_ssh_key in $&#123;ssh_public_key_arr[@]&#125;</span><br><span class="line">do</span><br><span class="line">ssh -p$&#123;ssh_port&#125; $&#123;current_ip&#125; &quot;echo &#x27;$&#123;current_ssh_key&#125;&#x27; | sudo tee -a /root/.ssh/authorized_keys&quot;</span><br><span class="line">done</span><br><span class="line">done</span><br></pre></td></tr></table></figure><h2 id="frp-反向代理批量安装"><a href="#frp-反向代理批量安装" class="headerlink" title="frp 反向代理批量安装"></a>frp 反向代理批量安装</h2><p>公司内网禁用了 服务部署环境 ssh 端口和本地开发环境的连接，登录机器需要通过 <a href="https://docs.jumpserver.org/zh/master/">jumpserver</a> 非常不方便</p><p>参考 <a href="https://github.com/fatedier/frp">frp</a> 项目，写了一个批量在多节点安装 frpc 的脚本</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"># frps 安装</span><br><span class="line">echo &quot;sshd:127.0.0.1&quot; &gt;&gt; /etc/hosts.allow</span><br><span class="line"></span><br><span class="line">mkdir -p /opt/modules/frps</span><br><span class="line">pushd /opt/modules/frps</span><br><span class="line">curl -LO https://github.com/fatedier/frp/releases/download/v0.40.0/frp_0.40.0_linux_amd64.tar.gz</span><br><span class="line">tar -xzvf frp_0.40.0_linux_amd64.tar.gz</span><br><span class="line">cd frp_0.40.0_linux_amd64</span><br><span class="line">echo &quot;&quot;&quot;</span><br><span class="line">[common]</span><br><span class="line">bind_port = 7001</span><br><span class="line">authenticate_new_work_conns = true</span><br><span class="line">authenticate_heartbeats = true</span><br><span class="line">authentication_method = token</span><br><span class="line">token = frp认证token</span><br><span class="line">&quot;&quot;&quot; &gt; frps.ini</span><br><span class="line">nohup ./frps -c ./frps.ini &gt; /dev/null 2&gt;&amp;1 &amp;</span><br><span class="line">popd</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"># frpc 批量安装</span><br><span class="line"></span><br><span class="line">ip_list=(需要安装的节点列表)</span><br><span class="line">remote_port=6001</span><br><span class="line">ssh_port=22</span><br><span class="line"></span><br><span class="line">for current_ip in $&#123;ip_list[@]&#125;</span><br><span class="line">do</span><br><span class="line"></span><br><span class="line">ssh -p$&#123;ssh_port&#125; $&#123;current_ip&#125; &quot;mkdir -p /opt/modules/frpc &amp;&amp; cd /opt/modules/frpc &amp;&amp; curl -LO https://github.com/fatedier/frp/releases/download/v0.40.0/frp_0.40.0_linux_amd64.tar.gz &amp;&amp; tar -xzvf frp_0.40.0_linux_amd64.tar.gz &amp;&amp; cd frp_0.40.0_linux_amd64 &amp;&amp; hostname=`hostname | sed &#x27;s/\..*//g&#x27;` &amp;&amp; echo -e &quot;\n[common]\nserver_addr = router1\nserver_port = 7001\nauthenticate_new_work_conns = true\nauthenticate_heartbeats = true\nauthentication_method = token\ntoken = frp认证token\n[ssh_$&#123;remote_port&#125;]\ntype = tcp\nlocal_port = $&#123;ssh_port&#125;\nremote_port = $&#123;remote_port&#125;&quot; | tee frpc.ini&quot;</span><br><span class="line"></span><br><span class="line">ssh -p$&#123;ssh_port&#125; $&#123;current_ip&#125; &quot;ps -ef | grep &#x27;frpc&#x27; | grep -v grep | awk &#x27;&#123;print \$2&#125;&#x27; | xargs --no-run-if-empty kill -9&quot;</span><br><span class="line">ssh -p$&#123;ssh_port&#125; $&#123;current_ip&#125; &quot;nohup /opt/modules/frpc/frp_0.40.0_linux_amd64/frpc -c /opt/modules/frpc/frp_0.40.0_linux_amd64/frpc.ini &gt; /dev/null 2&gt;&amp;1 &amp;&quot;</span><br><span class="line"></span><br><span class="line">ssh -p$ $&#123;current_ip&#125; &#x27;echo &quot;sshd:127.0.0.&quot; | tee -a /etc/hosts.allow&#x27;</span><br><span class="line"></span><br><span class="line">remote_port=$((remote_port+1))</span><br><span class="line">done</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="快速访问指定容器名"><a href="#快速访问指定容器名" class="headerlink" title="快速访问指定容器名"></a>快速访问指定容器名</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"># /usr/bin/goto</span><br><span class="line"></span><br><span class="line">#!/bin/bash</span><br><span class="line"># set -euxo pipefail</span><br><span class="line"></span><br><span class="line">echo &quot;hello go!&quot;</span><br><span class="line"></span><br><span class="line">if [ $# -lt 2 ]; then</span><br><span class="line">        echo &quot;Invalid input!&quot;</span><br><span class="line">        exit</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">node_name=$1</span><br><span class="line">env_name=$2</span><br><span class="line"></span><br><span class="line"># goto container dev_zsh</span><br><span class="line">if [ &quot;$node_name&quot; == &quot;container&quot; ]; then</span><br><span class="line">        container_name=$env_name</span><br><span class="line">        container_count=`docker ps -a --filter name=^$container_name\$ | grep -v &quot;CREATED&quot; | wc -l | sed &#x27;s/\t//g&#x27; | sed &#x27;s/ //g&#x27;`</span><br><span class="line">        if [ &quot;1&quot; == &quot;$container_count&quot; ]; then</span><br><span class="line">                container_id=`docker ps -a --filter name=^$container_name\$ | grep -v &quot;CREATED&quot; | sed &#x27;s/ .*//g&#x27;`</span><br><span class="line">                docker exec -it $container_id /bin/zsh</span><br><span class="line">                if [ 0 -ne $? ]; then</span><br><span class="line">                        docker exec -it $container_id /bin/bash</span><br><span class="line">                fi</span><br><span class="line">        else</span><br><span class="line">                echo &quot;container: $env_name, get count $container_count, will not enter&quot;</span><br><span class="line">        fi</span><br><span class="line">        exit</span><br><span class="line">else</span><br><span class="line">        echo &quot;command not valid&quot;</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line"># goto container dev: bash into container name &quot;dev&quot;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 开发工具 </category>
          
          <category> shell </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> shell </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>github action 基于个人项目实践</title>
      <link href="/2023/04/04/github-action/"/>
      <url>/2023/04/04/github-action/</url>
      
        <content type="html"><![CDATA[<p><a href="https://blog.csdn.net/xiaoliizi/article/details/131145170">本文csdn地址</a></p><h2 id="DevOps-和-Jenkins"><a href="#DevOps-和-Jenkins" class="headerlink" title="DevOps 和 Jenkins"></a>DevOps 和 Jenkins</h2><p>作为一名开发，虽然也没有经常听到 <strong><a href="https://en.wikipedia.org/wiki/DevOps">Devops</a> （研发和运维一体化）这个概念</strong>，但日常工作中已经无处不在地用着 DevOps 工具。自研也好，基于开源项目改造也好，互联网公司基本都会有自已的一套 DevOps 工具</p><p>所谓 DevOps 这个概念，不过是在我们日常开发流程上抽象一层，把<strong>开发、测试、运维</strong>等角色，日常的手动操作，都<strong>抽象成特定的语言/模板表述</strong>。有了这一层抽象之后，任务的<strong>自动化</strong>就有基础了。自动化之后 各个角色也能够从杂事中解放出来，分担其他角色的事情，或是更专注于领域深层的技术</p><p>一个完全没有实现自动化的研发体系，会是什么样的呢？想象一下：开发需要三头六臂，一边忙着开发需求，一边因为单元测试不够完善，不停地改着来自线上环境退回的 bug 单，甚至还要和运维 battle 服务部署的细节；测试一边要用 jmeter 给开发刚发布到测试环境的服务做压测，一边还要被测试组长批评: 这么基本的 bug 你怎么没有测出来？运维，那就更不用说了，这边数据库需要扩容，那边服务需要发布，根本没有停下休息的时候</p><!--开发需要完成需求功能开发，进行编写代码、提交到仓库、保证。测试需要保证上线生产环境的服务完整想象一下如果整个开发流程 都需要手动，会是一个什么场景: **开发人员**准时准点（下划线）并跟**测试人员**通知说 需求已经开发完成，可以**测试**了，测试人员又回头跟你说，那你在测试环境**发布一下版本**，开发就说好，于是**在开发机器上**执行 mvn package 给**项目打好了包**，把文件传给测试，测试开始**在测试机上执行测试用例**，所有用例都通过之后，又**通知开发**: 好你这个服务可以发布了，于是开发又要把包发给**运维人员**，**运维在生产环境把服务包部署好**，最后由**用户验收需求**。好了，整个过程 大家都掉了不少头发--><p>光是想象一下就已经头大了。如果不依靠成熟的工具 去分担一些琐事，不管是什么角色，都无法专注自己应该做的事</p><p>于是我们要先说到 <strong><a href="https://github.com/jenkinsci/jenkins">Jenkins</a></strong>: 一个开源的 <a href="https://en.wikipedia.org/wiki/CI/CD">CI/CD</a> （持续集成、持续开发） 服务，对 DevOps 流程做了很好的抽象，上面说到的所有过程，在 Jenkins 中都变成了<strong>插件</strong>。不管你是开发 测试 还是运维，总能在<a href="https://plugins.jenkins.io/">插件市场</a>中找到适合自己的，只需要按照既定的模板写好任务流程 ，就能自动化地执行任务了</p><p><img src="/2023/04/04/github-action/11.png" alt="Jenkins 插件市场"></p><p>举个例子，<a href="https://plugins.jenkins.io/golang">Go</a> 这个插件，就可以帮你做好 golang 环境的初始化工作。你只需要把服务编译、打包指令写好就行，以后都可以用同一个模板<br>官方示例:</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">pipeline &#123;</span><br><span class="line">  <span class="comment">// 选择任意执行机器</span></span><br><span class="line">  agent any</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 定义 golang 版本为 1.19，插件会自动帮我们在执行器中安装这个版本</span></span><br><span class="line">  tools &#123; go &#x27;1.19&#x27; &#125;</span><br><span class="line"></span><br><span class="line">  stages &#123;</span><br><span class="line">    stage(&#x27;Build&#x27;) &#123;</span><br><span class="line">      steps &#123;</span><br><span class="line">        <span class="comment">// 打印 golang 版本</span></span><br><span class="line">        sh &#x27;go version&#x27;</span><br><span class="line">        <span class="comment">// 编译产生可执行文件</span></span><br><span class="line">        sh &#x27;go build -o main ./main.go&#x27;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不过正是因为Jenkins对流程的抽象程度很高，上手难度也并不低。它的<strong>任务定义语法、插件系统、容器化部署、集群部署</strong> ，每一块都可以深度展开。本文的重点并不是要深入介绍 Jenkins，也不是把目光放到公司级别: 几千上万人使用的DevOps工具是什么样子的，而是<strong>专注于我们自己</strong>，在自己项目的日常开发中，是否也能用上这样能给我们带来便利的工具呢？</p><p>笔者遇到的场景是，自己开发了一个服务镜像仓库（包含各种服务的 Dockerfile），以及一个后台服务。镜像更新了什么功能，需要在本地重新构建镜像提交到 docker hub 仓库；后台项目实现了新功能，想跑跑单元测试 验证完整性，也需要在本地手动执行所有单测方法。虽然说熟能生巧，但总归是<strong>需要自己去“亲力亲为”的事</strong></p><p>正好，今天的主角 <strong><a href="https://docs.github.com/en/actions">Github Action</a></strong>: 这样一个Github直接提供给我们的 自动化CI/CD 工具，就派上了用场。有了它，不管我的服务什么时候需要更新，我都只管把代码提交到 github，剩下的部署和测试过程，都交给 action 帮我执行就好，是真的 <strong>save my time</strong> 了</p><h2 id="本文内容概览"><a href="#本文内容概览" class="headerlink" title="本文内容概览"></a>本文内容概览</h2><p>本文将从 github action 的使用方式入手，介绍它的基本语法，了解如何从零开始构建 action 任务。然后从笔者个人的实践出发，探讨 action 是否真的可以帮助我们提升开发效率<!--。最后扩展了解一下其他的公有云持续构建产品，看看网上其他人对这些产品的使用体验--></p><h2 id="github-action"><a href="#github-action" class="headerlink" title="github action"></a>github action</h2><h3 id="创建-action-任务"><a href="#创建-action-任务" class="headerlink" title="创建 action 任务"></a>创建 action 任务</h3><p><a href="https://docs.github.com/en/actions/quickstart">官方教程-Quickstart for GitHub Actions</a></p><p>Github Action 任务和 Github 代码仓库之间是绑定关系，<strong>一个 action 任务的描述文件最终会挂载到项目的 .github/workflows 目录下</strong>。我们可以在Github 上创建一个项目，然后按照官方文档的 quickstart 示例来提交一个 action 任务，就能体验基本功能了</p><p>这个任务不需要和仓库代码有任何关系，一个空项目都可以提交 action 任务</p><p>示例任务: （触发条件为 push 代表任意提交都会触发执行）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">name: GitHub Actions Demo</span><br><span class="line">run-name: $&#123;&#123; github.actor &#125;&#125; is testing out GitHub Actions 🚀</span><br><span class="line">on: [push]</span><br><span class="line">jobs:</span><br><span class="line">  Explore-GitHub-Actions:</span><br><span class="line">    runs-on: ubuntu-latest</span><br><span class="line">    steps:</span><br><span class="line">      # 打印一些 github action 自带的环境变量，如 github.event_name: 时间名称（push）、github.ref: 分支名（refs/heads/smiecj-patch-1）</span><br><span class="line">      - run: echo &quot;🎉 The job was automatically triggered by a $&#123;&#123; github.event_name &#125;&#125; event.&quot;</span><br><span class="line">      - run: echo &quot;🐧 This job is now running on a $&#123;&#123; runner.os &#125;&#125; server hosted by GitHub!&quot;</span><br><span class="line">      - run: echo &quot;🔎 The name of your branch is $&#123;&#123; github.ref &#125;&#125; and your repository is $&#123;&#123; github.repository &#125;&#125;.&quot;</span><br><span class="line">      - name: Check out repository code</span><br><span class="line">        uses: actions/checkout@v3</span><br><span class="line">      - run: echo &quot;💡 The $&#123;&#123; github.repository &#125;&#125; repository has been cloned to the runner.&quot;</span><br><span class="line">      - run: echo &quot;🖥️ The workflow is now ready to test your code on the runner.&quot;</span><br><span class="line">      - name: List files in the repository</span><br><span class="line">        run: |</span><br><span class="line">          ls $&#123;&#123; github.workspace &#125;&#125;</span><br><span class="line">      - run: echo &quot;🍏 This job&#x27;s status is $&#123;&#123; job.status &#125;&#125;.&quot;</span><br></pre></td></tr></table></figure><p>提交任务过程: 首先在仓库的 Action 一栏 创建一个自定义任务</p><p><img src="/2023/04/04/github-action/06.png" alt="创建 github action"></p><p>然后会提示 是选择直接 commit 到主分支 还是创建一个单独分支 并创建 pr，这里建议选择后者</p><p><img src="/2023/04/04/github-action/07.png" alt="提交 github action"></p><p>pr创建完成后，将自动触发 action 任务的执行，如下图 显示任务执行中</p><p><img src="/2023/04/04/github-action/08.png" alt="action 状态"></p><p>action 执行的每一个步骤（step）都有非常详细的日志</p><p><img src="/2023/04/04/github-action/10.png" alt="action 日志"></p><p>如果我们需要把刚才创建的 action 流程保存下来，可以把这个 pr 合并。也可以直接在本地开发时手动创建 .github/workflows 目录，将流程定义保存成 yml 文件，提交到仓库后就能自动触发执行了</p><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><table><thead><tr><th>概念</th><th>说明</th></tr></thead><tbody><tr><td><a href="https://docs.github.com/en/actions/learn-github-actions/understanding-github-actions#workflows">Workflow</a></td><td>任务单位，一个 github action yaml 文件即对应一个任务，一个 workflow 下 可定义多个 job</td></tr><tr><td><a href="https://docs.github.com/en/actions/learn-github-actions/understanding-github-actions#events">Event</a></td><td>触发 workflow 运行的事件，可以是一次 commit 提交，一次 pr 合并请求，到达设定的触发时间等</td></tr><tr><td><a href="https://docs.github.com/en/actions/learn-github-actions/understanding-github-actions#jobs">Job</a></td><td>Workflow 内定义的具体执行的任务，同一个 Workflow 中的任务将会在同一个 Runner 中运行，因此可以设定依赖关系，上一个 Job 的产物可以在下一个 Job 使用。默认没有依赖关系的 Job 将会并行执行</td></tr><tr><td><a href="https://docs.github.com/en/actions/learn-github-actions/understanding-github-actions#actions">Action</a></td><td>将 Workflow 开放为模板，可在 Market 中供别人使用</td></tr><tr><td><a href="https://docs.github.com/en/actions/learn-github-actions/understanding-github-actions#runners">Runner</a></td><td>Workflow 执行环境，每个 Runner 同时只能运行一个 job。若有特殊需求，可以使用<a href="https://docs.github.com/en/actions/using-github-hosted-runners/using-larger-runners">更高性能的执行器</a>，或者使用<a href="https://docs.github.com/en/actions/hosting-your-own-runners">自己部署的执行器</a></td></tr></tbody></table><h3 id="Market"><a href="#Market" class="headerlink" title="Market"></a>Market</h3><p><a href="https://github.com/marketplace?type=actions">Github Action Market</a> 类似刚才提到的 Jenkins Market，有非常多现成的，可以直接复用的任务。分类包括: 服务发布（如将服务发布到 aws）、安全（CodeQL 扫描）、持续集成（编译）、自动化（提交issue后自动回复）、页面生成（Hugo），非常丰富</p><p><img src="/2023/04/04/github-action/17.png" alt="choose a workflow from market"></p><h3 id="Workflow-基本语法"><a href="#Workflow-基本语法" class="headerlink" title="Workflow 基本语法"></a>Workflow 基本语法</h3><p><a href="https://docs.github.com/en/actions/using-workflows/about-workflows">About workflows</a></p><h4 id="触发条件"><a href="#触发条件" class="headerlink" title="触发条件"></a>触发条件</h4><p>对应基本概念中的 Action，常见配置有:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"># 在提交到 main 分支时触发（PR 不会触发）</span><br><span class="line">on:</span><br><span class="line">  push:</span><br><span class="line">    branches:</span><br><span class="line">    - main</span><br><span class="line">    - release/*</span><br><span class="line"></span><br><span class="line"># 提交 合并到 main 分支的 PR 时触发</span><br><span class="line">on:</span><br><span class="line">  pull_request:</span><br><span class="line">    branches:</span><br><span class="line">    - main</span><br><span class="line"></span><br><span class="line"># push / pr 且不论分支</span><br><span class="line">on:</span><br><span class="line">  [push, pull_request]</span><br><span class="line"></span><br><span class="line"># 定时触发</span><br><span class="line"># 注意: 触发时间为中时区 而不是当地时间 / crontab 表达式中最后一位的 day of the week 范围为 0-6</span><br><span class="line">on:</span><br><span class="line">  schedule:</span><br><span class="line">    - cron:  &#x27;30 5,17 * * *&#x27;</span><br></pre></td></tr></table></figure><p><a href="https://docs.github.com/zh/actions/using-workflows/events-that-trigger-workflows">更多触发条件</a></p><h4 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">on:</span><br><span class="line">  workflow_dispatch</span><br><span class="line"></span><br><span class="line">env:</span><br><span class="line">  DAY_OF_WEEK: Monday</span><br><span class="line"></span><br><span class="line">jobs:</span><br><span class="line">  greeting_job:</span><br><span class="line">    runs-on: ubuntu-latest</span><br><span class="line">    env:</span><br><span class="line">      Greeting: Hello</span><br><span class="line">    steps:</span><br><span class="line">      - name: &quot;Say Hello Mona it&#x27;s Monday&quot;</span><br><span class="line">        run: echo &quot;$Greeting $First_Name. Today is $DAY_OF_WEEK!&quot;</span><br><span class="line">        env:</span><br><span class="line">          First_Name: Mona</span><br></pre></td></tr></table></figure><p><a href="https://docs.github.com/zh/actions/learn-github-actions/variables#default-environment-variables">常见默认环境变量</a>，如 GITHUB_ACTOR 表示流程发起者</p><h4 id="运行环境"><a href="#运行环境" class="headerlink" title="运行环境"></a>运行环境</h4><p>对应概念的 Runner 执行器</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">jobs:</span><br><span class="line">  my_job:</span><br><span class="line">    name: deploy to staging</span><br><span class="line">    runs-on: ubuntu-18.04</span><br></pre></td></tr></table></figure><p><a href="https://docs.github.com/en/actions/using-github-hosted-runners/about-github-hosted-runners#supported-runners-and-hardware-resources">可选 Runner 列表</a></p><p>Linux 执行器的默认分配资源：2核7G 14G SSD – 基本够用了</p><h4 id="初始化各语言环境"><a href="#初始化各语言环境" class="headerlink" title="初始化各语言环境"></a>初始化各语言环境</h4><p>在Market中搜索关键字 actions/setup-语言名，大部分语言都有官方插件 支持初始化语言环境。比如如我们需要编译一个 java + maven 工程，就可以使用 <a href="https://github.com/actions/setup-java">actions/setup-java</a> 插件，它会帮我们装好 java、maven、gradle 和 sbt 等环境</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">name: Java CI</span><br><span class="line"></span><br><span class="line">on: [push]</span><br><span class="line"></span><br><span class="line">jobs:</span><br><span class="line">  build:</span><br><span class="line">    runs-on: ubuntu-latest</span><br><span class="line"></span><br><span class="line">    steps:</span><br><span class="line">      - uses: actions/checkout@v3</span><br><span class="line">      - name: Set up JDK 17</span><br><span class="line">        uses: actions/setup-java@v3</span><br><span class="line">        with:</span><br><span class="line">          java-version: &#x27;17&#x27; # 安装 Java 版本</span><br><span class="line">          distribution: &#x27;temurin&#x27; # 开源jdk 类型，可选 Zulu、Temurin 和 AdoptOpenJDK</span><br><span class="line">      - name: Build with Maven</span><br><span class="line">        # 通过 maven 编译项目</span><br><span class="line">        run: mvn --batch-mode --update-snapshots package</span><br></pre></td></tr></table></figure><h4 id="产物"><a href="#产物" class="headerlink" title="产物"></a>产物</h4><p>有一些action任务的执行结果 我们是希望 github 先帮我们保管的，比如服务编译后用于发布服务的安装包，或是测试报告等</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"># 上传</span><br><span class="line">jobs:</span><br><span class="line">  example-job:</span><br><span class="line">    name: Save output</span><br><span class="line">    steps:</span><br><span class="line">      - shell: bash</span><br><span class="line">        run: |</span><br><span class="line">          expr 1 + 1 &gt; output.log</span><br><span class="line">      - name: Upload output file</span><br><span class="line">        uses: actions/upload-artifact@v3</span><br><span class="line">        with:</span><br><span class="line">          name: output-log-file</span><br><span class="line">          path: output.log</span><br><span class="line"></span><br><span class="line"># 下载</span><br><span class="line">jobs:</span><br><span class="line">  example-job:</span><br><span class="line">    steps:</span><br><span class="line">      - name: Download a single artifact</span><br><span class="line">        uses: actions/download-artifact@v3</span><br><span class="line">        with:</span><br><span class="line">          name: output-log-file</span><br></pre></td></tr></table></figure><p>Workflow 的更多语法，如 <a href="https://docs.github.com/en/actions/using-workflows/caching-dependencies-to-speed-up-workflows">构建过程缓存</a>、<a href="https://docs.github.com/en/actions/using-workflows/reusing-workflows">引用其他项目的 workflow</a> 可参考官方文档</p><h3 id="限额"><a href="#限额" class="headerlink" title="限额"></a>限额</h3><p><a href="https://docs.github.com/en/actions/learn-github-actions/usage-limits-billing-and-administration">Usage limits, billing, and administration</a></p><p>既然是商用产品 免费使用的限额一定是有的，一部分限制如下:</p><ul><li>单次 Job 的执行时间: 6小时</li><li>Workflow 的执行时间: 35天</li><li>一小时内 请求 github api 次数: 1000次</li><li>同时运行的 job 数量: 20个（可以升级账号扩容），超过的将会排队</li></ul><p>个人使用的话 同时运行 job 数 这个比较需要留意。不过避免超过限制的方式也简单: 不同任务的触发时间尽量错开，比如编译A服务设置在凌晨2点触发，编译B服务设置到凌晨3点</p><h2 id="个人实践"><a href="#个人实践" class="headerlink" title="个人实践"></a>个人实践</h2><p>掌握了 Github Action 的基本语法后，就可以基于具体的项目来实践了。笔者进行了镜像自动构建、单测覆盖率统计 两种任务的部署</p><h3 id="镜像构建"><a href="#镜像构建" class="headerlink" title="镜像构建"></a>镜像构建</h3><p>之前做了一些开发环境镜像 和 大数据服务镜像 写成了 Dockerfile，都是在本地手动触发构建和提交的。现在都可以让 github action 帮我自动构建，定期提交到镜像仓库了</p><p><a href="https://frederick-s.github.io/2021/12/26/build-and-push-docker-image-to-docker-hub-with-github-actions/">参考博客-使用 GitHub Actions 自动构建和推送 Docker 镜像到 Docker Hub</a></p><h4 id="准备-dockerhub-开启二次登录-和-创建-token"><a href="#准备-dockerhub-开启二次登录-和-创建-token" class="headerlink" title="准备: dockerhub 开启二次登录 和 创建 token"></a>准备: dockerhub 开启二次登录 和 创建 token</h4><p>首先为了账号尽量安全，不要在 Github 上直接配置账号密码（权限过大），我们需要在 Docker Hub 给自己的账号创建Token</p><p><a href="https://docs.docker.com/docker-hub/access-tokens">参考-Create and manage access tokens</a></p><p>登录 Docker hub -&gt; 右上角账号 -&gt; Account Settings -&gt; Security -&gt; New Access Token</p><p><img src="/2023/04/04/github-action/01.png" alt="创建token"></p><p>如上图，创建了一个 Github Action 专用 token ，因为需要提交/覆盖镜像 所以 Write 权限是需要的。当然这个权限还是比较大，我们还是需要注意保管好 不要泄露</p><p>然后将这个 token 在 github 中配置，登录 github -&gt; 进入需要添加 action 任务的仓库 -&gt; Settings -&gt; Secrets and variables -&gt; Actions -&gt; New repository secret 。secret key 将作为任务的配置</p><p><img src="/2023/04/04/github-action/02.png" alt="配置token"></p><h4 id="准备-项目中提供-Dockerfile"><a href="#准备-项目中提供-Dockerfile" class="headerlink" title="准备: 项目中提供 Dockerfile"></a>准备: 项目中提供 Dockerfile</h4><p>既然需要支持 通过 action 自动构建镜像，在项目中提供 Dockerfile 自然也是必须的</p><p>以 <a href="https://github.com/apache/superset">superset</a> 为例，根路径下的 <a href="https://github.com/apache/superset/blob/master/Dockerfile">Dockerfile</a>，action 文件中有发布镜像流程 <a href="https://github.com/apache/superset/blob/master/.github/workflows/docker-release.yml">docker-release.yml</a> ，算是一个非常标准的参考项目了</p><p>如何给自己的服务编写 Dockerfile，也可以以不同语言的开源项目 Dockerfile 作为参考，对 Dockerfile 语法有一个大致了解就行。标准过程都是 <strong>定义编译镜像 -&gt; 编译生成可执行文件 -&gt; 定义服务运行镜像 -&gt; 拷贝二进制文件 -&gt; 定义服务启动指令</strong></p><h4 id="定义任务"><a href="#定义任务" class="headerlink" title="定义任务"></a>定义任务</h4><p>以笔者项目 <a href="https://github.com/smiecj/docker-centos/blob/main/.github/workflows/build_dev_python.yml">docker-centos</a> 为例: 定期构建 python 开发环境镜像任务如下:</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">on:</span></span><br><span class="line">  <span class="attr">schedule:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">cron:</span> <span class="string">&quot;0 3 * * 0&quot;</span> <span class="comment"># 每周一3点（中时区）开始构建</span></span><br><span class="line"></span><br><span class="line"><span class="attr">jobs:</span></span><br><span class="line">  <span class="attr">docker:</span></span><br><span class="line">    <span class="attr">runs-on:</span> <span class="string">ubuntu-latest</span></span><br><span class="line">    <span class="attr">steps:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Checkout</span></span><br><span class="line">        <span class="attr">uses:</span> <span class="string">actions/checkout@v2</span></span><br><span class="line">        <span class="attr">with:</span></span><br><span class="line">          <span class="attr">fetch-depth:</span> <span class="number">0</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Set</span> <span class="string">up</span> <span class="string">QEMU</span></span><br><span class="line">        <span class="attr">uses:</span> <span class="string">docker/setup-qemu-action@v1</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Set</span> <span class="string">up</span> <span class="string">Docker</span> <span class="string">Buildx</span></span><br><span class="line">        <span class="attr">uses:</span> <span class="string">docker/setup-buildx-action@v1</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Login</span> <span class="string">to</span> <span class="string">DockerHub</span></span><br><span class="line">        <span class="attr">uses:</span> <span class="string">docker/login-action@v1</span> </span><br><span class="line">        <span class="attr">with:</span></span><br><span class="line">          <span class="attr">username:</span> <span class="string">$&#123;&#123;</span> <span class="string">secrets.DOCKERHUB_USERNAME</span> <span class="string">&#125;&#125;</span> <span class="comment"># 对应前面配置的 docker hub 登录凭证</span></span><br><span class="line">          <span class="attr">password:</span> <span class="string">$&#123;&#123;</span> <span class="string">secrets.DOCKERHUB_TOKEN</span> <span class="string">&#125;&#125;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">build_dev_python</span></span><br><span class="line">        <span class="attr">run:</span> <span class="string">REPO=mzsmieli</span> <span class="string">cmd=push</span> <span class="string">platform=linux/amd64,linux/arm64</span> <span class="string">make</span> <span class="string">build_dev_python</span> <span class="comment"># 该指令将触发 docker buildx build ... --push 进行镜像的构建和提交</span></span><br></pre></td></tr></table></figure><h4 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h4><p>action 任务的执行记录</p><p><img src="/2023/04/04/github-action/13.png" alt="执行记录"></p><p>镜像仓库中可以看到上次更新时间正好就是周一</p><p><img src="/2023/04/04/github-action/12.png" alt="镜像仓库"></p><h3 id="单元测试覆盖率统计"><a href="#单元测试覆盖率统计" class="headerlink" title="单元测试覆盖率统计"></a>单元测试覆盖率统计</h3><p>一个完善的后台项目除了业务逻辑代码，还会包含大量的<a href="https://en.wikipedia.org/wiki/Unit_testing">单元测试</a>（即基本方法测试），用于正式上线前的自测。单元测试写得质量如何，其中一个重要评判标准就是<a href="https://en.wikipedia.org/wiki/Code_coverage">单测覆盖率</a>，即<strong>所有的单元测试所覆盖的业务代码行数 / 总业务代码行数 比例</strong>。覆盖率越高，说明单测越完整，实际上线时出现问题的概率也越低</p><p>而这个单测覆盖率的统计过程 如果能交给 Github Action 帮我们做，<strong>每天输出覆盖率报告</strong>，自然也能省不少心</p><h4 id="项目准备"><a href="#项目准备" class="headerlink" title="项目准备"></a>项目准备</h4><p>要统计单测覆盖率 当然我们要先给项目写好一部分单测。每种语言都会有自己的<strong>单测编写规范</strong> 和 <strong>单测框架库</strong>。框架库如何选择，可以在写单测之前了解一下 官方或者社区有没有比较流行好用的，选择一个自己用着更顺手的就行</p><p>规范这块则尽量参考官方文档，如一些后台语言的单测规范:</p><ul><li><a href="https://pkg.go.dev/testing">go-testing</a></li><li><a href="https://docs.python.org/3/library/unittest.html">python-unittest</a></li><li><a href="https://junit.org/junit5/docs/current/user-guide">java-junit5</a></li></ul><h4 id="环境准备-创建-mysql-service"><a href="#环境准备-创建-mysql-service" class="headerlink" title="环境准备 - 创建 mysql service"></a>环境准备 - 创建 mysql service</h4><p><a href="https://ovirium.com/blog/how-to-make-mysql-work-in-your-github-actions">参考-How to make MySQL work in your GitHub Actions</a></p><p>由于单测执行环境一般是在自己电脑 或者公司的测试环境，和线上环境是网络隔离的，我们需要给一些无法实际执行的函数写好<a href="https://en.wikipedia.org/wiki/Mock_object">mock</a> 。所谓mock，就是让我们编写的函数 在特定输入下 <strong>返回特定输出</strong>，比如我们的服务对接 一个客户系统，在本地环境无法连上客户的环境，就需要 mock 用户服务的接口，自己写接口输出，来<strong>模拟真实环境的情况</strong></p><p>对于业务层代码来说，写好 mock 取决于业务数据的分类规模。但对于更底层的<strong>数据接口层</strong>，如 gorm，需要 mock 的场景就更多了。比如业务层需要考虑 用户传入参数为 a、b、c 的输出，分别对应 d、e、f，那么数据接口层就要考虑 a、b、c 的首次存入、重复存入、事务存入等情况，除了 d、e、f 还需要返回各种错误提示。写好完整的 mock 比业务层要复杂多了</p><p>考虑到这点，数据库的交互部分我没有写 mock，而是直接通过 action 的 service 功能，启动一个 mysql 服务来完成项目中 需要依赖数据库的代码测试</p><h4 id="定义任务-1"><a href="#定义任务-1" class="headerlink" title="定义任务"></a>定义任务</h4><p>最终任务定义:</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">jobs:</span></span><br><span class="line">  <span class="attr">test:</span></span><br><span class="line">    <span class="attr">runs-on:</span> <span class="string">ubuntu-latest</span></span><br><span class="line">    <span class="attr">services:</span></span><br><span class="line">      <span class="attr">mysql:</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">mysql:5.7</span> <span class="comment"># 通过官方的 5.7 版本镜像来启动 mysql</span></span><br><span class="line">        <span class="attr">env:</span></span><br><span class="line">          <span class="attr">MYSQL_ROOT_PASSWORD:</span> <span class="string">root_password</span></span><br><span class="line">        <span class="attr">ports:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="number">3306</span><span class="string">:3306</span></span><br><span class="line">        <span class="attr">options:</span> <span class="string">--health-cmd=&quot;mysqladmin</span> <span class="string">ping&quot;</span> <span class="string">--health-interval=10s</span> <span class="string">--health-timeout=5s</span> <span class="string">--health-retries=3</span></span><br><span class="line">    <span class="attr">steps:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Checkout</span></span><br><span class="line">        <span class="attr">uses:</span> <span class="string">actions/checkout@v2</span></span><br><span class="line">        <span class="attr">with:</span></span><br><span class="line">          <span class="attr">fetch-depth:</span> <span class="number">0</span></span><br><span class="line">          <span class="attr">ref:</span> <span class="string">master</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">setup</span> <span class="string">goalng</span></span><br><span class="line">        <span class="attr">uses:</span> <span class="string">actions/setup-go@v4</span></span><br><span class="line">        <span class="attr">with:</span></span><br><span class="line">          <span class="attr">go-version:</span> <span class="string">&#x27;&gt;=1.17.0&#x27;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">init</span> <span class="string">mysql</span></span><br><span class="line">        <span class="attr">run:</span> <span class="string">|</span></span><br><span class="line"><span class="string">          # 初始化单测需要用到的数据库表</span></span><br><span class="line"><span class="string">          mysql -h127.0.0.1 -P3306 -uroot -proot_password -e &quot;create database temp&quot;</span></span><br><span class="line"><span class="string">          mysql -h127.0.0.1 -P3306 -uroot -proot_password -Dtemp &lt; db/mysql/mysql_test.sql</span></span><br><span class="line"><span class="string"></span>      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">test</span></span><br><span class="line">        <span class="attr">run:</span> <span class="string">|</span></span><br><span class="line"><span class="string">          # 执行项目下的所有单测用例，并生成测试报告</span></span><br><span class="line"><span class="string">          go test -covermode=count -coverprofile=coverprofile.cov -run=&quot;^Test&quot; -coverpkg=$(go list ./... | grep -v &quot;/test&quot; | tr &#x27;\n&#x27; &#x27;,&#x27;) ./...</span></span><br><span class="line"><span class="string"></span>      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Collect</span> <span class="string">Test</span> <span class="string">Coverage</span> <span class="string">File</span></span><br><span class="line">        <span class="attr">uses:</span> <span class="string">actions/upload-artifact@v3</span>  <span class="comment"># 上传测试覆盖率报告，即上个指令生成的 coverprofile.cov</span></span><br><span class="line">        <span class="attr">with:</span></span><br><span class="line">          <span class="attr">name:</span> <span class="string">go_common_coverage</span></span><br><span class="line">          <span class="attr">path:</span> <span class="string">coverprofile.cov</span></span><br></pre></td></tr></table></figure><h4 id="效果-1"><a href="#效果-1" class="headerlink" title="效果"></a>效果</h4><p>执行记录和上传的文件:</p><p><img src="/2023/04/04/github-action/14.png" alt="执行记录"></p><h3 id="github-首页构建"><a href="#github-首页构建" class="headerlink" title="github 首页构建"></a>github 首页构建</h3><p>对个人开发者而言，github action 还可以用于 个人博客、应用app 的定期发布。github 首页就有点类似个人博客，可以按 markdown 语法编写内容，进行自我展示</p><p>我的 github 首页:</p><p><img src="/2023/04/04/github-action/15.png" alt="github首页"></p><p>不过我还没有实现首页自动更新，这里以另一个github用户 <a href="https://github.com/wuhan005/wuhan005">E99p1ant</a> 的 首页项目为例。他将首页的 markdown 文件内容写成了模板样式，通过 action 任务，定期读取模板 并生成最终展示的首页样式</p><p>如图 他的项目的 README_template.md 文件只是模板，实际内容来自同一个仓库的 profile.yml</p><p><img src="/2023/04/04/github-action/16.png" alt="模板文件"></p><h4 id="任务定义"><a href="#任务定义" class="headerlink" title="任务定义"></a>任务定义</h4><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">jobs:</span></span><br><span class="line">  <span class="attr">build:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">Update</span> <span class="string">Profile</span></span><br><span class="line">    <span class="attr">runs-on:</span> <span class="string">ubuntu-latest</span></span><br><span class="line">    <span class="attr">steps:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Set</span> <span class="string">up</span> <span class="string">Go</span> <span class="number">1.16</span></span><br><span class="line">        <span class="attr">uses:</span> <span class="string">actions/setup-go@v1</span></span><br><span class="line">        <span class="attr">with:</span></span><br><span class="line">          <span class="attr">go-version:</span> <span class="number">1.16</span></span><br><span class="line"></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Build</span> <span class="string">&amp;</span> <span class="string">Run</span></span><br><span class="line">        <span class="attr">run:</span> <span class="string">|</span></span><br><span class="line"><span class="string">          # 执行主进程 将 模板文件 生成真正的首页效果</span></span><br><span class="line"><span class="string">          # 过程: 读取 README_template.md 作为模板，profile.yml 作为内容，替换 template 中的 &#123;&#123;PROJECTS&#125;&#125; 和 &#123;&#123;CVE&#125;&#125;，生成最终的 README.md</span></span><br><span class="line"><span class="string">          go build . &amp;&amp; ./main &amp;&amp; rm main</span></span><br><span class="line"><span class="string"></span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Git</span> <span class="string">Commit</span></span><br><span class="line">        <span class="attr">run:</span> <span class="string">|</span></span><br><span class="line"><span class="string">          git add README.md</span></span><br><span class="line"><span class="string">          git commit -S -m &quot;Update README.md&quot; || true # 内容没有变化时 commit 会报错，所以需要忽略报错，否则最后一步不会执行</span></span><br><span class="line"><span class="string"></span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Push</span> <span class="string">changes</span></span><br><span class="line">        <span class="attr">uses:</span> <span class="string">ad-m/github-push-action@master</span></span><br><span class="line">        <span class="attr">with:</span></span><br><span class="line">          <span class="attr">github_token:</span> <span class="string">$&#123;&#123;</span> <span class="string">secrets.GITHUB_TOKEN</span> <span class="string">&#125;&#125;</span></span><br><span class="line">          <span class="attr">branch:</span> <span class="string">master</span></span><br></pre></td></tr></table></figure><h2 id="其他商用CI-CD工具"><a href="#其他商用CI-CD工具" class="headerlink" title="其他商用CI/CD工具"></a>其他商用CI/CD工具</h2><p>基本每个云厂商都会有 配套产品，如 <a href="https://azure.microsoft.com/en-us/products/devops/pipelines">Azure Pipeline</a>, <a href="https://aws.amazon.com/cn/codepipeline">AWS CodePipeline</a> 和 <a href="https://circleci.com/">CircleCI</a> 等</p><p>不过既然是商用 就代表具有一定的使用门槛，场景也受限，往往会和厂商的其他服务配套才能使用。如此一对比，就更凸显 Github Action 对我们个人开发者的易用性了</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>从自己的实际体验来看，即使用上了 Github Action 也不会带来很明显的感知。但它带来的方便依然是存在的。就好像你在公司所用的所有基础设施（机器、数据库、sso服务等）一样。只有去刻意注意 才会发现它们的存在: 原来它们背后也凝聚了一群开发者的智慧，帮我们省去了非常多的工作</p><!--如果 Github Action 对你来说也会是这样的一个工具，能 save your time，那不妨就尝试用起来--><p>最后再分享前段时间看到的<a href="https://mp.weixin.qq.com/s/bOnW8gDJ-dXp4KbAjhDw9A">一段话</a>:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">但是像区块链这些东西，你就扪心自问一下，区块链是不是所有公司都在用？没有用就让那些猪在天上再飞一会，指不定哪天风停了呢。但是，今天那些很强劲的风已经刮了十多年、二十年了，你为啥不去呢？</span><br></pre></td></tr></table></figure><p>不敢说 今年大火的 chatgpt 能有多少人真正用得上，因为刚刚以产品的形态进入公众视野，还没有沉淀下来。但是诸如 Github Action 这种 DevOps 工具，已经发展很多年，使用方式也在很多大厂得到了实践，还是很值得了解和实践的</p>]]></content>
      
      
      <categories>
          
          <category> 开发工具 </category>
          
          <category> github </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 云服务 </tag>
            
            <tag> github </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【翻译】Bye bye me 歌曲鉴赏</title>
      <link href="/2023/03/01/vaundy-byebyeme/"/>
      <url>/2023/03/01/vaundy-byebyeme/</url>
      
        <content type="html"><![CDATA[<h2 id="译者序"><a href="#译者序" class="headerlink" title="译者序"></a>译者序</h2><p>回忆对我们来说，偶尔顿足回首，确实会有不同的味道，但回忆终究只会是回忆，捧起它是很有分量，放下它也可变得轻盈。如果你步履蹒跚，不妨试试 放下一些回忆，轻装前进吧</p><p><a href="https://media.framu.world/columns/lyrics_consideration/bye-by-me/">原文-Bye by me【Vaundy】歌詞の意味を考察！ドラマ「捨ててよ、安達さん。」OPテーマ</a></p><p><a href="https://www.youtube.com/watch?v=b3H5RvRHiYs">歌曲MV(油管)</a><br><a href="https://www.bilibili.com/video/BV1NZ4y147MY">歌曲MV(B站)</a></p><h2 id="作者序"><a href="#作者序" class="headerlink" title="作者序"></a>作者序</h2><p>这次让我们一起来欣赏 Vaundy 2020年4月发布的数字单曲，由他亲自作词作曲编曲 <strong>「Bye by me」</strong>的歌词吧</p><p>这首歌也被作为 安达祐实（ 安達 祐実／あだち ゆみ）主演的电视剧  <strong>「丢掉吧，安达小姐」</strong>（放送时间：2020年4月-7月）的片头曲</p><p>剧情：安达小姐 被委托参加 「每期“丢掉”一个自己的物品」 连载系列的制作 ，之后，每次准备扔掉什么东西的时候，都会做一个梦，梦里出现了神秘的少女，还有尚未丢掉的东西，变成了人的样子，向自己恳求“请丢掉我吧”<br>当然，最后这些物品也不一定被扔掉了，可能卖掉，或者送给别人，只是换了个地方并“重获新生”</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">译者: </span><br><span class="line">整部剧主线就是安达祐实 作为童星出道，成为演员所经历的故事。一集讲述一个故事，更像是舞台剧，节奏比较慢，挺适合茶余饭后当“点心”</span><br></pre></td></tr></table></figure><p><img src="/2023/03/01/vaundy-byebyeme/suteteyo01.jpeg" alt="剧照"></p><h2 id="歌曲部分"><a href="#歌曲部分" class="headerlink" title="歌曲部分"></a>歌曲部分</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">まんでい今日は</span><br><span class="line">どこへ行くの？</span><br><span class="line">まぁいいけど</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">今天是周一了</span><br><span class="line">你要去哪里呢？</span><br><span class="line">嘛，去哪都好啦</span><br></pre></td></tr></table></figure><p>第一段就体现了电视剧的主题 <strong>「即使是要丢掉一些东西，也请你放心」</strong></p><p>安达小姐作为主角 对话的搭档，正是她平日在犹豫是否要丢掉的东西。在梦中，它们变成了安达回忆中真实存在的某个人，和她对话</p><p>大部分东西都是在安达每次工作出门前，目所能及的</p><p>不过这些物品，在安达小姐的梦中，并没有特别地依依不舍。他们似乎不在乎自己最后是否被丢掉，只是在被丢掉之前，希望从安达小姐那里，得到它们疑惑已久的答案</p><p><img src="/2023/03/01/vaundy-byebyeme/suteteyo02.jpeg" alt="剧照"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ちゅーすでぃ今日も</span><br><span class="line">お仕事だったんでしょ？</span><br><span class="line">まぁいいけど</span><br><span class="line">まぁいいけど</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">今天星期二了</span><br><span class="line">这会你也是刚下班吧？</span><br><span class="line">嘛，工作上怎样都好啦</span><br><span class="line">怎样都好</span><br></pre></td></tr></table></figure><p>周二的安达小姐，迎着家里一些东西“欢迎”的目光回到家，有一种<strong>将要和他们轻声交谈、平日也守护着彼此的气氛</strong></p><p>假定我们自己身边的物品，也有自己的意识，和主人一同生活许久了，主人身上细微的变化，还有内心的小心思，恐怕也是能感受到吧</p><p><img src="/2023/03/01/vaundy-byebyeme/suteteyo06.jpeg" alt="剧照"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">うぇんずでぃ今日は</span><br><span class="line">何を見ているの？</span><br><span class="line">辛いでしょ</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">今天到周三了</span><br><span class="line">你这会在看什么呢？</span><br><span class="line">很辛苦对吧</span><br></pre></td></tr></table></figure><p>通过这次节目 安达小姐也发现了真正不舍得丢掉的一些东西，以及那些割舍不掉的回忆</p><p>周三，安达小姐又心绪复杂地扔掉了一个充满回忆的东西，梦中那东西甚至还安慰她道「很辛苦对吧」</p><p>也许因为是别人赠予的东西吧，丢掉它之前，安达唤起了更多回忆</p><p><img src="/2023/03/01/vaundy-byebyeme/suteteyo09.jpeg" alt="剧照"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">またさ</span><br><span class="line">遠く去った過去の日々に</span><br><span class="line">名前をつけて</span><br><span class="line">いたんでしょ</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">我们呢</span><br><span class="line">给已经过去许久的每一天</span><br><span class="line">都赋予了属于它们的名字</span><br><span class="line">今天也是，对吧？</span><br></pre></td></tr></table></figure><p>明明是不需要的东西，却不舍得丢掉，大概是还<strong>对「过去」的一些回忆 充满着纠结</strong></p><p>「向过去之日赋予名」这种诗意般的表现，也是对应着电视剧中对欲弃之物“拟人化”的表现形式</p><p>或许 「不要忘记过去的荣耀」、「对前任还抱有幻想」 这种 「还试想回到过去的日子」 任性的想法，在我们身上也会有</p><p><img src="/2023/03/01/vaundy-byebyeme/suteteyo11.jpeg" alt="剧照"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">お帰り、でももういいよ</span><br><span class="line">伝えたいことは特にないから</span><br><span class="line">お帰り、でももういいの</span><br><span class="line">覚えてることも</span><br><span class="line">もうないよ</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">欢迎回来，怎样都好啦</span><br><span class="line">你想说的话，我们都能理解</span><br><span class="line">欢迎回来，已经没事啦</span><br><span class="line">需要你去用力记住的东西</span><br><span class="line">不过是一些浮云啦</span><br></pre></td></tr></table></figure><p>「已经可以了」在这部剧中的充分体现，就是「丢掉也没关系」</p><p>对剧中的“主角们”将会被丢掉的东西来说，设定就是「充满着 安达小姐 对过去难以割舍的回忆」</p><p>为了<strong>从「过去」的执念中解放出来，把这些东西丢掉</strong>也许是一个不错的方式</p><p>安达小姐一开始对于丢掉一些东西、忘记过去还抱有一丝罪恶感，于是拟人化的物品们 开始安慰她 「反正把我留着也没有什么意义了」</p><p><img src="/2023/03/01/vaundy-byebyeme/suteteyo08.jpeg" alt="剧照"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">さーすでぃ今日は</span><br><span class="line">どこに行ってきたの？</span><br><span class="line">遅いでしょ</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">今天星期四了</span><br><span class="line">你去了哪里逛呢？</span><br><span class="line">回来得有点晚哟</span><br></pre></td></tr></table></figure><p>周四 在家担心着安达小姐回来有点晚了的“东西” ，默默散发着一丝母爱</p><p>安达小姐作为童星很早就出道，现在也已经是母亲了</p><p>这是否也暗示着 每次梦里都会出现的神秘的少女 和安达的紧密联系呢？</p><p><img src="/2023/03/01/vaundy-byebyeme/suteteyo05.jpeg" alt="剧照"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ふらいでぃ今日は</span><br><span class="line">思い出していたの？</span><br><span class="line">あのことを</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">又是周五了</span><br><span class="line">你是否记起了</span><br><span class="line">那段久未拾起的回忆呢？</span><br></pre></td></tr></table></figure><p>周五的安达小姐，想要扔掉的「那个东西」是一段「回忆」，或者说「观念」（和其他集扔掉的都是实物 有所不同）</p><p>观众看到这集（第五集：想被别人喜欢），或许会在自己的记忆中有所共鸣吧？（为了去迁就、成全别人，去做过一些费力不讨好的事）</p><p><img src="/2023/03/01/vaundy-byebyeme/suteteyo10.jpeg" alt="剧照"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">でもさ</span><br><span class="line">遠く去った過去の日々と</span><br><span class="line">サヨナラしたら</span><br><span class="line">楽でしょ</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">但是吧</span><br><span class="line">如果对曾经的日子</span><br><span class="line">好好说一声“再见”的话</span><br><span class="line">也许就可以释怀吧？</span><br></pre></td></tr></table></figure><p>标题 「Bye by me」字面意思就是（和过去的自己）「再见」</p><p>与其反复记起过去的一些回忆，不如把它们都存放在内心深处 一个不容易被发现的角落</p><p>对过去的那些执着，也随着旧物品一起丢掉，才能感受到「解脱」吧</p><p><img src="/2023/03/01/vaundy-byebyeme/suteteyo04.jpeg" alt="剧照"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">休みの夜のやけ酒も</span><br><span class="line">それくらいにして</span><br><span class="line">もういいだろ？</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">就好像在休息日的夜晚</span><br><span class="line">举杯畅饮那般</span><br><span class="line">这样就满足了吗</span><br></pre></td></tr></table></figure><p>温馨提醒: 过度饮酒当然是不健康的</p><p>副歌部分的「已经足够了」，在这里对应的就是倒入杯中之酒已经「足够了」</p><p>沉浸在「过去」，不断地给自己添酒买醉，与其陷入这种恶循环，不妨停下片刻，提醒自己 「（喝的酒）<strong>差不多已经够了吧</strong>」，或许就能从这种循环中解脱出来</p><p><img src="/2023/03/01/vaundy-byebyeme/suteteyo07.jpeg" alt="剧照"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">愛していたんだきっと</span><br><span class="line">思い出すことを</span><br><span class="line">愛して、愛して</span><br><span class="line">満たしているなら</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">你一定还牵挂着</span><br><span class="line">一些放不下的回忆吧</span><br><span class="line">想念着，困扰着</span><br><span class="line">满腔思绪，如果快要承受不住</span><br></pre></td></tr></table></figure><p>「向回忆致以拥抱」这种生活态度，也许是最高级的温柔</p><p>被「过去」束缚住，尽管有所自觉，也难免深陷对自己这种状态的厌恶当中。这种情况下还能改善现状，<strong>必定是被别人「关心」着，或者是被别人肯定着</strong>，才能以轻松的心态继续前进（否则一定需要时间去调整的）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">忘れても、もういいよ</span><br><span class="line">伝えたいことはもう伝えたから</span><br><span class="line">忘れても、もういいよ</span><br><span class="line">この先もいっぱいたまっていくから</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">不如放下那些回忆吧，也没什么</span><br><span class="line">你心里想说的话，都已经传达给我们了</span><br><span class="line">就算再也不记得那些事，也没关系</span><br><span class="line">以后你还会拥有更多更多的回忆</span><br></pre></td></tr></table></figure><p>「已经可以了」还有一种含义就是 「<strong>忘记（那些回忆）也没关系</strong>」</p><p>我们所生活的时刻，也是由无数个「当下」连结而成的，认知也好，记忆也好，都是在不断增加的过程。<strong>平时 想追求怎样的目标，想在什么事情上花更多精力，还是取决于自己</strong>。对那些让自己不开心的事情，最好就「忘记」吧，向前看，发现更值得去热爱的事情</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">愛してやまない傷を</span><br><span class="line">無くして新しい日々を</span><br><span class="line">またね</span><br><span class="line">Bye by me~~</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">抚慰快愈合的伤痕</span><br><span class="line">挥别将结束的一天</span><br><span class="line">再见啦，明天的我</span><br><span class="line">Bye by me~~</span><br></pre></td></tr></table></figure><p>最后一段副歌 总结了作者的一种<strong>反向对待人生烦恼</strong>的态度：​ 「接受回忆在内心的伤痕」的同时，「越积越多的身边物品和烦恼，都把它们丢掉吧」（译者：其实就是电视剧的主题）</p><p>简单点做起，那不如就<strong>明天起床，以轻松愉快的态度，去迎接新的一天吧</strong></p><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>MV才是这首歌的灵魂</p><p>通过闪现的方式讲述一段故事之后</p><p>在某一瞬间，这些回忆好像都消失不见，回到现实，我还是我自己，一直都是活在当下的自己</p>]]></content>
      
      
      <categories>
          
          <category> 音乐 </category>
          
          <category> Vaundy </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 音乐 </tag>
            
            <tag> 日语 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>那个男孩</title>
      <link href="/2023/01/30/life-202301/"/>
      <url>/2023/01/30/life-202301/</url>
      
        <content type="html"><![CDATA[<h2 id="腌面"><a href="#腌面" class="headerlink" title="腌面"></a>腌面</h2><p>就在家门口吃到了很不错的腌面，面的口感非常到位，汤里面的酒糟也是画龙点睛</p><p>面里面的葱蒜稍微少了一点，不过也无碍了，这就是家乡的味道</p><p><img src="/2023/01/30/life-202301/02.png" alt="腌面"></p><h2 id="民间足球"><a href="#民间足球" class="headerlink" title="民间足球"></a>民间足球</h2><p>老家的足球文化还是挺不错的，到村里初中看看，都在举办一场球赛</p><p>看着这些说不上有名气的赞助商，球场简陋的环境，但球场周边却不乏热情的观众，不禁又联想到去年和大家一起看的国足比赛了，无奈笑出了声</p><p>还是不吐槽罢了，真到了国足能有起色那天，一定不会少了真心热爱足球的观众。现在所希望的只是让这种平凡的比赛，能真正被社会关注，带动起民间足球的氛围</p><p><img src="/2023/01/30/life-202301/03.jpeg" alt="老家足球"></p><h2 id="英超"><a href="#英超" class="headerlink" title="英超"></a>英超</h2><p>连续两年都有足球节目，只是相比去年让人闹心的结果，今年换成了酣畅淋漓的对攻剧本</p><p>做个中立球迷还是挺好的，什么结果都能接受，什么热闹都能凑</p><p><img src="/2023/01/30/life-202301/04.png" alt="看英超"></p><h2 id="创造"><a href="#创造" class="headerlink" title="创造"></a>创造</h2><p>和亲戚聊天聊到一个问题：如何能过上自己满意的人生</p><p>这个问题肯定很难，我们也没讨论出一个共识，毕竟每个人都有权对自己的人生进行规划，这种问题非要达成共识的话，方向就已经有问题了</p><p>最通用的办法，可能还是先接受现实 ，再试图创造不一样的东西 。接受现实更多的是迫不得已，我们已经经历了低谷的三年，今年可能会好转，但谁也说不准。创造这点也是和疫情有关：封控三年，需要改变的不只是相关政策，还有人们思想的惯性，治疗内心的伤痕。很多人还习惯于听天由命，不受控制的生活节奏中。只有自己相信 自己能改变什么，能创造出什么东西的时候，才能拨动久未触动的内心</p><h2 id="纸炮"><a href="#纸炮" class="headerlink" title="纸炮"></a>纸炮</h2><p>回到老家发现纸炮已经买好了</p><p>看到纸箱里满满的一堆手持烟花和三响炮，还厚古薄今，跟老家小孩子说这都是我们以前玩剩的，没有鱼雷，就没那味</p><p>结果跟他们一起玩起来，还不是有种回到童年的感觉</p><p>随时间变化的可能不只是烟花，还有童心</p><p><img src="/2023/01/30/life-202301/05.png" alt="噼里啪啦"></p><h2 id="那个男孩"><a href="#那个男孩" class="headerlink" title="那个男孩"></a>那个男孩</h2><p>那个生活中有很多烦恼，但依然选择在过年期间，给自己弟弟妹妹报以最纯真笑颜的男孩</p><p>那个还没从校园毕业，但已经考虑好这两年的发展方向，构想着成家之后家庭模样的男孩</p><p>那个作为长辈，承担很多事情，承受着来自后生和更长辈的各种目光，但依然能从容应对，还能给后辈适时提醒和引导的“男孩”</p><p>有幸认识这些男孩</p>]]></content>
      
      
      <categories>
          
          <category> 生活 </category>
          
          <category> 记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 生活 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【翻译】怪獣の花唄 歌曲鉴赏</title>
      <link href="/2023/01/08/vaundy-kaijunohanauta/"/>
      <url>/2023/01/08/vaundy-kaijunohanauta/</url>
      
        <content type="html"><![CDATA[<h2 id="译者序"><a href="#译者序" class="headerlink" title="译者序"></a>译者序</h2><p>作为 Vaundy 的第一张专辑 《<strong>strobo</strong>》收录的歌曲，算是比较早就认识这首歌了，不过第一次听 还没有很特别的感觉​</p><p>直到一天看到了MV，才真正明白这首歌想表达的东西：​每个人内心的那个 “<strong>怪兽</strong>” 都不太一样，但最后都可以归结成 “<strong>勇气</strong>” 。这首歌呼喊着男主儿时看到的怪兽，其实也是在呼喊着我们的勇气</p><p>今年的红白（日本电视台 NHK 于跨年夜举办的歌会，将当年比较热门的歌手分成红白两组，轮番上台演唱PK，故简称“红白”）上，Vaundy 也选择了这首作为个人主打曲。台风非常耀眼，几乎把红白唱成了自己的演唱会</p><p>话不多说，一起来欣赏这首 属于新生态歌手独特的光芒吧</p><p><a href="https://media.framu.world/columns/lyrics_consideration/kaijunohanauta/">原文-怪獣の花唄【Vaundy】歌詞の意味を考察！怪獣の花唄と怪獣の歌の違いに迫る</a></p><p><a href="https://www.youtube.com/watch?v=UM9XNpgrqVk">歌曲MV(油管)</a><br><a href="https://www.bilibili.com/video/BV1aa411b7n3">歌曲MV(B站)</a><br><a href="https://www.bilibili.com/video/BV12P4y1v79R">红白演唱</a><br><a href="https://www.youtube.com/watch?v=lYLa6zyjhSI">2022.09.09 one man live at BUDOKAN 演唱</a></p><h2 id="作者序"><a href="#作者序" class="headerlink" title="作者序"></a>作者序</h2><p>这次让我们来欣赏Vaundy作词作曲的数字单曲《怪兽的花之歌》（20年5月发布，收录进第一张专辑 《strobo》），一起来赏析歌词里面的含义吧</p><h2 id="歌曲部分"><a href="#歌曲部分" class="headerlink" title="歌曲部分"></a>歌曲部分</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">思い出すのは君の歌</span><br><span class="line">会話よりも鮮明だ</span><br><span class="line">どこに行ってしまったの</span><br><span class="line">いつも探すんだよ</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">回忆起的是你的歌声</span><br><span class="line">比我们聊过的话更加刻骨铭心</span><br><span class="line">你到底去哪里了呢</span><br><span class="line">我可是一直都在寻找着你</span><br></pre></td></tr></table></figure><p>《怪兽的花之歌》歌名里面的词都很好懂，但是根据听者站在不同的角度，又可以有各种各样的解读</p><p>开头是歌曲主角的旁白：我突然回忆起一段旋律，它属于不知去向何方的你。相比那天我们聊过的话，歌曲给我带来的回忆更加强烈。然而，我所心心念念的「<strong>你</strong>」到底是谁，对「<strong>我</strong>」而言又是什么样的存在，作者并没有点明。甚至直到歌曲最后，「<strong>你到底去了何方</strong>」也还是一个谜</p><p><img src="/2023/01/08/vaundy-kaijunohanauta/kaijunohanauta04.png" alt="MV画面"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">思い出すのは君の歌</span><br><span class="line">歌い笑う顔が鮮明だ</span><br><span class="line">君に似合うんだよ</span><br><span class="line">ずっと見ていたいよ</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">回想起了你的歌声</span><br><span class="line">唱着歌的笑颜也逐渐清晰</span><br><span class="line">那模样除了你还会有谁</span><br><span class="line">我可是一直都想再见你一面啊</span><br></pre></td></tr></table></figure><p>「我」一直期待着 再次看到你那唱着歌的笑颜</p><p>然而，不管怎么试图让回忆变得清晰，现实中我已经看不到你的面容，更听不到你的歌声</p><p>都是因为你已经离我而去，到了我无法知晓的远方</p><p>那么又是为何，「我」 要如此执着于 回忆起 「你的歌曲」呢？</p><p>这里可能也暗藏着问题 「你对我来说，到底是什么样的存在呢？」的答案</p><p><img src="/2023/01/08/vaundy-kaijunohanauta/kaijunohanauta05.png" alt="MV画面"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">でも最後に見たいのは</span><br><span class="line">きっともう君の夢の中</span><br><span class="line">もう一度 また聞かせてくれよ</span><br><span class="line">聞きたいんだ</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">但是最后想见到的你</span><br><span class="line">一定已经让我魂牵梦萦</span><br><span class="line">就让我再听一次吧</span><br><span class="line">我是真的想再听到这首歌啊</span><br></pre></td></tr></table></figure><p>关于「你」是谁的解读，有两种比较被认可：「<strong>年少时期的自己</strong>」和 「<strong>去世的挚友</strong>」</p><p>对前者说法的解释是，Vaundy 生日是2000年6月6日，《怪兽的花之歌》发行之日 2020年5月11日，Vaundy 刚好快满20岁。咋即将迈向新的10年之际，不由而感 那个 「年少的自己」「去哪里了呢」。在这个10年青春的「最后」，最初陪伴自己创作音乐的动力：<strong>摇滚之魂</strong>，再次被唤醒，最终作出了这首歌</p><p><img src="/2023/01/08/vaundy-kaijunohanauta/kaijunohanauta07.png" alt="MV画面"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">もっと 騒げ怪獣の歌</span><br><span class="line">まだ消えない</span><br><span class="line">夢の歌唱えて</span><br><span class="line">君がいつも 歌う怪獣の歌</span><br><span class="line">まだ消えない</span><br><span class="line">口ずさんでしまうよ</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">再来一次吧，这首属于你喧闹的怪兽之歌</span><br><span class="line">还没有消失，甚至更加清晰</span><br><span class="line">大声呼唤着我的梦想</span><br><span class="line">你也曾在那时，不知疲倦地唱着这首怪兽之歌</span><br><span class="line">我无法忘却</span><br><span class="line">不知不觉又哼唱起来</span><br></pre></td></tr></table></figure><p>副歌部分真的很好听</p><p>接着 「你=年少的自己」的解读，「怪兽之歌」也许正好对应了「<strong>年少时期才华横溢的自己，抵挡不住的摇滚之魂</strong>」。然而如今，尽管还能从「梦中」强行唤回年少的回忆，这种回忆也「不会消失」，但我也只能哼唱那些回忆中的歌曲罢了（再也无法创作出这样的歌曲）</p><p>关于另一种解读 「你=逝去的挚友」，「怪兽之歌」就成为了「朋友年少时唱起的、仿佛歌声响起，就会有怪兽出现（拍摄特效也好，动画也好）的一首歌」。为纪念这首属于你的 「怪兽之歌」，也为了悼念逝去的你，我也要 「歌唱起、哼唱起」起来，「<strong>回忆中的这首歌颂梦想之歌</strong>」就慢慢成为了「<strong>怪兽的花之歌</strong>」</p><p><img src="/2023/01/08/vaundy-kaijunohanauta/kaijunohanauta08.png" alt="MV画面"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">怪獣の花唄と怪獣の歌ちゃんと別物です。</span><br><span class="line">この話はいつかしよう、ちゃんと理由がある</span><br><span class="line"></span><br><span class="line">—- Vaundy (@vaundy_engawa) May 11, 2020</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">怪兽的花之歌，和 怪兽之歌 是不一样的</span><br><span class="line">关于这个以后会解释，有很充分的理由</span><br><span class="line"></span><br><span class="line">-- Vaundy 于 2020.05.11 发表的推特</span><br></pre></td></tr></table></figure><p><img src="/2023/01/08/vaundy-kaijunohanauta/kaijunohanauta06.png" alt="推特"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">思い出すのは君がいた</span><br><span class="line">ギター持ってる君がいた</span><br><span class="line">忘れられないんだよ</span><br><span class="line">だから僕が歌うよ</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">回想起的是你在身边的日子</span><br><span class="line">那个抱起吉他，认真弹唱的你</span><br><span class="line">我念念不忘</span><br><span class="line">所以我要为你唱起这首歌</span><br></pre></td></tr></table></figure><p>歌词的翻译仁者见仁，但 「<strong>吉他</strong>」象征的意义，与其说是「“怪兽”登场时的音乐」，不如说是 「<strong>摇滚背后的反骨精神</strong>」（译者：结合 MV，这里的 “反骨” 更偏向积极的成分，有一种不畏现实的残酷，勇敢与之抗衡的精气神）</p><p>关于另一种解释：男主是为了迎接 「10年青春的结尾」这样一个人生重要节点，选择以 「<strong>我 = 长大后的自己</strong>」的身份，直面 「<strong>你 = 小时候的自己</strong>」，一边唱着歌，一边向「你」献上一束花，感谢曾经唱着「怪兽之歌 = 10岁世代的摇滚」 的 「你」，对如今的「我」，唱着 「怪兽的花之歌 = 20岁世代的摇滚」的我，一直以来的指引和激励</p><p>「<strong>怪兽</strong>」这个词本身带有一种肆意妄行、「吉他」手在奋力拨弦，尽力呐喊的样子</p><p>很多音乐家，不管怎么提醒自己 「创作音乐，特别是摇滚，一定不要忘记出道初期 的那种冲劲和反骨精神」，随着职业发展（自己创作的音乐更多了，听到的声音也变多了）还是容易忘记初心</p><p><img src="/2023/01/08/vaundy-kaijunohanauta/kaijunohanauta14.png" alt="MV画面"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">落ちてく過去は鮮明で</span><br><span class="line">見せたい未来は繊細で</span><br><span class="line">すぎてく日々には鈍感な君へ</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">原本放下的过去竟开始清晰可见</span><br><span class="line">奋力奔向的未来也逐渐微不足道</span><br><span class="line">所度过的每一天，都是为了唤醒回忆里那逐渐模糊的你</span><br></pre></td></tr></table></figure><p>作为 「但是最后想见到的……我是真的想再听到一次啊」的呼应，是再合适不过了</p><p>尽管 「过去」 的回忆 伴随年龄的增长，会逐渐变得模糊，但当我们听到儿时陪伴自己许久的音乐时，或是回忆突然在梦中闪现时，那种冲击感依然会非常鲜明</p><p>除了音乐（上的回忆会淡去），我们小时候所描述的 「<strong>未来</strong>」是「<strong>微不足道</strong>」的，对应到我们对「<strong>当下」</strong>（时光的）「<strong>迟钝</strong>」，其实都不是一瞬间发生的，这种变化已经悄悄发生在我们所度过的「<strong>日常</strong>」当中（<strong>光阴似箭</strong>）。但「小时候的我们」，也就是年轻人，特别容易后知后觉</p><p><img src="/2023/01/08/vaundy-kaijunohanauta/kaijunohanauta11.png" alt="MV画面"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ねぇ 僕ら</span><br><span class="line">眠れない夜に手を伸ばして</span><br><span class="line">眠らない夜をまた伸ばして</span><br><span class="line">眠くないまだね</span><br><span class="line">そんな日々でいたいのにな</span><br><span class="line">懲りずに</span><br><span class="line">眠れない夜に手を伸ばして</span><br><span class="line">眠らない夜をまた伸ばして</span><br><span class="line">眠くないまだね</span><br><span class="line">そんな夜に歌う 怪獣の歌</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">呐，让我们一起</span><br><span class="line">在睡不着的深夜中伸出双手</span><br><span class="line">让不眠之夜更加漫长</span><br><span class="line">失眠的夜里</span><br><span class="line">多想能够回到跟你在一起的日子</span><br><span class="line">我却没有吸取教训</span><br><span class="line">在独自清醒的黑夜中再次伸出双手</span><br><span class="line">让不眠之夜更加难忘</span><br><span class="line">失眠的夜里</span><br><span class="line">我再次大声唱了起来，这首怪兽之歌啊</span><br></pre></td></tr></table></figure><p>完美承接了最后一段副歌的感情铺垫</p><p>我们的青春期，肯定会有烦恼不断的日子，多少会因为内心的不安，而经历 「无法入眠的夜晚」，反而为了享受快乐而 「通宵」会没有那么多（年轻人也有年轻人的烦恼）</p><p>Vaundy 将这段 「<strong>青春之夜</strong>」，写成了「<strong>怪兽之歌 = 青春期的摇滚之歌</strong>」并歌颂了出来</p><p>然而光阴似箭，即便是曾经拥有「<strong>10年如一日的青春</strong>」，也会有到「<strong>最后</strong>」的时刻</p><p>为了「<strong>纪念对青春的告别，而亲手捧上花束</strong>」，相信这就是 「<strong>怪兽的花之歌</strong>」背后真正的蕴意吧</p><p><img src="/2023/01/08/vaundy-kaijunohanauta/kaijunohanauta13.png" alt="MV画面"></p><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>这次赏析基本 几乎都是从 「你 = 年少时期自己」角度赏析的。不过 「你 = 去世的朋友」这个角度也有成立的理由</p><p>但不管是什么样的解释，歌词给我们的留白 也是值得品味，无需多言的</p><p>「怪兽之歌」和「怪兽的花之歌」，Vaundy以字谜的方式，让这首歌的寓意充满想象，也是非常有意思</p><h2 id="找回勇气"><a href="#找回勇气" class="headerlink" title="找回勇气"></a>找回勇气</h2><p>这首歌本身从听感上，情感就特别饱满，再结合MV，彻底把这首歌的意义升华了</p><p>主人公突然从昏迷还是宿醉中醒来，看着身旁散落一地的东西，回忆也满满的涌上来</p><p>而等到回忆终于渐渐清晰，他也抓住了随之冒出，转瞬即逝的勇气，为了救赎曾经的自己而奔向远方</p><p><strong>MV男主小时候听到朋友歌唱的「怪兽的花之歌」，在他长大后的某个时刻，终于被赋予了意义，成为了他奋不顾身的勇气</strong>。混迹社会的我们，又何尝不想找到一个能让自己找回热情，奋不顾身的理由呢？</p><p><img src="/2023/01/08/vaundy-kaijunohanauta/kaijunohanauta03.jpeg" alt="演唱会"></p>]]></content>
      
      
      <categories>
          
          <category> 音乐 </category>
          
          <category> Vaundy </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 音乐 </tag>
            
            <tag> 日语 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【翻译】花占い 歌曲鉴赏</title>
      <link href="/2022/12/30/vaundy-hanauranai/"/>
      <url>/2022/12/30/vaundy-hanauranai/</url>
      
        <content type="html"><![CDATA[<h2 id="译者序言"><a href="#译者序言" class="headerlink" title="译者序言"></a>译者序言</h2><p>Vaundy 特别擅长通过音乐，在简单的事物上 寄托进自己的情感，并在副歌中把情绪宣泄出来</p><p><strong>「花占い」</strong> 这首歌，就是在 <strong>花占卜</strong> 上，寄托了纠结于确定恋爱关系的人们 ，那一丝丝矛盾、紧张，却又让人沉迷的心思</p><p>这里选择一篇歌曲赏析文进行翻译，希望这首歌的氛围，能在冬日给大家带来一些内心的鼓动和温暖</p><p><a href="https://media.framu.world/columns/lyrics_consideration/hanauranai/">原文-花占い【Vaundy】歌詞の意味を考察！花占いで願う二人の未来とは？</a></p><p><a href="https://www.youtube.com/watch?v=onhBN0qkUcE">歌曲MV地址(油管)</a><br><a href="https://www.bilibili.com/video/BV1Eg411u7b6">歌曲MV地址(B站)</a></p><h2 id="作者序"><a href="#作者序" class="headerlink" title="作者序"></a>作者序</h2><p>这回让我们来欣赏<strong>2021年7月5日</strong>配信的Vaundy的新曲 「<strong>花占い</strong>」</p><p>作为在读大学生、音乐家的 Vaundy，包办作词、作曲和编曲， 已经创作了好几首热门歌曲。而在这次的新歌中，Vaundy又在其中向我们传递了什么样的情感和意义呢？</p><p>另外这首还是7月4日开始放送的电视剧『我的杀意恋爱了』收录的主题曲</p><p>下面先介绍电视剧的主题</p><p>男主 男虎柊 是在「传说的杀手之家」中，被男虎丈一郎养育长大的青年，但后者被人杀害。男虎柊 为了报仇，也为了继承「杀手之家」的家业，决定留在这里，随时找机会复仇</p><p>负责侦查杀害丈一郎凶手的警察， 綿谷詩織，向柊断定凶手正是超人气漫画家 鳴宮美月。柊知道后，本来已经为仇杀做好周到的准备了，但意外的火灾，不但让复仇计划泡汤，反而男虎柊 还在火灾中把漫画家救了出来。通过这个契机，两个人的恋情逐渐生根发芽</p><p>对男虎柊来说，本来应该是暗杀的对象，却萌生了恋情，暗杀计划真的还能顺利进行吗？</p><p>中川大志、新木優子、藤木直人，有这些豪华的演员阵容，一定能让这部剧更出彩</p><p>出于这部电视剧主题而创作的音乐，也让它多了一份期待不是吗？</p><p>下面是Vaundy关于歌曲的评价</p><p>「<br>这里是Vaundy，本次参与了『我的杀意恋爱了』主题曲的制作，我的音乐能跟随这部电视剧一起发布，也是我的荣幸</p><p>了解了这部电视剧的剧情之后，我开始思考「作什么样的曲子呢」，随之浮想到脑海中的第一个关键词就是“舞蹈”</p><p><strong>「希望能创作出，听着让人心动、不知不觉想跟随节奏一同起舞的曲子」</strong></p><p>能够让观众跟着这首剧中 BGM，在脑海中涌现剧中踏入恋情的主角。跟随着剧情画面，大家能多少地因为我的音乐，而拥有心动的感觉。正是带着这种期望，我作出了这首曲子</p><p>歌曲的主题是  「<strong>还未结果的恋情</strong>」，是一个关于 经历了很长很长的时间，依然没能结出恋情的果实，关系就这么一直持续下去的两人的故事</p><p>同时，这首不可思议的曲子，在剧中欣赏的时候，可能还会给你（和直接听这首歌）不一样的印象。电视剧将会在每周进行放送，就请大家尽情享受吧<br>」</p><h2 id="歌曲部分"><a href="#歌曲部分" class="headerlink" title="歌曲部分"></a>歌曲部分</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">街の夕焼けに溶けた</span><br><span class="line">僕たちはまだ2人だろうか</span><br><span class="line">風が吹く僕たちを乗せて</span><br><span class="line">2人でちぎった花に</span><br><span class="line">願いを込めて</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">融化在夕阳街角下的</span><br><span class="line">依然是你我二人对吧</span><br><span class="line">乘着阵阵拂过的晚风</span><br><span class="line">放飞一片片摘落的花瓣</span><br><span class="line">就让我们一起把愿望寄托其中吧</span><br></pre></td></tr></table></figure><p>这首歌的MV开头，是一位靠在墙角桌下的小男孩，在<strong>用食指和拇指比个圈，透过这个圈看向远方，希望能看到和喜欢的人未来的样子</strong></p><p>他看到的未来的世界，是自己长大之后的样子</p><p>「依然是你我二人对吧」这句歌词，我认为是小男孩看到了未来之后所想的事情</p><p>「花占卜」的含义，大家可以说是耳熟能详了，是一个很出名的占卜方式：随着花瓣一片片摘落，依次表示「喜欢」、「讨厌」，以最后一瓣作为结果</p><p>就在这一枚枚的花瓣中，男孩默默地许下了自己的愿望</p><p><img src="/2022/12/30/vaundy-hanauranai/hanauranai05.png" alt="MV画面"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">願うなら</span><br><span class="line">僕たちを出会うよりも</span><br><span class="line">ずっと遠くに</span><br><span class="line">叶うなら</span><br><span class="line">僕たちの運命さえも</span><br><span class="line">もっと遠くに</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">能许下愿望的话</span><br><span class="line">希望我们能在相遇之前</span><br><span class="line">更不知晓对方</span><br><span class="line">愿望能实现的话</span><br><span class="line">希望我们能够逃脱命运</span><br><span class="line">更加远离彼此</span><br></pre></td></tr></table></figure><p>这一段表现了男主通过花占卜，许下的具体愿望</p><p>「<strong>希望我们在相遇之前 更不知晓对方</strong>」男主许下这个愿望，也说明他甚至不想和女主相见，想回到两人相见之前的时间</p><p>这里同时也对应了Vaundy在歌曲评论中说到的“歌曲的主题：「还未结果的恋情」，是一个关于数百上千年，两个人依然没能成为恋人，就这样一直下去的故事</p><p>不管经过多长时间，两人都无法成为真正的恋人 </p><p>既然心心念念的恋情都无法实现，两个人也许不见面会更好。内心这么思考的男主，也多少有一种无奈的感觉呢</p><p><img src="/2022/12/30/vaundy-hanauranai/hanauranai03.jpeg" alt="MV画面"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">なんて　笑って　吐いて　捨てては</span><br><span class="line">君を思い出す</span><br><span class="line">そんな思いを</span><br><span class="line">抱いて　抱えて　悶えた　先には</span><br><span class="line">いつも君がいる</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">就这样笑着，叹息着，无数次想放下，但又忍不住捡起</span><br><span class="line">都是因为想起了你</span><br><span class="line">带着这种丢不掉的思念</span><br><span class="line">拥抱着，背负着，无数次想解脱，但总是为此闷闷不乐</span><br><span class="line">都是因为身边一直有你在</span><br></pre></td></tr></table></figure><p>不管内心怎么下定决心，永远不相见</p><p>静下心来的时候，都会想起你的面容</p><p>也许我们真的就再也无法摆脱这命运，再也离不开对方，也再也无法拥有对方了吧</p><p><img src="/2022/12/30/vaundy-hanauranai/hanauranai06.png" alt="MV画面"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">「そんなことより</span><br><span class="line">恋路の果てにはなにがある」</span><br><span class="line">くだらない話を2人で</span><br><span class="line">しよう</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">算了，与其说这些</span><br><span class="line">不如就 恋爱之路的尽头会是什么呢</span><br><span class="line">这种无关紧要的话题</span><br><span class="line">开始聊起吧</span><br></pre></td></tr></table></figure><p>歌曲主题“无法结出果实的恋爱”，说的正是无法成为恋人的两人，也是电视剧的主角 来自杀手之家的男虎柊，和他的杀人目标鳴宮美月</p><p>在无奈接受自己命运的同时，男主也在思考等待他们的未来会是什么，（然而百思不得其解下）男主做出了决定，邀请女主 一边聊 看似不起眼的小事，一边一同前进，找到真正属于两人的正确道路</p><p><img src="/2022/12/30/vaundy-hanauranai/hanauranai07.png" alt="MV画面"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">僕たちの1000年の恋は</span><br><span class="line">相槌で折れる花のようだ</span><br><span class="line">僕たちは1000年後もまだ</span><br><span class="line">同じように待ってんだ</span><br><span class="line">笑っちゃうよね</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">我们之间漫长的恋爱</span><br><span class="line">就像顺势折断的花朵一样</span><br><span class="line">漫长的恋爱过后</span><br><span class="line">我们一定也会像现在这样，一直等待彼此下去的吧</span><br><span class="line">真是让人见笑了</span><br></pre></td></tr></table></figure><p>这一段带点自嘲的意味，自嘲不管自己做什么，也无法改变的两人之间的关系</p><p>即便过了上千年，<strong>依然只能停留在回忆中的恋情，就像是脆弱的花瓣一样，稍微一碰就要消散</strong>。然而即使是这样，<strong>男主依然决定抱着这束残弱的花，抱着对女主亘古不变的思念</strong>·</p><p><img src="/2022/12/30/vaundy-hanauranai/hanauranai08.png" alt="MV画面"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">あなたと以外</span><br><span class="line">もうどこにもいけない</span><br><span class="line">波の中で</span><br><span class="line">混じり合わない</span><br><span class="line">日々の中で</span><br><span class="line">2人がたっている</span><br><span class="line">永劫を</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">除了在你身旁</span><br><span class="line">我已经无处可去</span><br><span class="line">交融在这片海浪中的我们</span><br><span class="line">即使像沙砾和海水那般无法结合</span><br><span class="line">但就在这样的日常之中</span><br><span class="line">我们也能彼此留下印记</span><br><span class="line">直到永远</span><br></pre></td></tr></table></figure><p>（译者：这段翻译参考了网易云的，海水和沙粒 这个形容简直是太棒了）</p><p>长期处于无法更近一步的关系，男主内心也大声地提出了反问：<strong>对我来说，你的存在到底是不是有那么重要？</strong></p><p>「<strong>波</strong>」也象征着男女主之间，像海浪一样潮起潮落，日复一日的每一天。时间再怎么流逝，两人再怎么有深刻的回忆，也永远不会有交集，就像海浪没有惊喜地拍打沙滩一样</p><p>男主真的能接受这让人不甘的命运吗？</p><p><img src="/2022/12/30/vaundy-hanauranai/hanauranai09.png" alt="MV画面"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">「そんなことより</span><br><span class="line">願いは君との先にある」</span><br><span class="line">たわいない話を2人で</span><br><span class="line">しよう</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">先不说这些了</span><br><span class="line">我有一个愿望，关于和你一起的未来</span><br><span class="line">让我们就这个不起眼的话题</span><br><span class="line">开始谈谈吧</span><br></pre></td></tr></table></figure><p>这里男主的愿望，一个和女主，和未来相关的愿望指的是什么呢？</p><p>笔者认为，这是男主在经过内心斗争之后，终于想通：<strong>即便是两人无法成为恋人，还是想和你永远在一起的愿望</strong></p><p>“<strong>即使我们的故事无关爱情，我们的窃窃私语无法结成恋爱的果实，我依然会守护这样的关系</strong>”</p><p><img src="/2022/12/30/vaundy-hanauranai/hanauranai10.png" alt="MV画面"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">何年経っても妄想が</span><br><span class="line">根を張ってもうこんなに</span><br><span class="line">溢れ出している</span><br><span class="line">願いは</span><br><span class="line">花が散るほど</span><br><span class="line">溢れ出していく</span><br><span class="line">花占う恋歌</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">经过许久，希望慢慢变成了妄想</span><br><span class="line">就像是争相扩张的树根</span><br><span class="line">快要冒出来似的</span><br><span class="line">我的愿望</span><br><span class="line">也如随风飞散的花瓣那般</span><br><span class="line">漫天飞舞</span><br><span class="line">这就是花占卜之情歌</span><br></pre></td></tr></table></figure><p>不管过了多久，我对你的想念都不会改变</p><p>随着花占卜 一片片花瓣被摘下，逐渐在脑海中浮现的幻想，正是和你幸福地度过日常的每一天</p><p>“<strong>喜欢，不喜欢</strong>”，“<strong>能在一起，不能在一起</strong>”，“<strong>能实现，不能实现</strong>”，伴随着花占卜的，还有这些各种各样的，内心翻来覆去的猜测</p><p>两人的恋情究竟会变成什么样子呢？</p><p><img src="/2022/12/30/vaundy-hanauranai/hanauranai12.png" alt="MV画面"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">僕たちの1000年の恋は</span><br><span class="line">相槌で咲く</span><br><span class="line">花のように</span><br><span class="line">僕たちは1000年後もまだ</span><br><span class="line">同じようにちぎってまた</span><br><span class="line">笑っていたいよね</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">我们之间漫长的恋爱</span><br><span class="line">就像争相盛开的</span><br><span class="line">花朵那般</span><br><span class="line">就这样经过千年之后</span><br><span class="line">我们一定也会像现在这样，拾起飘散的花瓣吧</span><br><span class="line">真是让人见笑了</span><br></pre></td></tr></table></figure><p>不管过了多久，还是想和女主一起，捧起花朵，开始花占卜的男主</p><p>笔者从这段歌词读出来的，是一种无奈感：<strong>就这样吧</strong>，哪怕是只能和你维持现状，我也无所谓了。我现在只希望现在的关系能持续下去</p><p><img src="/2022/12/30/vaundy-hanauranai/hanauranai14.png" alt="MV画面"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">何年経っても妄想が</span><br><span class="line">根を張ってもうこんなに</span><br><span class="line">溢れ出している</span><br><span class="line">願いは</span><br><span class="line">何年経っても妄想が</span><br><span class="line">根を張ってもうこんなに</span><br><span class="line">溢れ出している</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">经过多年也变成了妄想的希望</span><br><span class="line">就像是那顽强扩张的树根</span><br><span class="line">快要忍不住冒出来似的</span><br><span class="line">我的愿望啊</span><br><span class="line">......（X2）</span><br></pre></td></tr></table></figure><p>尽管希望就像轻轻一碰就会折断的花那样，但男主还是靠着对女主的一丝想念，把这份希望坚持了下去，甚至还在顽强地生长</p><p>不管遇上什么样艰难的命运，男主依然坚信两个人会有美好的结局。这种强大的内心，有一种能给观众强烈印象的感觉</p><p><img src="/2022/12/30/vaundy-hanauranai/hanauranai15.png" alt="MV画面"></p><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>B站上有这首歌的现场版，译者是真的被漫天飞舞的彩带感染到了，仿佛在诉说着，<strong>​恋爱如花盛开、飘散般绚丽，又如散落般短暂</strong>，然而就这一刻，男主可能只想享受在占卜过程，一点点 随花瓣摘落而心动的感觉，不想被任何人打扰，即便是他看到了可能不完美的结局，他也相信一片片花瓣会带着他走向未来，就像 MV 中的小男孩那样</p><p><img src="/2022/12/30/vaundy-hanauranai/hanauranai16.png" alt="现场版画面"></p>]]></content>
      
      
      <categories>
          
          <category> 音乐 </category>
          
          <category> Vaundy </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 音乐 </tag>
            
            <tag> 日语 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker 常用指令</title>
      <link href="/2022/12/28/docker-command/"/>
      <url>/2022/12/28/docker-command/</url>
      
        <content type="html"><![CDATA[<p><a href="https://blog.csdn.net/xiaoliizi/article/details/128474415">本文csdn地址</a></p><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>对于 Docker 这一个“庞然大物” 来说，想用好它其实没有这么难，掌握好基本几个指令就可以了，这里将平时自己用得多的整理一下</p><h2 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h2><table><thead><tr><th>指令类型</th><th>指令</th><th>功能</th></tr></thead><tbody><tr><td><strong>基本</strong></td><td>docker login</td><td>登录镜像仓库</td></tr><tr><td><strong>镜像操作</strong></td><td><a href="https://docs.docker.com/engine/reference/commandline/images/">docker images</a></td><td>查看本地镜像信息</td></tr><tr><td></td><td><a href="https://docs.docker.com/engine/reference/commandline/pull/">docker pull</a></td><td>拉取镜像</td></tr><tr><td></td><td><a href="https://docs.docker.com/engine/reference/commandline/tag/">docker tag</a></td><td>给一个镜像添加另一个tag</td></tr><tr><td></td><td><a href="https://docs.docker.com/engine/reference/commandline/rmi/">docker rmi</a> <image_id></td><td>删除镜像</td></tr><tr><td></td><td><a href="https://docs.docker.com/engine/reference/commandline/commit/">docker commit</a> -m <msg> -a <tag> <container_id> <image_name></td><td>容器打包成镜像</td></tr><tr><td></td><td><a href="https://docs.docker.com/engine/reference/commandline/push/">docker push</a></td><td>提交镜像到远端仓库</td></tr><tr><td></td><td><a href="https://docs.docker.com/engine/reference/commandline/inspect/">docker inspect</a></td><td>查看本地/远端镜像信息</td></tr><tr><td></td><td><a href="https://docs.docker.com/engine/reference/commandline/image_prune/">docker image prune</a></td><td>清理无用镜像(<strong>小心执行</strong>)</td></tr><tr><td></td><td><a href="https://docs.docker.com/engine/reference/commandline/save/">docker save</a> <image_name> &gt; image.tar</td><td>保存镜像到 tar</td></tr><tr><td></td><td><a href="https://docs.docker.com/engine/reference/commandline/load/">docker load</a> image.tar</td><td>从tar 包中还原镜像</td></tr><tr><td><strong>容器操作</strong></td><td>docker ps</td><td>查看容器列表</td></tr><tr><td></td><td><a href="https://docs.docker.com/engine/reference/run/">docker run</a></td><td>启动容器<br>docker run -p 3306:3306 –name mysql -e MYSQL_ROOT_PASSWORD=123456 -d mysql:5.7</td></tr><tr><td></td><td><a href="https://docs.docker.com/engine/reference/commandline/rm/">docker rm</a> <container_id></td><td>删除容器</td></tr><tr><td></td><td><a href="https://docs.docker.com/engine/reference/commandline/exec/">docker exec</a> -it <container_id> /bin/bash</td><td>进入容器</td></tr><tr><td></td><td><a href="https://docs.docker.com/engine/reference/commandline/container_prune/">docker container prune</a></td><td>清理未运行的容器</td></tr><tr><td></td><td><a href="https://docs.docker.com/engine/reference/commandline/logs/">docker logs</a> <container_id></td><td>查看容器/服务日志</td></tr><tr><td><strong>volume</strong></td><td><a href="https://docs.docker.com/engine/reference/commandline/volume_ls/">docker volume ls</a></td><td>查看所有 volume</td></tr><tr><td><strong>network</strong></td><td><a href="https://docs.docker.com/engine/reference/commandline/network_ls/">docker network ls</a></td><td>查看当前所有网络</td></tr><tr><td></td><td><a href="https://docs.docker.com/engine/reference/commandline/network_create/">docker network create</a></td><td>创建网络</td></tr><tr><td><strong>服务状态</strong></td><td><a href="https://docs.docker.com/engine/reference/commandline/stats/">docker stats</a></td><td>查看服务实时状态，每个容器的资源使用情况</td></tr><tr><td></td><td><a href="https://docs.docker.com/engine/reference/commandline/info/">docker info</a></td><td>查看 docker 安装版本信息、基本配置等</td></tr><tr><td></td><td><a href="https://docs.docker.com/engine/reference/commandline/system_df/">docker system df</a></td><td>拉取镜像<br>-v: 查看具体信息，比如每个容器的磁盘占用</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 开发工具 </category>
          
          <category> docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【翻译】mabataki 歌曲鉴赏</title>
      <link href="/2022/11/12/vaundy-mabataki/"/>
      <url>/2022/11/12/vaundy-mabataki/</url>
      
        <content type="html"><![CDATA[<h2 id="译者序言"><a href="#译者序言" class="headerlink" title="译者序言"></a>译者序言</h2><p>译者: Vaundy 作为日本乐坛强大的新生代力量之一，每首歌都有自己独特的曲风，今年同样有非常值得欣赏的几首音乐<br>这里特别是想评一下 mabataki 这首音乐，特别是在今年，在疫情，战争，世界经济下行等大背景下，这首确实有属于它独特的意义<br>这里将一篇日语的浅析文章翻译一下。日语能力有限，还请多多包涵~</p><p><a href="https://media.framu.world/columns/lyrics_consideration/mabataki-3">原文地址</a><br>原文标题: mabataki【Vaundy】歌詞の意味を考察！もし〇〇な世界だったら人は、優しくなれるのだろうか？<br>mabataki 歌词的意味考察！如果世界是〇〇样子的，生活在其中的人们能彼此温柔以待吗？</p><p><a href="https://twitter.com/Vaundy_AWS/status/1568254768111550464">新歌发布信息</a></p><p><a href="https://music.163.com/#/song?id=1980109662">歌词翻译参考-网易云</a></p><h2 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h2><p>这首是 9月9日 Vaundy 在武道馆举办的 one man live tour 演唱会中，在最后演奏的新曲<br>在演唱会中间，Vaundy 还宣布了将于 2023年11月 在5个城市举办10场大型公演的计划<br>大家对 「mabataki」 的歌词有什么样的感想呢？让我们一起看看吧</p><p><a href="https://www.youtube.com/watch?v=6h6AQbdTkaE">歌曲MV地址(油管)</a><br><a href="https://www.bilibili.com/video/BV1UP411J7wE">歌曲MV地址(B站)</a></p><h2 id="副歌部分（开头）"><a href="#副歌部分（开头）" class="headerlink" title="副歌部分（开头）"></a>副歌部分（开头）</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">もし何も</span><br><span class="line">忘れられない世界で</span><br><span class="line">出会い会ってしまったら</span><br><span class="line">憎み合うのはやめるだろうか</span><br><span class="line">もし何も</span><br><span class="line">覚えられない世界で</span><br><span class="line">すれ違ってしまったら</span><br><span class="line">振り向き合うようになるだろうか</span><br><span class="line">なんて</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">如果我们在无法忘却任何事情的世界中相遇</span><br><span class="line">也许我们都会放下彼此的憎恨吧</span><br><span class="line">如果我们在无法记起任何事情的世界中擦肩而过</span><br><span class="line">也许会为了彼此，互相奔赴转身的吧</span><br></pre></td></tr></table></figure><p>开头以主人公向自身发起提问的场景开始<br>如果这个世界能记住所有发生过的事情，我们能够放下那些和他人之间不愉快的回忆，抛弃对彼此的憎恨吗？<br>反过来，如果这个世界不再记得发生过的任何事情，我们能忘记来自过去的怨恨，让彼此的关系破镜重圆吗？<br>我仿佛听见了（歌曲）作者对世界是否能变得更加安稳和平的祈祷</p><p>当然在实际的世界中，我们还是会忘记一些事情，也会有一些一直记得的事情<br>但如果这个世界发生了极端的变化，（世界和我们自己）会变成什么样呢？<br>也许作者正是带着这种哲学性的疑问，才想着唱出了这首歌吧</p><p><img src="/2022/11/12/vaundy-mabataki/mabataki09.png" alt="MV画面"><sup><font color='#dfa0ee'><center>MV 开头场景</center></font></sup></p><h2 id="副歌部分1"><a href="#副歌部分1" class="headerlink" title="副歌部分1"></a>副歌部分1</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">どこにも見えない敵を今</span><br><span class="line">そこにあてがい</span><br><span class="line">人々は考えることをやめていた。</span><br><span class="line">薄れてく希望は</span><br><span class="line">徐々に蝕み</span><br><span class="line">弾倉の中に願いを込め始めた人々は</span><br><span class="line">また泣き出してしまう</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">一直以来看不见的敌人，如今也出现在了那里</span><br><span class="line">人们逐渐失去了思考，原本就微薄的希望，也慢慢地被侵蚀</span><br><span class="line">开始往弹夹中装入愿望的人们，不禁再次潸然泪下</span><br></pre></td></tr></table></figure><p>如果 什么事都会记得的世界，争端逐渐消失的话<br>如果 什么事都会被忘记的世界，温柔逐渐被孕育出来的话<br>我们当下生活在的现实世界，会变成什么样呢？是否会有所不同？</p><p>“どこにも見えない敵を今 そこにあてがい 人々は考えることをやめていた。”<br>这部分我感觉，作者是针对 当今社会中 一群在网络上 对别人随意恶语中伤、对世界形势冷漠不关心的社会现象，而提出的感想<br>本来这个世界应该是朝着争端更少、充满和平的方向发展的，但人们在面对真正最大的问题：那些看不见的“敌人”的时候，反而逃避了<br>渐渐变得淡薄的希望，渐渐被侵蚀和变得冷漠的人心，由此逐渐衍生出的各种争端、憎恨甚至战争。当我们回想到这些，可能会在某一时刻流下伤感的泪水吧<br>Vaundy 将那些试图通过战争解决争端的人们，形容成“开始在弹夹中寄托希望的人们”，真的是很厉害</p><p><img src="/2022/11/12/vaundy-mabataki/mabataki04.png" alt="MV画面"></p><h2 id="主歌部分2"><a href="#主歌部分2" class="headerlink" title="主歌部分2"></a>主歌部分2</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">足並みを揃え始めた</span><br><span class="line">疑いは罵倒となり</span><br><span class="line">人を食べた。</span><br><span class="line">薄れてく心は</span><br><span class="line">徐々に蝕み</span><br><span class="line">透明な刃に嫉みを込め始めた人々は</span><br><span class="line">まだ泣き止まずにいる</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">我们终于开始变得步伐一致</span><br><span class="line">但彼此的怀疑依然变成了谩骂，吞没了人们</span><br><span class="line">逐渐变得淡薄的内心，也慢慢被侵蚀</span><br><span class="line">开始把嫉妒化作透明的刀刃的人们，无法停下失声哭泣</span><br></pre></td></tr></table></figure><p>终于开始收拢相同步伐的我们，内心还是无法放下微小的猜忌，任由它发酵，最后变成了在现实中的争端</p><p>从古代就在不断发生的人类之间的冲突，在21世纪的当下依然在继续，有一种让人失望和悲伤的感觉</p><p>“<strong>人を食べた</strong>”这句歌词，（通过夸张）表现出了一种战争的失败方被胜方吸收掉的假想，很好地表现出了当今的世界形势（规则）</p><p>“<strong>薄れてく心は 徐々に蝕み 透明な刃に嫉みを込め始めた人々は まだ泣き止まずにいる</strong>”</p><p>透明的刀刃，也许说的是人们（无意中）伤害他人的话语<br>现代社会，谁都可以在网上发表评论，因为看不到他人的面孔（不知道别人听到你的话到底会怎么样），很多人都没有带着平静的心情，就开始在网络上表现情绪，随意宣泄自己的不满<br>不管是在现实还是在虚拟世界中的冲突，都是由于人类空虚的内心产生的，不禁让人感到一丝丝伤感</p><p><img src="/2022/11/12/vaundy-mabataki/mabataki06.png" alt="MV画面"></p><h2 id="过渡部分"><a href="#过渡部分" class="headerlink" title="过渡部分"></a>过渡部分</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">纏う悲しみが今</span><br><span class="line">また人を傷つけてしまう</span><br><span class="line">もう僕が先に銃を捨てよう</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">缠绕在人们内心的悲伤</span><br><span class="line">如今再次对大家造成痛楚</span><br><span class="line">那么我就先把手上的枪先丢在地上吧</span><br></pre></td></tr></table></figure><p>之前缠绕在人们内心的伤感、承受失败的感情，继续传染给了周围的人们，所有人都笼罩在一种消极的气氛中</p><p>我们应该怎么走出这种地狱般的负面情绪的循环呢？</p><p>在重复的合唱副歌部分，<strong>作者通过不断的自问自答的方式</strong>，逐渐在内心下定觉悟: 首先把自己心中的枪放下</p><p>把枪放下后，也许会被无声的语言攻击，会被看不见的刀刃弄伤</p><p>但如果不放下我们心中那把为了自卫装上的枪，也许也不能够把内心真正的想法 传达出来，作者想得到的结论也许正是这个吧</p><p>这几句歌词，读出了主人公内心坚定的决意</p><p><img src="/2022/11/12/vaundy-mabataki/mabataki10.jpeg" alt="MV画面"></p><h2 id="副歌部分2"><a href="#副歌部分2" class="headerlink" title="副歌部分2"></a>副歌部分2</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">もし誰も</span><br><span class="line">見つめ合えない世界で</span><br><span class="line">出会い会ってしまったら</span><br><span class="line">手を握って話すだろうか</span><br><span class="line">もし僕ら</span><br><span class="line">明日が最後としたら</span><br><span class="line">憎み合うのはやめるだろうか</span><br><span class="line">思い合うようになるだろうか</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">如果我们在一个无法好好对视的世界相遇的话</span><br><span class="line">也许会握紧彼此的手好好说话的吧</span><br><span class="line">如果明天是世界终焉之日的话</span><br><span class="line">也许我们都会放下心中憎恨的吧</span><br><span class="line">会开始想念彼此的吧</span><br></pre></td></tr></table></figure><p>这也许是一种讽刺的表现吧？<br>在一个无法认真对视的世界中相遇的话，我们能好好握住彼此的手交谈吗？不，也许根本不能<br>但我们实际生活着的世界中，是可以好好和别人面对面交谈的。因此好好坐下来，真诚地握住对方的手，注视对方认真交谈的话，也许就不会产生这么多无谓的争执了</p><p>如果明天就是世界终焉之日，我们彼此之间的憎恨也会消失的吧？<br>正因为谁都无法知道，什么时候会走到人生结束那一天，对我们来说，不如停止憎恨，互相体谅对方，以这种方式生活下去，也许也是可以的吧？</p><p>感觉到了作者对向着<strong>构建和平世界</strong>（或未来）而一起努力的呼吁</p><p><img src="/2022/11/12/vaundy-mabataki/mabataki07.png" alt="MV画面"></p><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>大家感觉怎么样？<br>感觉这真的是 Vaundy 对和平愿望表达深切，非常棒的曲子了<br>明年在 演唱会 tour 中他会以怎样的姿态在我们面前展示呢？就让我们一起期待吧～</p><p><img src="/2022/11/12/vaundy-mabataki/mabataki11.png" alt="开头"></p><h2 id="部分生词"><a href="#部分生词" class="headerlink" title="部分生词"></a>部分生词</h2><p><a href="https://www.weblio.jp/">词语解析来源: weblio 辞書</a></p><p><strong>弾倉</strong><br>連発銃で、補充用の弾丸をこめる部分。</p><p><strong>足並み</strong><br>1 複数の人や馬の足の運びのそろいぐあい。歩調。<br>2 考え方や行動のそろいぐあい。<br>3（「に」を伴って副詞的に）一歩進むごとに。</p><p><strong>嫉み</strong><br>自分と他人を比べ、他人の優れた部分を羨み、憎く思うこと。似たような意味の「妬み」が、相手に対しての憎しみが強いのに対し、相手が優れていることに対して劣等感を抱くという意味合いが強い。</p><p><strong>仮定</strong><br>1 未定のこと、不確かなことを仮にこうと定めること。また、仮に定めた事柄。<br>2 論理学などで、ある命題を導き出す推論の出発点におかれる前提条件。仮設。</p><p><strong>伝染</strong><br>1 病原体が他の生物体に入り、増殖して病気になること。感染。「はしかが―する」<br>2 物事の状態・傾向などが他に移って同じような状態が起こること。「あくびが―する」</p><h2 id="一点点感受"><a href="#一点点感受" class="headerlink" title="一点点感受"></a>一点点感受</h2><p>最后想说说翻译之后的感想:<br>翻译文章最难的部分真的不是去查询、记住生词，而是在<strong>外语和母语之间表达模式的切换</strong>。就这篇文章来说，我觉得我并没有很好地把作者的语气表达出来，可能是日语的<strong>语境</strong>和中文之间差别还是比较大</p><p>举个例子：日语经常在一句话结尾带上疑问语气，但更多地想表达的意思其实是肯定。带上疑问只是语言习惯而已，比如这句：<br>“<strong>これは、反語的な表現なのではないでしょうか？</strong>”<br>其实已经肯定形势: “这是讽刺的表现形式” 的意思了，<strong>でしょう</strong> 只是希望引起读者的共鸣，并不表示疑问</p><p>而这种东西，翻译软件是不会教你的，只能后面翻译更多的文章，多去理解</p>]]></content>
      
      
      <categories>
          
          <category> 音乐 </category>
          
          <category> Vaundy </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 音乐 </tag>
            
            <tag> 日语 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【翻译】软件工程师的通用技巧</title>
      <link href="/2022/10/31/software-soft-parts/"/>
      <url>/2022/10/31/software-soft-parts/</url>
      
        <content type="html"><![CDATA[<p><a href="https://addyosmani.com/blog/software-engineering-soft-parts">原文地址</a><br><a href="https://blog.csdn.net/xiaoliizi/article/details/127677921">本文csdn地址</a><br><a href="https://mp.weixin.qq.com/s/jfpXGMENp_kjhBycmRayew">本文公众号地址</a></p><h2 id="关于本文"><a href="#关于本文" class="headerlink" title="关于本文"></a>关于本文</h2><p>作者以10年在谷歌的开发经验，总结出了一套通用的方法论。译者这里对文章进行粗略的翻译，希望能对从事软件行业的同学有一定帮助，引起大家对平时所做、所看和所学的思考</p><ul><li>注1: 本文保留原文的章节架构，为易于理解，再对内容做适当的筛减和补充，偶尔扩展译者从自身经验角度的理解</li><li>注2: 原文很长，章节也比较多。建议大家分批次阅读，每次读两三个点，偶尔记下自己的思考，这样读起来不会这么枯燥</li><li>注3: 翻译和技术水平都有限，不一定能把作者的原意传达非常到位。因此建议有余力的同学去品一品原文，当然如果你读了我的翻译能有点共鸣，那也算是我的荣幸</li></ul><h2 id="作者介绍"><a href="#作者介绍" class="headerlink" title="作者介绍"></a>作者介绍</h2><p><strong>Addy Osmani</strong><sup><font color='#49E844'>[1]</font></sup> 是一位 爱尔兰籍 软件工程师和领导，目前在谷歌浏览器团队工作。他已经在谷歌工作10年，致力于让网页（访问速度）更快。他还曾在 AOL（America Online，美国在线） 和 Fortune 500（500强） 站点工作。 Addy 还是 《Learning JavaScript Design Patterns》、《Learning Patterns》和 《Image Optimization》等书籍的作者</p><p>作者博客首页<sup><font color='#49E844'>[2]</font></sup></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>今天我将会介绍软件工程中，关于 <strong>通用技巧</strong><sup><font color='#49E844'>[3]</font></sup>（soft skills）的部分。这些技巧是我在谷歌浏览器的前10年学到的，在这里我还成为了高级工程师。在工作10周年纪念之际，我想回忆一些一直伴随自己的课程，也希望这些技巧对读者的职业发展有所帮助</p><p>成为一名优秀工程师的过程是不断积累经验的过程。每个项目，不管多大多小，都是你学习技术、丰富自己工具箱的好机会。随着不断积累，当你能够把 从一个项目中学到的技能包，应用在另一个项目 去解决问题的时候，将会有事半功倍的效果</p><p>还需要说明：我说的话可能都不重要，一切以你的理解为准（YMMV）:)</p><h2 id="所有章节一览"><a href="#所有章节一览" class="headerlink" title="所有章节一览"></a>所有章节一览</h2><ul><li>精通</li><li>批判性思考，提出关键因素</li><li>巩固基础知识</li><li>通用知识点</li><li>效率</li><li>做出更好的选择</li><li>专注于用户（需求），其他事情会跟着走</li><li>提升自己的能力</li><li>利用参与新项目的优势，学习新技术</li><li>保持好奇心，保持学习</li><li>经常做笔记</li><li>Leader承认自己不知道的方面，将会很有感染力</li><li>Leader 也需要承认自己犯的错误</li><li>做开源项目的caretaker（管理者），而不是owner（所有人）</li><li>技术的广度和宽度</li><li>从实践中学习</li><li>通用代码 vs 专用代码</li><li>Deep module (模块化) 思想</li><li>学会管理一个项目</li><li>从新项目（green-field）中学习</li><li>定义完成事项</li><li>分阶段发布</li><li>系统性调试</li><li>设计文档的重要性</li><li>文档审查</li><li>定义你的沟通方式</li><li>耐心、深思熟虑</li><li>学会说“不”</li><li>接受与尊重</li><li>信息分享</li><li>灵活性</li><li>保持记录</li><li>真诚</li><li>资历和战略思维</li><li>以身作则</li><li>提升你的影响力</li><li>“不能胜任”综合症</li><li>指导他人</li><li>面向领域层面进行指导</li><li>组织层面的指导</li><li>学员的职责</li><li>构建信任</li><li>理解业务模型</li><li>提升你的影响力</li><li>时间管理</li><li>过度工作并不是好的工作素养</li><li>不断尝试超越自己的标准是不现实的</li><li>你不需要知道每一件时事</li><li>通过学会说不、了解什么时候该停下来、以及规划好自己的时间（包括工作间隙的休息），主动把自己从焦虑中解放出来</li><li>鼓励你和你的团队成员进行休息、旅游和调休</li><li>随着对问题的了解深入，更新（排期）评估</li><li>有时取消项目是正确的选择（即便是让人感到不舒服）</li><li>关于技术债：预防远远 &gt; 补救</li><li>如果没有充足的休息，和 work-life balance（的习惯），你的团队将会产生职业倦怠</li><li>大型组织/公司中流程会比较缓慢</li><li>专注于 问题 VS 专注于 项目</li></ul><h2 id="学习新知识"><a href="#学习新知识" class="headerlink" title="学习新知识"></a>学习新知识</h2><p>这部分内容能帮助大部分初级和中级工程师 成长，结合软件行业的基本流程和业界的最佳实践，构建复杂系统。尽量跟随业界的<strong>第一原则</strong><sup><font color='#49E844'>[4]</font></sup>。比如将大问题拆解成一个个小问题，就是你职业生涯中非常重要的技能之一</p><h3 id="精通"><a href="#精通" class="headerlink" title="精通"></a>精通</h3><p>对技术的精通，能帮你在工作时间产生更多的价值</p><p>你可以发现产生价值的工作点，并帮助你的团队将精力放到这件事情上来。同时，也能避免时间花在产出低效的事情上，<strong>优秀的工程师甚至可以带领团队从低效事情中解放出来</strong>，把工作放在最有价值的事情上</p><p>作者经常被（请教）问到：“如何知道我在充分使用自己的时间？”。你可能总是会有 能让自己变忙的各种任务，但真正的诀窍是确保你所做的是“对的事情”。如果你想移动整座山，那么你应该关注如何移动土堆，即使移动很小（即：愚公移山）</p><p>一些你可以经常问自己的问题:</p><ul><li>我的目标是什么？我所做的事情是否都是为了目标服务？</li><li>是否有其他途径 能更快地实现目标？ </li></ul><p>即使是自己对自己问这些问题，也能够很有作用</p><h3 id="批判性思考，提出关键因素"><a href="#批判性思考，提出关键因素" class="headerlink" title="批判性思考，提出关键因素"></a>批判性思考，提出关键因素</h3><blockquote><p>批判性思考是利用足够的认知，进行独立思考，并做出成熟决策的一种技能</p></blockquote><p>有时为了快速响应用户，我们可能会急于用一些快捷方案去解决用户问题。这样看起来会进展很快，但如果对结果和问题原因欠考虑，可能会引起后续出现问题的风险<br>与之相对，批判性思考就是带着强目的性去思考，发现问题的本质，规避风险<br>这种带着目的思考的方式，能帮助你更关注到问题的本质，规避那些 因为没仔细分析 根因和结果 而在未来会导致的问题</p><p>概括来说，以批判性角度，我会给自己提的问题有：</p><ul><li>我们是否在解决真正的问题？（问题是什么）</li><li>我们是否在用正确的方式解决问题？（可以从平衡严谨性和效率出发，比如时间不太够的时候，是否可以用更快的方式解决，一般适用于故障解决）</li><li>如果暂时找不到问题根源所在，如何找到定位根因的主要思路？（排除法是个不错的选择）</li><li>如何把核心问题拆解成一个个可以快速分析的问题？</li><li>如果我们有多种解决问题的假设，如何组织工作评估他们？</li><li>如果分析问题的时间有限，但是又不宜影响分析问题的严谨性，可以用什么捷径？（参考社区经验）</li><li>得到的结论，是否有充分的证据和现象能够支撑？（需要过程）</li><li>怎么知道把事情做完了？解决方案足够好吗？（适当回顾，确保不会有新的问题出现）</li><li>怎么把解决方案解释给故障影响方？（一般用于故障回顾，将故障具体原因、具体解决方式提炼出概括性的技术说明，保证对方能理解，并认可方案）</li></ul><p>这些问题经常能起到帮助作用。有时我们还会遇到这种情况：定位一个问题，结果从表象深入后发现了更多问题；采用一些可以快速解决问题的方案，但是在系统运行一段时间后，发现又因此产生了新的问题<br>通过进行一段时间的批判性思考，我们不断挑战假设，对收益和风险看得更细致，找到现象之间的矛盾点，评估（现象的）可信度，收集更多的数据，以确保我们现在做的是对的事</p><p>举个例子，很多程序员常犯的错误是，误将一个关联关系当成是因果关系（两个事情关联，但并不是说其中一件事发生，就一定会导致另一件事）。一个具备批判思维的人能将思路放回到假设中，并抛出问题：为什么我们会认定这个假设是对的？<br>这种（带批判性思考的）人还会做的事情有：</p><ul><li>提出更具体的问题（比如解析一个大需求：优化接口查询性能，可以拆解成，参数怎么优化，数据层过滤条件怎么优化等）</li><li>查询更多资料，寻找和问题之间的关联性（很适合初学者，资料总是不嫌多）</li><li>得到合理的结论和解决方式后，按照相关标准和规范进行测试（突出复现和测试）</li><li>通过不同的思维方式进行思考，对假设、影响和结果再次评估（形成适用于其他问题解决的方法论）</li><li>面对复杂问题，高效交流，找到最终解决方式（面对有复杂上下游的服务）</li></ul><p>扩展阅读: 批判性思考是通用技能吗？ <sup><font color='#49E844'>[5]</font></sup></p><h3 id="巩固基础知识"><a href="#巩固基础知识" class="headerlink" title="巩固基础知识"></a>巩固基础知识</h3><blockquote><p>牢固你的基础知识，并通过不断（在工作中）使用它们，来掌握新技能</p></blockquote><p>从长远角度来看，基础知识长期不变，学到了就能用很久，而且很通用，你在一个领域学到的基础知识在其他领域也用得上</p><p>短期来看，基础知识能让你面对问题时，提出更好的解决方案，并让自己的代码更加高效</p><h3 id="通用知识点"><a href="#通用知识点" class="headerlink" title="通用知识点"></a>通用知识点</h3><blockquote><p>通用知识是那些可以在不同项目之间都能使用的知识点。让我们从它们和基础知识之间的关系开始说起</p></blockquote><p>基础知识是贯穿整个软件工程师职业生涯的基础。它可以分为两层：宏观和微观。宏观层面是软件工程师的核心（<strong>基础知识</strong>），微观层面是实现（如：<strong>技术栈、库、框架</strong>等）</p><p>在宏观层面，你能够学到编程相关，高度抽象、和语言无关的概念。它们在各个领域的描述可能不同，但背后的核心思想都是一致的。包括：<strong>数据结构</strong>（数组、对象、模块、hash）、<strong>算法</strong>（排序、查询）、<strong>架构</strong>（设计模式、状态机）、<strong>性能调优</strong>（及早求值和惰性求值、内存、缓存、懒加载）等。这些概念你会在工作中经常用到，了解它们背后的原理将很有意义</p><p>在微观层面，你能够学到宏观概念的具体实现。包括：<strong>编程语言</strong>（JS、python、ruby）、<strong>前端框架</strong>（react、angular、vue）、<strong>后端框架</strong>（django、rails）和<strong>应用技术栈</strong>（谷歌 app engine、谷歌云平台）等。它们会涉及到很多能帮助你学到专业知识的细节，能让你变得高效， 但并不总是那么通用</p><blockquote><p>通过学习基础知识，你能够收获技能包和工具包，让你（在之后）可以忽略技术实现细节并成长</p></blockquote><p>务实地说，没有人可以在职业初期就学到所有东西。由此再延伸出一个观点：你不应该过多关注基础知识，反而应该学习在现实中搭建项目时需要用到的知识/技能。这也是“<strong>在实践中学习</strong>”理念的来源</p><p>译者：宏观知识帮助你了解技术原理，微观知识帮你把技术具体实现出来。不管是哪一种知识，都需要我们 learning by  doing 边做边学，都是需要过程的<br>不能太过神化宏观知识的重要性（比如各种面试八股文），它容易让你陷入底层，脱离工程<br>实际情况中，工程相关技能（即微观知识）更重要，毕竟这些才是能在当下帮你赚钱，帮公司赚钱的技能<br>​不管怎样，两种技术最终还是相互依存的。谁都很重要，谁也离不开谁</p><h3 id="效率"><a href="#效率" class="headerlink" title="效率"></a>效率</h3><p>理解服务的架构，能帮助你写出更高效的代码，这包括 <strong>时间复杂度</strong>（运行代码的时间）、<strong>内存使用率</strong>、以及<strong>性能和可维护性之间的平衡</strong><br>这些考虑点能让你在构建稳定的大型应用的时候，做出有用的权衡。另外对现代应用程序来说，<strong>速度</strong>非常关键，通常能特别显著地影响用户体验</p><h3 id="做出更好的选择"><a href="#做出更好的选择" class="headerlink" title="做出更好的选择"></a>做出更好的选择</h3><blockquote><p>对宏观和微观基本知识有更好的认识，能帮助你做出更优的决定</p></blockquote><p>基于项目的目标和约束，以及你所学的知识，你能够在选择<strong>应该用什么技术、不应该用什么技术</strong>这两个问题上做出更好的决策，避免在工作中因为选择了错误的技术方向或工具，导致陷入陷阱中</p><p>“You haven’t mastered a tool until you understand when it should not be used.” -<br>“<strong>你永远没有真正掌握一个工具，直到你知道什么时候不应该用它</strong>”<br>@kelseyhightower（谷歌云平台部门谷歌的首席工程师和首席员工倡导者）</p><p>软件工程师思考问题时需要考虑很多方面：<strong>核心语言、实现、架构、工具和人</strong>。只有在你带着<strong>敬畏之心</strong>，去认真学习这些方面的知识，才能让你更快成长。真正了解基础知识（包括 O(n) 时间复杂度（的算法））能帮助你走得更远，特别是在语言和框架（的具体实现）随着时间不断变化的背景下</p><p>扩展阅读:<br>The value of fundamentals in Software Engineering<sup><font color='#49E844'>[6]</font></sup></p><p>Why learning the fundamentals matters<sup><font color='#49E844'>[7]</font></sup></p><p>Learn the fundamentals of a good developer mindset in 15 minutes<sup><font color='#49E844'>[8]</font></sup></p><h3 id="专注于用户（需求），其他事情会跟着走"><a href="#专注于用户（需求），其他事情会跟着走" class="headerlink" title="专注于用户（需求），其他事情会跟着走"></a>专注于用户（需求），其他事情会跟着走</h3><blockquote><p>从用户体验开始，实现时回归你需要用到的技术</p></blockquote><p>乔布斯说过：”you’ve got to start with the customer experience and work backward to the technology. You can’t start with the technology then try to figure out where to sell it.”<br>“你需要从用户体验开始，再回归到技术中。你不能先基于（选择）技术，再尝试去找到哪里可以卖出你的产品”</p><p>这句话深深地触动了我：作为工程师，我们很容易就会有这种思维：先找方案，不管是社区流行的技术、其他开发者的经验，还是个人喜好，找到方案之后再去找哪里用得上<br>相反，我们其实更应该专注于我们所服务的对象、需要解决什么样的问题，以及当前的方案有什么不足之处<br>好的用户体验来自 <strong>用户和技术</strong> 两个角度的结合。和用户沟通，表达你的观点，你认为他们有什么需求，并认真分析他们说的需求。在用户需求实现上，会有很多细节能导致巨大差别，比如选择什么样的服务架构，能在用户手机端有比较好的体验；以及什么因素会影响工程开发、规模扩展、招聘等的效率？<br>总结来说，坚持不懈地关注用户需求，在工作条件限制下，<strong>坚持以实现用户需求为导向</strong>，能够让我们长期受益</p><blockquote><p>最优秀的软件，是由 带着用户同理心的工程师开发出来的</p></blockquote><p>软件能成功，取决于用户满意度，而满意度又体现在用户使用软件的体验上。我们需要了解<strong>最终用户侧</strong>的体验；确保我们的方案不会影响用户使用产品的同时，完成他们自己的工作<br>如果你有渠道可以和终端用户直接交流，就尝试去理解他们的需求和痛点吧</p><p>译者：理解用户需求并不简单，现实中总会遇到各种问题，译者经历过的主要有：</p><ul><li>和用户的沟通渠道不通畅<ul><li>大部分是平台问题导致的，比如产品首页缺少反馈按钮，用户想反馈问题只能靠投诉（想到了之前遇到的一个产品，想反馈一个bug，甚至要跳转另一个平台才能提，体验极差）</li></ul></li><li>用户需求和产品规划矛盾<ul><li>大部分用户需求都是站在短期实现的基础上的，和产品的长期规划不一定吻合。比如我想做一个笔记软件，长期来看，体验便捷 和 云端同步 可能是我首先考虑的功能点。对于 画图、共享这种功能，可能就不会排在很高优先级。但如果用户又站在强势地位，要求开发优先实现额外的需求，那开发就要受累了。后面可能就会能看到 产品、开发和测试 天天battle，需求赶着时间做出来，质量很差，转测的时候测试又提一堆bug，开发迫不得已边改bug 边开发，陷入恶性循环中</li></ul></li><li>用户也不清楚真实需求<ul><li>产品发展初期容易出现。用户对产品没有特别具体的认识，需要产品经理和用户进行更多的沟通，去发掘需求</li></ul></li></ul><h3 id="提升自己的能力"><a href="#提升自己的能力" class="headerlink" title="提升自己的能力"></a>提升自己的能力</h3><blockquote><p>选择适用于你的场景的技术，而不是当下流行的（flavor of the month）</p></blockquote><p>对比两种观点：使用“无聊”的技术（经过充分测试和体验的）也是ok的 VS  跟上潮流技术</p><p>语言、框架和库 都在经常发展。选择能帮助你顺利交付最终产品的就好。开始一个新项目时，建议从“无聊”的技术（<strong>但非常了解</strong>）开始，然后基于这个技术，有意选出最好的工具来帮你解决问题</p><p>即使是选择了新的技术来学习和使用，也不要害怕选择一些看上去无聊、不属于“社区”上主流的方向。FOMO<sup><font color='#49E844'>[9]</font></sup>（Fear of missing out 错失恐惧症）面对 语言、框架、库 和 工具这些技术的时候，可能就不是很有效了，因为更重要的事情是为了交付优秀的最终产品，你需要对自己所用的东西更加了解。请不要盲目为了追求新颖、漂亮的技术，除非你确定它们能为你的方案添砖加瓦。当然，也不要因为某个事情还没有被讨论充分，而忌讳提到它</p><h3 id="利用参与新项目的优势，学习新技术"><a href="#利用参与新项目的优势，学习新技术" class="headerlink" title="利用参与新项目的优势，学习新技术"></a>利用参与新项目的优势，学习新技术</h3><p>了解 <strong>个人开源项目和黑客项目</strong> 是学习新技术的好契机<br>对我们大部分人而言，基于现有项目是很难了解到新技术的，因为技术选型已经基本定型了<br>刚提到的两种项目，能让你以低风险、低成本方式研究新技术，了解新技术的优势和不足，以及了解可能在未来对你有用的一手知识</p><p>译者：另外，对初学者而言，还是要有对做什么项目的期望和思考，<strong>先有对项目的初步设想，再去找实现思路（如社区demo）</strong>。想法也不一定要很具体，有一个大体想法也可以，比如想做一个自定义规则的天气预报，想写一个小程序等<br>不是盲目找一个看起来很火的开源项目，随便搭起来就好了。因为并不是每个项目都适合你，越是花里胡哨的项目，越难应用于实际。<strong>带目的性的去找开源项目就是最好的甄别方法</strong><br>再提一点自己的感受：当有一个新技术摆在你面前时，<strong>学习它的最好时候永远是现在</strong>。错过了现在，你后面就可能花费更多的时间精力去重新捡起来</p><h3 id="保持好奇心，保持学习"><a href="#保持好奇心，保持学习" class="headerlink" title="保持好奇心，保持学习"></a>保持好奇心，保持学习</h3><h3 id="经常做笔记"><a href="#经常做笔记" class="headerlink" title="经常做笔记"></a>经常做笔记</h3><p>写下所学的东西，能帮助你更好的理解知识点。有的时候只有你尝试把自己所了解的知识讲给别人听，才能真正把你不懂的点弄清楚<br>如果你写的东西（博客）没人看，那也没关系。<strong>做笔记主要还是为了自己</strong>，（只是记下）你已经从中收获很多了</p><p><strong>学习还应该是一个持续坚持的事</strong> – 那些号称自己对特定领域无所不知的人通常都不是真正的专家。真正的专家精通一些技术，但他们能够意识到，总会有（继续）学习和改进的地方。<strong>好奇心驱动学习</strong> - 所以如果你对一个新框架感兴趣，那就去谷歌它、阅读它的文档、尝试新手教程、以及阅读源码！学习并不只是出现在教室中，<strong>学习可以在任何地方、任何时候发生</strong>。每天花半个小时阅读一本书的一小章节，听一次技术广播，阅读技术博客，学一门新的编程语言等</p><h3 id="Leader承认自己不知道的方面，将会很有感染力"><a href="#Leader承认自己不知道的方面，将会很有感染力" class="headerlink" title="Leader承认自己不知道的方面，将会很有感染力"></a>Leader承认自己不知道的方面，将会很有感染力</h3><p>Leader 需要降低期望：<strong>即使是高级工程师，也没有了解方方面面的必要</strong>。承认自己对一些细节不了解的同时，并致力于找到 和 团队一起解决问题的方法（即合作），这个比了解技术细节更重要</p><h3 id="Leader-也需要承认自己犯的错误"><a href="#Leader-也需要承认自己犯的错误" class="headerlink" title="Leader 也需要承认自己犯的错误"></a>Leader 也需要承认自己犯的错误</h3><p>教导下属 用虚心的态度承认和解决错误，愿意从错误中学习和提升自己，是很重要的。告诉下属现实世界并不完美，我们需要对可能发生的错误做好准备</p><p>译者： 理想状况下，我们提供的服务还是应该具备<strong>高可用、故障后可快速恢复</strong>的能力。这样就算是一个刚接手服务的同事，也能有快速上手的<strong>自信</strong>。遇到问题也能冷静处理<br>当然，不得不说，基础设施、服务维护工具和服务架构设计等，也是达到这种理想程度的基本条件。做到如上所述完全理想的情况不是不可能，只是确实有难度<br>如果你所维护的服务正好没有做到上面几点，那就根本别指望不会出问题，更别指望能不被用户投诉、领导责备了。不过这个时候，也只能想办法去<strong>尽量改变现状。每次犯错都去责备团队或者责备自己，对现状不会有任何改进</strong></p><h3 id="做开源项目的caretaker（管理者），而不是owner（所有人）"><a href="#做开源项目的caretaker（管理者），而不是owner（所有人）" class="headerlink" title="做开源项目的caretaker（管理者），而不是owner（所有人）"></a>做开源项目的caretaker（管理者），而不是owner（所有人）</h3><p>在项目发展的初期，以 owner 的角度去思考是没问题的。你会经常去思考项目的价值，开发新特性和回复 issue。对为项目争取社区支持、赞助是好事，但随着项目人员的变化，以及个人时间受限，这种模式对项目的发展就不是最好的了</p><p>经过初期的项目规模收缩之后，另一种参与项目的方式是成为项目的<strong>管理人</strong>，而不是<strong>所有人</strong>。管理人的角色更专注于扩大自身的影响力。比如和其他项目所有人、贡献者和社区之间 分享知识（通过文档、代码注释、最佳实践文档化等）。这对扩大项目的 reviewer 规模同样有用，有助于后续不再参与项目的时候，项目也能朝着正确方向发展</p><h3 id="技术的广度和宽度"><a href="#技术的广度和宽度" class="headerlink" title="技术的广度和宽度"></a>技术的广度和宽度</h3><blockquote><p>考虑成为一个全才和某一领域的大师，哪一个更适合你？</p></blockquote><p>你应该掌握的一个很重要的技能，就是掌握 如何学习 的方法。这比你怎么说更重要，（你需要做的）只是深入到编程语言或者框架的底层。另外这也有助于保持好奇心。一旦你经历了这种学习方式，你可能就会提出刚刚说的问题：是追求成为某个领域的专才，还是全栈的多面手（a jack of all trades）<br>我个人更喜欢成为 <strong>T型工程师</strong><sup><font color='#49E844'>[10]</font></sup>（T-Shaped Team Members） 的想法。这种工程师会在一个或少数几个领域有深入研究（<strong>T 的纵向深度</strong>），但对构建和运行大型项目需要的多个领域的技术，也有基本的认识（<strong>横向宽度</strong>）。有的团队会愿意将团队成员定期相互交换，来培养这种 T型工程师<br>我已经发现在中-大型团队中，如果有那种在某一领域专长的人员，能够很有效地补充其他人的技能、全面性和合作能力</p><p>译者：<strong>初学者还是建议以技术宽度为主</strong>。宽度能帮助你快速定位和解决问题（<strong>打开思路、用好工具</strong>），然后能更专注于研究深度。因此确实不要放过任何一个能学到新东西的机会<br>而最理想的状态，就是在对大的领域，比如后台，所有热门技术栈都有实践性的认识，同时对1-2个领域有非常深的实战经验</p><h3 id="从实践中学习"><a href="#从实践中学习" class="headerlink" title="从实践中学习"></a>从实践中学习</h3><p>学习一门新语言的时候，需要专注于构建有形的结果，能让你有更深刻的一手体验<br>不一定要完整阅读新语言的官方文档，记住所有的特性、关键词。<strong>了解这门语言如何解决问题</strong>更重要。从demo项目中，或者亲手写代码来获得经验。正如《Why Bad Software Happens to Good People》<sup><font color='#49E844'>[11]</font></sup>这里所说，“软件的主要价值并不是产生的代码，而是创造这个语言的人传递的知识本身”<br>也要注意：不要在生产环境进行新技术的试验</p><h2 id="技术复杂度"><a href="#技术复杂度" class="headerlink" title="技术复杂度"></a>技术复杂度</h2><h3 id="通用代码-vs-专用代码"><a href="#通用代码-vs-专用代码" class="headerlink" title="通用代码 vs 专用代码"></a>通用代码 vs 专用代码</h3><blockquote><p>解决手头问题的时候写专用代码，但也尝试能让代码变得更通用的地方</p></blockquote><p>当我们为了解决一个问题的时候，往往会因为紧急程度、升级复杂程度等，写出一些比较不那么通用，只是为了快速解决问题的“专用”代码。<br>通常，我们会先尝试写出尽可能通用的代码，最后写出那些看似高效的代码，但并不能解决问题。实际上，（应该）<strong>先是为了解决问题写代码，再去找到可以让代码变得更通用的地方</strong>，这样能在更迅速地解决问题的同时，减少后续再回顾和重构的时间（译者：解决手头问题的时候，短期效率还是排在第一位的）</p><p>关于设计复杂度上，有一些通用的原则：<br>YAGNI（You aren’t gonna need it）<sup><font color='#49E844'>[12]</font></sup>、Do the simplest thing that could possibly work<sup><font color='#49E844'>[13]</font></sup><br>这两点说的其实是一个事：<strong>不要过度设计</strong><sup><font color='#49E844'>[14]</font></sup>（overengineering）。尽量通过最简单的设计完成工作，让后续的需求通过快速迭代实现，而不是一开始就把所有特性都规划好。不过滥用这两个原则，也容易导致设计出过于抽象和简单的方案，后续不能很好地实现和集成</p><p>另一方面，你还会经常听到<strong>抽象原则</strong><sup><font color='#49E844'>[15]</font></sup>，旨在通过抽象和通用化思想，减少重复代码。我更喜欢在极端抽象和极端简单中找到平衡点，AHA<sup><font color='#49E844'>[16]</font></sup>（Avoid Hasty Abstractions）（避免过度抽象） 体现了这种思想</p><h3 id="Deep-Module-模块化-思想"><a href="#Deep-Module-模块化-思想" class="headerlink" title="Deep Module (模块化) 思想"></a>Deep Module (模块化) 思想</h3><blockquote><p>解决复杂问题，并通过开放清晰的接口给其他开发者使用</p></blockquote><p>如果你是一个API 的设计者或者开发者，你的职责就是提供能简化功能的接口。如果接口过于难懂，让其他程序员调用需要花费过多成本，那这个接口就是不合格的。这个理念同样能在 <strong>Deep Module</strong><sup><font color='#49E844'>[17]</font></sup> 的思想中体现：“最好的模块能够同时提供最好的效果和最低的成本。效果就是它的功能，成本就是它的接口”</p><p>尽管让接口变得简单是可行的，但代码不一定，复杂问题有时就是需要复杂的代码来实现（这是一个通用规则，但不一定总是正确）。复杂度最好是内嵌到代码中。复杂的功能抽象程度越高，作为接口提供给最终用户的价值就越高<br>API 使用越多的函数和类，就越难被搜索到。随着函数和类的新增，将会增加 程序员的维护和接口使用的成本</p><p>译者：接口设计规范也是老生常谈的规范了，这里简单提一下</p><ul><li>接口的入参不应超过3个<ul><li>接口入参 其实就能体现给用户调用这个接口的成本。参数越多，也意味着这个接口越复杂，甚至不是复杂在功能，而是理解成本</li></ul></li><li>用更少的类实现接口<ul><li>这里就涉及到模块架构的设计了，比如一个 http 接口，最普遍的分层方式就是 api 层 + controller + service + 数据层</li></ul></li><li>接口名称</li><li>接口返回值</li></ul><h3 id="学会管理项目"><a href="#学会管理项目" class="headerlink" title="学会管理项目"></a>学会管理项目</h3><blockquote><p>处理旧系统的代码时，应该理解需要保留的代码，和需要废弃的代码之间的区别</p></blockquote><p>大型、年久失修的项目往往会有一些不好的、没有好的理由再保留下去的代码。应该去深入了解这些代码，分析留下的理由、去除的理由。去除坏代码，留下好代码</p><p>我曾经在很多公司中遇到过这种情况：<strong>同事们认为旧的代码是不可动的</strong>，或者是出于一个好的理由设计的，导致这些代码流失于历史之中（译者：即没人敢动，也没人能动的状态）。这会产生对修改旧系统代码的畏惧感，只能在一个脆弱的基础上继续添加功能</p><p>软件行业已经发展到了一个阶段：<strong>很多团队都需要维护或者迁移 旧系统</strong>。当你发现自己就在这样的团队的时候，不要灰心，你可以从这些旧代码中学到很多特定领域的知识。尽管旧的代码在生产环境中继续保留 会有充分的理由，你还是可以怀疑不是每一行都有存在的价值</p><p>有的软件开发者会对修改在线上环境运行的代码很谨慎，担心会导致bug。所以他们会根据现有的系统的代码，通过重复代码来添加新功能（译者：比较典型的情况就是修改接口，对旧系统存在 bug 的接口不敢改，而是添加一个新的接口，但这个接口绝大部分代码都和旧接口一样）这种解决方式在当时会很省时，但随着时间推移，维护就会变成噩梦了。不要假设现有的代码都是可靠的，它们在可扩展性和效率上可能会有问题，你可以去尝试发现这些问题</p><h3 id="从新项目（green-field）中学习"><a href="#从新项目（green-field）中学习" class="headerlink" title="从新项目（green-field）中学习"></a>从新项目（green-field）中学习</h3><blockquote><p>实验、创新、快速失败和更好地解决问题</p></blockquote><p>当你的任务是从头开始搭建一个系统的时候，你的学习之旅就将很不同。在迭代制作原型、实现特性的时候，你将能学到什么能起到作用，什么不能<br><strong>敏捷方法论</strong> 和 <strong>快速失败</strong> <sup><font color='#49E844'>[18]</font></sup>（fail-fast）的原则，将帮助你通过很少的资源就能确认你的想法是否正确。它们能帮助你拆解并解决复杂问题</p><p>译者：敏捷开发这块，现在已经有很多开源的工具，可以帮助我们在本地实践。简单列几个：</p><ul><li>代码仓库：gitlab（需要使用体验）</li><li>发布：jenkins</li><li>镜像仓库：harbor</li><li>服务管理：k8s、istio、etcd等</li></ul><h3 id="定义完成事项"><a href="#定义完成事项" class="headerlink" title="定义完成事项"></a>定义完成事项</h3><blockquote><p>定义什么算是“完成”事项能节省时间，因为它能帮你评估所需要的工作、制定开发计划、并避免不必要的调整</p></blockquote><p>在解决复杂问题时，有效的敏捷原则是对 “完成”事项（The Definition of Done<sup><font color='#49E844'>[19]</font></sup>） 达成一致。除了用户需求列表和验收标准外，还包括代码审视（code-review）、测试、文档化等</p><p>译者：这里体现一种“<strong>闭环</strong>”思维：在手头事情很多，需要来回切换的时候，事情做得稍有疏忽很正常。因此需要特别注意 “完成” 事项的明确<br>比如刚给用户改完一个bug，在用户群回复用户、知会受影响方、提交fix代码，都是需要“闭环”的事情。可以先稍微花点时间先把它们写下来，避免忘记</p><h3 id="分阶段发布"><a href="#分阶段发布" class="headerlink" title="分阶段发布"></a>分阶段发布</h3><blockquote><p>单个大的版本可以拆解成一系列低风险、容易理解的小版本来发布</p></blockquote><p>在大型生产环境系统 进行 版本发布的时候，版本发布计划的重要性不亚于 架构、代码实现等。通过迭代开发、分阶段发布版本，能帮你更好地管控因重大更改而导致的风险。你还可以制定版本发布策略，包括开发、测试策略，来保证在发布复杂特性的时候，有（完整的）端到端计划</p><h3 id="系统性调试"><a href="#系统性调试" class="headerlink" title="系统性调试"></a>系统性调试</h3><blockquote><p>当你在 debug 的时候，你应该系统地、严谨地解决问题，确保覆盖到了所有的测试条件</p></blockquote><p><strong>总是阅读错误和堆栈信息</strong>。那里大概率会有关键信息，能帮你定位和解决问题<br>惊人的是，很多工程师在调试之前，都会忽略错误信息能提供的线索。我们应该假设 机器/软件能告诉你发生了什么问题，而不是假定 稍微做点修改、重启服务就能解决问题。如果你还没有仔细阅读程序抛出的异常，就开始写解决方案，你可能会浪费时间。大部分情况下，异常信息中就包含了真正错误的提示</p><h2 id="文档"><a href="#文档" class="headerlink" title="文档"></a>文档</h2><h3 id="设计文档的重要性"><a href="#设计文档的重要性" class="headerlink" title="设计文档的重要性"></a>设计文档的重要性</h3><blockquote><p>设计文档不应该放在后面来考虑，而应该是软件开发过程的一部分</p></blockquote><p>设计文档能帮助你和 <strong>同事</strong> 或者 <strong>其他需要和你的系统进行交互的团队</strong> 之间获得共识，是一个无处不在的工具。从他人获得的反馈，又可以让你认识到差距，并改进你的设计。设计文档还可以为后续加入团队的工程师提供宝贵的帮助，可以帮助他们理解问题，在设计解决方案的时候考虑到权衡点、替代方案等。设计文档也提供了一个团队空间，能够记录所有设计的参与者，以及它们的贡献，作为历史文档的一部分，以方便他人找到具体解决方案的贡献者，以及方案具体解释的负责人</p><p>译者：一个成熟的项目，团队空间中包括的文档应该包括而且不限于：</p><ul><li>项目 milestone</li><li>公司权限申请帮助文档</li><li>服务设计文档</li><li>服务环境、部署文档</li><li>内部服务和第三方服务的接口人</li></ul><h3 id="文档审查"><a href="#文档审查" class="headerlink" title="文档审查"></a>文档审查</h3><blockquote><p>协同检视设计文档，比较当前文档和历史文档，确保所有依赖项都被记录了</p></blockquote><p>尽管每个人都可以在文档中记录设计思路，但实际的设计过程通常出现在白板会议、随机面对面讨论、空闲时间段 或者 邮件/手机讨论（这种<strong>随时发生的场合</strong>）中。在这之后，只有通过文档把设计记录下来，你才能确认 结论之间的矛盾点，并确认（现在讨论的结论和）之前讨论过的点是否吻合。初稿完成后，需要进行审视，确保所有相关人员都参与进来。另外，随着项目发展，还是可能存在代码实现 和 文档中记录的设计思路 变得不吻合的情况（因此文档需要定期审查和更新）</p><h2 id="沟通"><a href="#沟通" class="headerlink" title="沟通"></a>沟通</h2><blockquote><p>谦虚、清晰沟通、并尊重他人。保持亲切 本身不计成本，它产生的影响却是无价的。有的人会认为 沟通需要消耗能量和思考。正是因为如此，我们需要以更多的能量和热情来和他人沟通</p></blockquote><p>沟通是一个非常关键的通用能力和社交能力。成为一位有用、高产、和高效（effective, productive, and efficient）的软件开发者也离不开（和他人）沟通。沟通不通畅会导致（开发出）不正确的功能、不兼容的代码、冲动的团队氛围等。沟通能帮助开发者更好地理解需求，避免问题继续升级<br>理想情况下，<strong>软件开发者是把（大部分）时间花在编写代码上的</strong>。但是为了保证我们的产品真正对用户有用，我们还需要和团队成员同步工作（进度）、业务需求和用户期望。这让协作和沟通成为我们工作很重要的一部分<br>初级工程师主要的沟通对象是 其他团队成员、测试工程师和项目leader，分享想法和解决问题的方案。随着我们职业发展，为了有效完成工作，需要的沟通量将会越来越多。邮件、会议和公开演讲也会变多。我们必须和 <strong>业务leader、项目经理、利益相关人员</strong>沟通。然而沟通越多，产生误解的风险也会越大，因为不是每个人都能轻松理解你的表达方式</p><h3 id="定义你的沟通方式"><a href="#定义你的沟通方式" class="headerlink" title="定义你的沟通方式"></a>定义你的沟通方式</h3><blockquote><p>和沟通对象 确定好 语言、概念 和 沟通细则的相关性</p></blockquote><p>不管我们对问题或者情况有多么理解，和别人沟通的时候，我们还是应该设计好沟通关键词，保证沟通对象能够快速get到 和自己相关的内容：</p><ul><li>和业务人员沟通的时候，谈论你所做的事情在业务层面的影响。避免使用过多的技术术语</li><li>和工程管理人员沟通的时候，说明技术影响和挑战</li><li>和决策者沟通的时候，描述你期望的可行方案，以及这些方案的影响和风险，不要谈到方案实现的细节</li><li>提供状态更新的时候，需要特别关注随着更新可能导致的周边影响，以及你的更新和目标之间的关联度</li></ul><p>这些原则 同样适用于写邮件和举行大型分享。你需要写下和沟通对象相关的事项。在分享的时候，还需要保卫你的观点，以深思熟虑的态度回复问题，膝跳反应（knee jeck）的回答方式通常不适用于沟通</p><h3 id="耐心、深思熟虑"><a href="#耐心、深思熟虑" class="headerlink" title="耐心、深思熟虑"></a>耐心、深思熟虑</h3><blockquote><p>亲切是一种超能力，尝试用好它</p></blockquote><p>成为冷静、亲切和乐于助人的人，能让你走得更远，而不是切断自己和其他人的联系。善于帮助团队内的同事，能帮助你的团队变得更强大和更成功。对团队外的成员也保持友善，对公司的职能部门同事（<strong>hr、财务、市场</strong>）也给予同样的尊重，（在工作上）你可能不会直接帮助到他们，但你可以理解他们的工作，对他们拥有同理心。当他们在工作上有所成就，或者获得赞誉的时候，也同样送上你的祝贺和赞赏。善良是能传递下去的，那些你曾经善待的同事，在未来可能也会积极回应你的需求</p><blockquote><p>不要吝啬（be liberal）称赞他人</p></blockquote><p>产品需要改进的时候，（问题的）反馈很重要。产品体验很优秀的时候，正面的反馈同样很重要。这能帮助你的团队（成员）明白 正在做的事情是能带来改变，并且是有价值的</p><h3 id="学会说“不”"><a href="#学会说“不”" class="headerlink" title="学会说“不”"></a>学会说“不”</h3><blockquote><p>说“不”比工作过度要更好</p></blockquote><p>很多时候在工作逐渐累积的时候，我们都不是很擅长说“不”。要么是因为没有意识到<strong>说“不”其实是一种选项</strong>，要么是我们沉迷于挑战之中。但是过度工作是一种负担，它可能会导致交付延迟。让其他人也知道你正在进行的计划，以及一个合理的时间预估，也是一种尊重的态度。因为这能够让其他人调整他们的选项：向其他人寻求帮助，或者推迟时间表。如果 leader 能了解到（过度工作）会明显影响产品交付质量，他们也不会强行要求你在很紧的时间内完成工作。如果你是高级经理，请让你的团队成员有权利对坏主意说“不”<br>高级工程师是很擅长于说“不”的。人们会试图占用你的空闲时间。你可以平静而又坚定地说不，将他们指向其他思路，或者让他们找你主管，确认你到底是否可以将更多的时间，花在帮助他们身上（而不是手头的事情）” - 观点来源<sup><font color='#49E844'>[20]</font></sup></p><blockquote><p>你不可能让所有人感到满意：不管是说 “yes”还是 “no”都要格外小心</p></blockquote><p>领导对一切事情说“no” 的对应面，就是对一切事情说“yes”，并且两者没有明显的边界。承担超过 利用现有的资源（人力、时间等）能承受的工作范围，可能最终会导致你自己、你的团队和客户都受伤。<strong>向下属制定 什么时候应该说 “yes”，什么时候应该直接拒绝 的规范，对 leader 来说是特别重要的</strong></p><h3 id="接受与尊重"><a href="#接受与尊重" class="headerlink" title="接受与尊重"></a>接受与尊重</h3><blockquote><p>敢于承认你不了解的东西。开放地接受别人寻求帮助的请求，包括初级工程师（的提问）</p></blockquote><p>承认你不知道的事情，是很ok的。对软件工程师来说，最重要的技能之一就是找到问题的答案，并从中学到东西<br>作为一名 高级leader，需要学会接受 身边的下属 可能比你更了解工程的技术细节。承认你不了解一些细节是 ok 的，让下属负责解释他们。下属会因为你的诚实，以及对学习的兴趣，对你更加尊重，你也会对当前团队正在做的事情有更清晰的画面，并在这些事情上增添更多的价值。作为初级工程师，你应该向更高一级工程师把技术概念和方案细节解释清楚，可以是开放式（交流会），也可以是在会议室，取决于你觉得哪种方式比较舒适</p><h3 id="信息分享"><a href="#信息分享" class="headerlink" title="信息分享"></a>信息分享</h3><blockquote><p>通过会议 或者 问答 的形式，提出合适的问题，交换所学，并在团队中分享</p></blockquote><p>举行会议的时候，不要只是一个人在说。会议是一个很好的 分享想法、提供真实反馈的机会，除了表达自己，也应该给别人一些空间去发言，并认真倾听<br>初级工程师可能会羞于提出过多的问题。如果你是高级工程师，你可以通过提出（需求）上下文，来提示他们提出正确的问题。筛选问题之后，也要让提出问题的同学知道，你对（真实）问题的抛出感到高兴</p><h3 id="灵活性"><a href="#灵活性" class="headerlink" title="灵活性"></a>灵活性</h3><blockquote><p>捍卫你的观点，但是发现新的观点，和自己的观点对立的时候，也要懂得审视它们</p></blockquote><p>审视其他观点，也是交流的重要过程之一。有不同于自己的观点是很正常的，因为一个问题的解决方法本来就可能不止一种。与其固执于自己的观点，不如去倾听、审视其他观点。说不定这些不一样的想法，还能让你的观点在之前忽略的方向更进一步。Paul Saffo（斯坦福大学工程学院的咨询教授） 的原则 “<strong>Strong opinions weakly held</strong><sup><font color='#49E844'>[21]</font></sup>” 告诉我们要捍卫自己的观点，同时也要在发现新的对立现象之后，及时更新观点。这是一种科学、通用的方法论，不管提出观点的人是谁</p><h3 id="保持记录"><a href="#保持记录" class="headerlink" title="保持记录"></a>保持记录</h3><blockquote><p>非正式会议之后的一封邮件，有助于我们确认讨论的关键点和关键进展</p></blockquote><p>完全口头的交流有一个缺点，就是会后 （讨论过的事情）很容易忘记，或者是记错。保持会议过程所发生事情的记录，以及所有讨论点的总结，能降低这种风险。如果你和另一个同事已经确定要参与一项任务，你需要通过邮件将 ddl 知会到所有相关人，包括你的导师。在事项的（排期）评估讨论过程中，对尚未具体排期的计划进行记录也会很有用</p><h3 id="真诚"><a href="#真诚" class="headerlink" title="真诚"></a>真诚</h3><blockquote><p>了解在什么时候应该保持冷静，观察正在发生的事情</p></blockquote><p>有的时候，你对团队讨论做出的一些决定 会不太理解，或者是这些决定无论从技术还是业务角度看都不合理。这在跨团队讨论过程中可能会出现。（尽量）表现出你的真诚，并假定人们不会冒着 带有恶意 的风险。可能你只是对整体背景还没有完全的认识，或者是参与讨论的人们有各自的优先级考虑。你需要提出你的疑惑，列出你的观点，而不是对最终决定直接表示愤怒和消极</p><p>译者：“沟通”这一章节所说能否应用到现实，建立在团队有开放的交流氛围、leader和其他成员乐于听取你的想法的基础上。当然，现实情况并不总是那么理想，但不管怎样，<strong>保持冷静，少冲动做事</strong>是总没错的</p><h2 id="资历"><a href="#资历" class="headerlink" title="资历"></a>资历</h2><p>我们期望不断提高自己的资历，不管是从角色还是能力方面。有的人会对高级工程师职位感兴趣，有的人会更愿意往团队leader或者部门管理方向发展。不管是哪种选择，在我们职业发展的过程中，总会有一些关键特征，是会慢慢展示出来的。在你的成长过程中，你可能会由你的导师来带领你，下面是我的一些方法，可以帮助你在走上高级职位之前，准备好必要的素质</p><h3 id="资历和战略思维"><a href="#资历和战略思维" class="headerlink" title="资历和战略思维"></a>资历和战略思维</h3><blockquote><p>不要害怕做决定，或者表现得很不确定</p></blockquote><p>大部分时候你会发现，<strong>做决定的结果比不做决定要好很多</strong>。至少你的决定能让别人知道，你在朝哪个方向前进。作为leader，我们往往没有花足够的时间审视 整个团队到底期望我们做什么样的决定。即便如此，我们也不会这么去审视，因为我们不可能掌握 100% 的事实。我们确实应该在做决定前，尝试描述所有的依据和细节，但不可能做到面面俱到（特别是时间紧张的情况下）。（过度注意细节）这可能导致团队 长时间陷入 停滞、不确定的状态。通过有限的信息，在有限的时间作出的决定，效果反而会更好（译者：感到没事做是最不好的状态，对个人和对团队来说都是如此）</p><blockquote><p>leader 负责补充自己的知识库，来让自己全方位、战略性地思考，并为他人制定前进路线图</p></blockquote><p>随着经验成长，你的战略性规划、将想法应用于更多领域 的能力，也应该提升。从独立开发者角度出发，你可能会专注于你所负责的任务，还有需要实现的功能。但随着你的进步，你的影响力就不仅体现在工作任务和负责项目上了。在权衡选择时，你将学会根据选择带来的 效益和限制 两个角度，去思考更多的东西（即权衡利弊）。举个例子，在早期 你只是为了自己的团队，指引组内其他同事 去做决定，随着你的成长，你的选择和交流将会影响到多个团队</p><h3 id="以身作则"><a href="#以身作则" class="headerlink" title="以身作则"></a>以身作则</h3><blockquote><p>向团队传授学习方法。不要只是为了解决手头问题而去行动，耐心地指引他们 去锻炼一些能力，并让这些能力为自己服务</p></blockquote><p>工程师行业的领导善于<strong>授权</strong>。随着你的职位越来越高，尝试下放原来属于你的工具、权限、责任等，让团队成员自己去用这些资源并取得成功，（对下属）会很有帮助。这也是你继续提升效率的方法。还可以通过 提出好问题 来提升，而不只是回答问题</p><blockquote><p>在别人提供解决方案的时候，以身作则地 负责具有挑战性的任务，并提出（过程中遇到的）相关问题</p></blockquote><p>技术领域的高工 需要负责 团队内和团队外的协作、沟通和共识建立。<strong>他们致力于提高团队的整体产出，而不仅是自己的</strong>。作为高级工程师，你可能偶尔是为了学习新技术，或者是了解行业现状 去写代码，但这种事情并不会被写在工作内容中（需要自觉去做）。现实中，你还需要自觉去审视代码，确保架构图中没有疏漏。你还应该为自己的决定 如何带来技术或者商业价值 收集好依据和原因<br>高级工程师还应该熟练管理软件系统和团队。你可以领导一个多元化的工程师团队，分配给他们 注重代码质量、性能、复杂度 的任务，及时给予反馈和指导。同时，<strong>你还应该适当展示你的能力、工作和技能</strong>，让自己未来有能力解决具有挑战性的问题，在团队甚至公司获得知名度。总而言之，你应该培养和团队内同事、公司内领导层的关系</p><h3 id="提升你的影响力"><a href="#提升你的影响力" class="headerlink" title="提升你的影响力"></a>提升你的影响力</h3><blockquote><p>伟大的软件项目通常是由团队创造的，而不是个人。所以 如果你想实现更多的目标，或者在公司展示 你已经为成为 高级工程师 做好准备了，你需要通过合作和指导力来展现自己。提升影响力，不仅仅是为了自己，也为了团队的其他同事</p></blockquote><p>当我意识到需要扩展自己（的能力）的时候，就是我在google公司内向着成为高级工程师的时候。<strong>我必须在考虑 “我”和 “我们”的模式之间切换</strong>。通过和其他人协作、分享所学、专注于提升身边同事的经验和技术，我们深刻意识到做了更多有价值的事情</p><p>如果你是从独立开发者开始，你可能不会专门领导一个团队，但<strong>你可以寻求更多志同道合的小伙伴来和你共事</strong>，实现一个人难以实现的项目。随着你的技能、职位越来越高，你会通过建立团队，进一步提升工作效率，来继续贯彻这种（合作）思维</p><h3 id="“不能胜任”综合症（Imposter-syndrome-22-）"><a href="#“不能胜任”综合症（Imposter-syndrome-22-）" class="headerlink" title="“不能胜任”综合症（Imposter syndrome[22]）"></a>“不能胜任”综合症（Imposter syndrome<sup><font color='#49E844'>[22]</font></sup>）</h3><blockquote><p>尝试接受 犯错误、难以找到答案、需要寻找指导 的工作过程，可以帮你克服“我不能胜任”这种心理负担</p></blockquote><p>我们在工作中几乎都遇到过，对特定的工作或者是角色，（一开始）会感到自己并不能胜任。这种心理是非常普遍和真实的，甚至在一些已经获得明显成就的人身上也会出现。即便是别人会找自己咨询意见，你依然可能会觉得自己不适合。甚至你永远也不会放下这种内心负担，但它确实能激发你的好奇心，推动你去学习新东西</p><h2 id="指导"><a href="#指导" class="headerlink" title="指导"></a>指导</h2><h3 id="指导他人"><a href="#指导他人" class="headerlink" title="指导他人"></a>指导他人</h3><blockquote><p>及时提供信息和指导建议，让你的学员不至于陷入完全不正确的方向，而是通过做好自己的事情来掌握技能</p></blockquote><p>在你职业生涯的发展过程中，你可能会发现自己时而是导师，时而是学员。作为导师指导别人，不一定非要很正式的过程。非正式（日常工作）情况下，你也可以寻求指导别人或者获得别人的指导的机会。指导别人可以锻炼自己的人际交往能力。下面是一些指导的关键点：</p><p><strong>指导别人是引导别人去发现答案，而不是直接给他们最终答案</strong>。允许你的学员在解决问题的时候多尝试，多实验，因为他们有直接感受解决方法的风险和收益的最佳机会。不过，你也应该及时把解决问题用得到的工具（比如方法论）告知给他们，如果是一个技术问题，也可以参与讨论，提出你所建议的想法和方案，具体实施还是交给他们。让学员也分享所想，提出问题，进行对话讨论</p><p>如果你的学员发现自己很难找到问题的解决方法，你可以分享你会怎么去分析问题，接近答案，以及为什么你会用一个特定的模式来解决问题。教会他们分析问题和debug的方法，分享你在 诊断问题、提出解决方案、实现解决方案 和 debug 时候的思路。<strong>分享如何解决问题的技巧</strong>，而不仅仅是答案</p><h3 id="组织层面的指导"><a href="#组织层面的指导" class="headerlink" title="组织层面的指导"></a>组织层面的指导</h3><blockquote><p>指导别人是作为高级工程师的职责之一，有助于在组内成员变化之后，依然能保留关键领域的知识</p></blockquote><p>假设你在很投入地指导别人，而且也是你日常工作的一部分。这种情况下，你就需要安排一部分工作时间，专门用在指导活动上。这能让你指导的效果更好，在指导生涯中做出更有意义的事。有的公司还会根据职责发展阶段和要求，在员工发展的每一阶段都会对 导师/学员机制 有一定的流程规范</p><h3 id="学员的职责"><a href="#学员的职责" class="headerlink" title="学员的职责"></a>学员的职责</h3><blockquote><p>导师可以给你建议，但真正评估和实施方案的还是你自己，你需要对自己的职业生涯发展和成长做好规划</p></blockquote><p>假设你是期望在团队内成长起来的初级工程师，我只有一条建议给你：找到那些能帮你规划职业发展的优秀导师<br>你会在职业生涯中，遇到仰慕的教练、导师和同事。他们会给你如何培养技能的建议，但真正实践还是得靠自己。吸收别人的建议时，也要注意技术层面的条件，不同场景，有效的法则也会不同。在一个项目有效的理论，换个项目就不一定适用了（<strong>具体情况具体分析</strong>）</p><h2 id="高效的团队"><a href="#高效的团队" class="headerlink" title="高效的团队"></a>高效的团队</h2><h3 id="构建信任"><a href="#构建信任" class="headerlink" title="构建信任"></a>构建信任</h3><blockquote><p>信任可以将团队人员拧成一股绳，朝着共同的目标努力工作。相反，官僚主义会让彼此产生隔阂</p></blockquote><p>当工程师一起参加一个<strong>开放、公正</strong>的头脑风暴会的时候，（这种形式）为能够驱动创新 的新的想法和不同思维角度（的提出）铺平了道路。（这种开放的氛围）确实能驱动团队变得高效和高产出。不过团队内成员能高效合作的基础，还是健康的沟通和关系。下面是一些构建和管理高效团队的关键点：</p><p>构建起信任，是团队构建中最重要的事项。跨越不同级别的同事之间的信任，对工作事项能快速完成、团队能高效运作很必要的。团队成员可能会使用不同的开发工具，比如为了检查工程质量而使用的代码检视工具，或者是测试工具。然而如果没有信任作为基础，这些（开发）过程都会变得乏味和官僚主义。举个例子，如果你信任一个工程师和他的代码，那么在进行代码检视的时候，就会更少地吹毛求疵</p><p>译者：确实有的公司盲目追求编程规范，搞了各种可信认证，已经让编程完全变了味。译者认为，可信的目的并不是让大家都变成“一样”的人，写完全相同风格的代码，用同样的工具，甚至用同样的开发语言。如果是这样不如开发一个机器人来写代码，而是相信他的代码上线之后能稳定运行、代码风格比较规范、代码具有可扩展性等</p><p>真正开放、有彼此促进的开发氛围，是需要靠实际的团队合作培养出来的，比如分享、代码检视会等，而不只是各种枯燥的考试和认证</p><h3 id="理解业务模型"><a href="#理解业务模型" class="headerlink" title="理解业务模型"></a>理解业务模型</h3><blockquote><p>理解变更会对业务侧带来的影响</p></blockquote><p>当你（从业务侧）接到一批需求时，你需要了解它们背后的动机。一定不要跳过需求文档中的“<strong>目的（或背景）</strong>”和“<strong>业务目标</strong>”章节。你还可以通过（向产品经理或用户）提问来了解业务模型，以及它和需求之间的关系。通过（检视）现有的代码，或者是一次和SME（subject-matter-experts 行业专家）之间的交流，可以让你对领域和架构有更深入的视角。在进行系统流程和数据工作流（data flow）的时候，请参考业务文档、特性地图 以及 使用示例等</p><p>“大部分软件工程师都喜欢带着技术上的挑战去解决问题。然而当你理解业务的角度（去思考）时，你会收获更多，比如成本更低的解决方案。要记住你的用户/客户 使用你的产品，也是为了去完成他们自己的工作，就像你完成每天的工作方式一样。尽量不要让他们的工作比使用你的产品之前还要困难” - 来源<sup><font color='#49E844'>[23]</font></sup></p><h3 id="提升你的影响力-1"><a href="#提升你的影响力-1" class="headerlink" title="提升你的影响力"></a>提升你的影响力</h3><blockquote><p>对业务-软件之间的关系 保持一定的洞察力和敏锐度，能提升你的工作影响力</p></blockquote><p>对业务和产品进行360度的审视，能帮助你对团队和项目有更积极的贡献。如果你能够<strong>从销售和市场人员的角度进行思考</strong>，你将能够有更好的方式去做出正确的选择和高产出的工作。随着你对团队的影响力的提升，你对工作的满意度和工作给你的收获也会更多（译者：当然这是一种很理想的情况：工作和成长是相互促进，正相关的关系）。领导会注意到，你有能力自我驱动，不需要过多的监督，就能够做出对团队、项目和业务都有促进的事情，来提升整体效率</p><h2 id="Work-Life-balance"><a href="#Work-Life-balance" class="headerlink" title="Work-Life balance"></a>Work-Life balance</h2><p>如果你已经掌握了 技术能力、人为因素和领域方面的知识，作为软件工程师，你将会更受欢迎。团队内部的同事也会经常向你请教。除了工作本身的工程任务之外，你可能还需要承担过多协作相关的事情，导致<strong>协作过载</strong>（collaboration overload<sup><font color='#49E844'>[24]</font></sup>）。过多的临时请求会侵占你的时间，导致你没有精力去做真正想做的事</p><h3 id="时间管理"><a href="#时间管理" class="headerlink" title="时间管理"></a>时间管理</h3><blockquote><p>为 <strong>Deep Work</strong>（沉浸式工作）规划好你的时间表</p></blockquote><p>你需要在日程中专门留出一部分时间，用来做 Deep Work。坚持了几年，我发现这个方法对编写设计/策略文档，或者钻研一个技术问题是非常有效的。Deep Work 是一种<strong>远离干扰、深度集中（注意力）</strong>的工作模式，能够在有限的时间创造出很多价值。Cal Newport（乔治城大学计算机科学系副教授）的《Deep Work》<sup><font color='#49E844'>[25]</font></sup>也谈到了这一点</p><p>“<strong>注意力残留</strong>”（Attention residue）是 Cal 提到的一个观点，也是 为什么 持续的 Deep Work 能如此高效的原因：每当你从一件事情切换到另一件事的时候，内心注意力的“残留”，会让你依然陷入对上一件事的思考上面，很难重新集中注意力去做当前真正重要的事</p><p>Deep Work 通过让你专注于一件事情上，最大程度地提升你在有限时间内的产出。期间<strong>没有打扰，没有推特，没有会话或者邮件</strong>。我非常推荐你尝试一下，对那些认知工作比较重的任务（译者：需求方案设计、技术问题定位等），放在 Deep Work 的时间去完成它们</p><p>我还发现偶尔换一个工作位置，对 deep Work 很有用。我们可能会陷入到（“过于习惯”）一些特定的工作地点和特定的工作任务，如 一个桌子、一个房间、高楼里面（需要完成老板日常吩咐的任务）。适当进行一些改变，可以帮助我们重振活力</p><p>译者：有意思的是，我有个导师也经常这么做。一开始还纳闷怎么每天他下午3点多都要出去工位一段时间，后来接了个茶才发现，原来他正在茶水间摆着电脑沉浸式敲代码呢</p><blockquote><p>尽量不要打乱自己的工作时间</p></blockquote><p>如果你的一个小时因为分心，被分割成几分钟的时间块，你可能会感到焦虑。找到让你分心的原因（不管是因为自己还是别人）并解决他们。否则你的一天将会变得很低效</p><p>译者：这里提几点比较具体的建议：</p><ul><li>每天都固定留至少1h 用于专注做1-2件事情上（尽量是做有长期价值的事）</li><li>专注模式下，尽量关闭社交软件的通知，眼不见心不烦</li><li>通过公司内部的聊天工具备注，或者是其他方式，把自己的专注时间也告知别人，让别人尽量尊重你的时间的同时，提高彼此沟通的效率</li><li>专注模式尽量用在精神状态比较好的时候，这个因人而异，对译者来说就是下午3-4点的时间</li><li>也分配一个“杂事模式”，专门用来处理bug、回复、部署等这一类偏流程或运维的事情</li><li>临时的事情超过3个，一定要排个优先级，防止安排不过来（毕竟人类大脑在“多线程切换”这件事上可没有计算机这么灵活）</li><li>进入专注模式前，对自己要做的事尽量拆细，做到万一真的被打断了，能快速切换状态</li><li>（作者）切换工作地点，给自己寻找不一样的灵感。译者就发现有的大佬喜欢到茶水间/会议室专心写代码，远离嘈杂的办公位</li></ul><h3 id="过度工作并不是好的工作素养"><a href="#过度工作并不是好的工作素养" class="headerlink" title="过度工作并不是好的工作素养"></a>过度工作并不是好的工作素养</h3><p>你不可能比所有人都更努力工作。很多公司都以“加班”作为工作态度的“标准”，并将他们和良好的职业道德挂钩。然而成功来自很多因素，绝不仅仅是加班</p><h3 id="不断尝试超越自己的标准是不现实的"><a href="#不断尝试超越自己的标准是不现实的" class="headerlink" title="不断尝试超越自己的标准是不现实的"></a>不断尝试超越自己的标准是不现实的</h3><p>我对此感到很惭愧。如果你想保持平静的心态去开发，避免疯狂的工作环境，你需要有“<strong>知足心</strong>”，对现状保持满意。作为领导，你应该领导你的团队形成这样的氛围，有“<strong>足够好就可以了</strong>”的心态，树立好的榜样</p><p>译者：说白了，就是“<strong>反对无休止的内卷</strong>”。对个人来说，不断追求更好的自己是好事，但是对团队来说，看不到努力的天花板，不知道做到怎样算是足够，绝对不是好事。Leader 在给员工审核目标的时候，也应该给每个下属明确“<strong>达到足够</strong>”的指标</p><blockquote><p>工作时间是有限的，与其花更多的时间，不如减少没有必要的工作</p></blockquote><p>（市面上）已经有很多关于如何更好地重新梳理工作的指导（书、文章），然而真正的问题可能是在一开始就规划了太多需要完成的事情。你完全可以毫不犹豫地消除没有必要、浪费时间的事，而不是试图管理本来就有限的工作时间</p><h3 id="你不需要知道每一件时事"><a href="#你不需要知道每一件时事" class="headerlink" title="你不需要知道每一件时事"></a>你不需要知道每一件时事</h3><p>很多人会对没有跟上实时热点感到焦虑甚至害怕，这也是人们会沉迷于每个小时都去刷推特、reddit、instagram 等等（社交软件）的原因。我肯定也经历过（这种心态）<br>大部分信息对我们来说都没有那么重要，（与其关注时事）应该尝试更多地阅读<strong>读总结类的新闻</strong>，或者是<strong>减少查看时事的频率</strong><br>Jason Fried 的 《It doesn’t have to be crazy at work》<sup><font color='#49E844'>[26]</font></sup> 里面提到了关于这方面的更多思考</p><h3 id="通过学会说不、了解什么时候该停下来、以及规划好自己的时间（包括工作间隙的休息），主动把自己从焦虑中解放出来"><a href="#通过学会说不、了解什么时候该停下来、以及规划好自己的时间（包括工作间隙的休息），主动把自己从焦虑中解放出来" class="headerlink" title="通过学会说不、了解什么时候该停下来、以及规划好自己的时间（包括工作间隙的休息），主动把自己从焦虑中解放出来"></a>通过学会说不、了解什么时候该停下来、以及规划好自己的时间（包括工作间隙的休息），主动把自己从焦虑中解放出来</h3><p>时间管理和把握好工作-生活的平衡，对每个级别的工程师来说都至关重要。长期加班可能会让你倍感压力和失去动力。压力（过大）还会导致其他身心健康并发症。在一天结束之前把问题都解决完，会很诱人，但慢慢地这可能会变成一种（坏）习惯（加班）</p><p>扩展：压力对身体带来的影响<sup><font color='#49E844'>[27]</font></sup><br>（建议在医学生的陪同下阅读）</p><h3 id="鼓励你和你的团队成员进行休息、旅游和调休"><a href="#鼓励你和你的团队成员进行休息、旅游和调休" class="headerlink" title="鼓励你和你的团队成员进行休息、旅游和调休"></a>鼓励你和你的团队成员进行休息、旅游和调休</h3><p>你的健康和家庭都是很重要的。如果你能意识到这点，并作为高级工程师给团队其他成员做好示范，这将会很好地提升职场整体的幸福感。反之，筋疲力尽和倦怠（的工作氛围）会导致职场氛围非常不健康</p><h3 id="随着对问题的了解深入，更新（排期）评估"><a href="#随着对问题的了解深入，更新（排期）评估" class="headerlink" title="随着对问题的了解深入，更新（排期）评估"></a>随着对问题的了解深入，更新（排期）评估</h3><p>在工作中，总是会有客户或利益相关者 这样的角色，会想要了解产品什么时候可以交付，以及所投入的成本（人力、机器等）是否值得。这是非常合理的。有时他们想要对齐DDL，或者确定 为了支持你的工作，需要进行的依赖项（准备）的规划</p><p>众所周知，<strong>软件层面的 DDL 很难准确预测</strong>。只有在项目进入特定时期的时候，才能给出预估性的截止时间。随着时间推移，了解了团队解决问题的能力之后，（leader）应该更新预期。<strong>初次预估通常是最不靠谱的，但它作为起点，可以在之后不断被修正</strong>。<strong>初始预估还会比较保守</strong> — 当产品需求、用户体验或者是依赖关系不清楚的时候，一个更宽松和保守的预估，对项目发展是有帮助的。我还发现，通过和 PM 合作，保证我们都在讨论同一件事情，来制定预估，能经常获得成功</p><p>软件预估的问题在于，初次预估被固定下来之后，是当做计划，而不是初稿。当团队处在关键阶段，将初步预估当成计划（之后），却不注意及时修正，就可能会带来问题（译者：也不必做惊弓之鸟，需求排期大概2-3天左右更新一次即可）。一旦项目获得批准，细节更是需要留意 — 随着对如何实现需求有更加清晰的认识，原本3个月的预估可能就要变成2个月（或4个月）</p><p>你几乎总是尽可能想要让预估驱动你的计划，或者是让计划驱动更新你的预估。在我的团队中，如果我们确实有一些不可推迟的 DDL（如会议），（其他需求）预期超过ddl 可能也是可以的 — 我们可以通过修改提示（如：预览，或在界面提示：该功能将在不久之后实现）、将需求推向更久之后的未来完成等，这些都是可以和领导商量的选项。当然，我必须确认，这些（变化）并不总是这么微小（所以需要谨慎考虑）。当工作计划变得紧张的时候，我们可以把工作拆解成 “必须实现（<strong>must-have</strong>）” 和 “如果有会更好（<strong>nice-to-have</strong>）” 两部分，将后者移到后续的迭代中去，并确认前者是否能赶上 DDL</p><p>（在做了这些调整之后）如果计划还是太赶，你还有其他问题可以确认：比如 “我们是否还可以增加项目人手？” 以及 “是否有一大部分（工作）范围可以削减，之后依然能实现（令用户）满意的交付水准？”</p><p>译者：对 leader 来说，还应该注重的点是<strong>备用方案的制定</strong>。需求在实现过程中不可能所有事都一帆风顺，对中间环节可能遇到的问题，leader 应该要有准备意识，对各种情况都有一套备用方案，保证需求能够按时交付</p><h3 id="有时取消项目是正确的选择（即便是让人感到不舒服）"><a href="#有时取消项目是正确的选择（即便是让人感到不舒服）" class="headerlink" title="有时取消项目是正确的选择（即便是让人感到不舒服）"></a>有时取消项目是正确的选择（即便是让人感到不舒服）</h3><p>我讨厌（取消项目）这件事，但长远来看，对项目和组织来说它确实可能是最健康的选择。特别是在项目获得支持、准备正式上线之前，却因为团队成员要解散，而最终不得不停止之前做这个（取消项目的）决定，（提前取消项目）是尤其正确的。如果大家想知道，建议阅读 《Killed by Google》<sup><font color='#49E844'>[28]</font></sup>，这篇文章旨在尽量减少因为大环境问题，导致需要裁减项目的情况。最近我就停止了一个经营了 好几年的项目，感到很艰难</p><p>什么时候会出现需要停止项目的情况？你可以决定投资一个在当时看起来方向正确的新项目，各种事情看起来都完美契合（市场需求、公司投入、人力投入承诺等），使得整个项目也是完全有价值有意义的。<strong>但一年之后，市场、领导层、项目的重要性等环境因素，可能就变了</strong>。定期检视 项目成立初期的假设，随着项目的发展，是否依然成立 （对保障项目稳定）很关键</p><p>当你越能为你的假设支撑起更多的信心时，你就越有机会让项目成功启动，并继续获得支持。有很多原因 让停止项目很艰难，包括参与项目的同事们，已经投入了真心实意的情感，希望能看到项目成功落地。作为leader，将被解散团队的成员引导到其他已经成功落地的项目 也是一个艰难的选择，因此让他们重新感觉到 内心的安全、信任和幸福 是很重要的。从客户角度来说，（作为leader）也需要留意 用户的信任度，你需要认识到你的长期决策 会如何影响到用户感受</p><h3 id="关于技术债：预防远远-gt-补救"><a href="#关于技术债：预防远远-gt-补救" class="headerlink" title="关于技术债：预防远远 &gt; 补救"></a>关于技术债：预防远远 &gt; 补救</h3><p>Titus Winters<sup><font color='#49E844'>[29]</font></sup> （Google c++ 代码负责人） 将技术债定义为“<strong>系统（效果）和代码之间的差距，在当下的情况 vs 我们预期的情况</strong>”（译者：这里提到的“差距”，其实就是需要“<strong>补救</strong>”的工作，<strong>在项目起步阶段容易被忽略的事情</strong>，比如单元测试、调试工具、故障处理机制等）。这些差距会有具体的体现，并且会比其他债务的影响更深。技术债有的来自早期没有出现的软件异常（疏忽），有的来自事后发现（后见之明），还有的来自技术的变化（环境因素）</p><p>持续优先应对技术债还是很难的，因为你不是总能将还没出现的bug 或者 还没发生的 服务故障 量化，因为你还没“还清足够的技术债”。因此 保持住团队对 修补技术债 这种事情的兴趣，并在评估绩效的时候（适当）奖励这种事项，是很重要的。问题随着时间的积累，“补救”的成本也会越来越大，就像解决污染问题一样，因此对技术债的预防，永远是比在之后再进行补救的成本更低</p><p>那么，我们该怎么避免技术债（过度）积累呢？技术 leader 应该在迭代中，除了新功能的需求之外，也定期安排 整理和“弥补”技术债的工作。检视者需要意识到，（过于）追求短期成效，可能会在之后导致问题。管理者和董事会也应该特别小心 用新项目替换（覆盖）已存在项目。除非权衡利弊之后，觉得替换值得的（比如需要对比：解决当前项目技术债是不值得的 vs 构建新的项目）。另外，监控项目的健康状态，是在这里讨论如何解决技术债的 基础</p><h3 id="如果没有充足的休息，和-work-life-balance（的习惯），你的团队将会产生职业倦怠"><a href="#如果没有充足的休息，和-work-life-balance（的习惯），你的团队将会产生职业倦怠" class="headerlink" title="如果没有充足的休息，和 work-life balance（的习惯），你的团队将会产生职业倦怠"></a>如果没有充足的休息，和 work-life balance（的习惯），你的团队将会产生职业倦怠</h3><p><strong>Burnout</strong><sup>（<strong>职业倦怠</strong><font color='#49E844'>[30]</font></sup>）是一种 由于压力没有被成功管理好，而导致 精力耗尽的状态。我见过很多程序员，在大环境导致的工作压力下，产生职业倦怠。在科技领域，这种情况总是会出现。最近我采访（同事）会按 1:1 的比例问两个问题：“你的压力等级现在怎么样？”、“我可以怎么帮助你？”</p><p>我对职业倦怠的体验是：<strong>这种感觉来得不知不觉，又很难消散</strong>。你会慢慢地感觉能量开始变少，失去动力，甚至还要继续尽力应付工作压力。你开始怀疑自己出现了什么问题，但没有意识到，你的身体已经在过度工作，来弥补能量的不足。你还会继续让自己工作强度越来越大，但最终会发现（身体）已经没有多少可以付出的了</p><p>大概5年前，我经历过这种职业倦怠，不过我感到欣慰的是现在走出来了。是什么让我走出来的呢？有很多因素。（职业生涯）前几年，我把工作放在第一位，工作时间越来越长，并总是说做得还不够。从来没有进行足够的休息的假期。晚上平均只睡5个小时。到家之后，我已经是“低能量”的状态了，没有给家庭足够多的陪伴<br>所谓的“修正”，就是做和这些相反的事：<strong>工作之余多休息、晚上多睡觉、在工作时间内挤出更多价值（即 提升工作效率），更好地委派（工作），并有一个明确的“非工作”时间</strong></p><p>对主管来说，为了避免下属产生职业倦怠，我们应该鼓励团队成员多用上假期时间，获得休息，并定期（沟通）确认下属在有压力情况下，依然能顺利做好他们的工作</p><h3 id="大型组织-公司中流程会比较缓慢"><a href="#大型组织-公司中流程会比较缓慢" class="headerlink" title="大型组织/公司中流程会比较缓慢"></a>大型组织/公司中流程会比较缓慢</h3><p>我和工程师们进行过很多对话，最后（主题）都可以归结为“为什么在大型组织中进行 <strong>X moon-shot</strong>（谷歌内部形容 “创新性的、难以实现的项目” ） 很困难？”Alex Komoroske<sup><font color='#49E844'>[31]</font></sup>（前谷歌产品经理） 对此有一个很好的比喻：<strong>黏菌</strong><sup><font color='#49E844'>[32]</font></sup>（slime mold）。背后的意思是，即使是（在公司中）执行一件很小的工作，可能都会因为 协作阻力，比你理想中进展要慢很多。随着直接参与、或者合作参与项目的人变多，组织的系统、架构和内部动态 变得复杂，这种阻力就会变大</p><p>还有很多因素对这种阻力起着作用，包括对其他同事的工作事项复杂度的低估（比如：这些事情之间有依赖关系的时候），你不能忽略这些因素，因为它们会让系统故障（影响面）扩散开。解决这种阻碍的唯一方式就是尽可能地<strong>解耦</strong><sup><font color='#49E844'>[33]</font></sup>，这样才能让（功能）能按正确的时间节点交付，最终收敛于目标需求</p><p>与其一开始就追踪所有的不确定（X）因素，你可以避免只关注“对月亮射击”（成功风险较大的努力）的问题，而更多地关注“对天花板射击”（完成每一步的风险更小）的问题，能让你更容易地接近目标。如果你遇到的问题和这个章节非常类似，非常建议你阅读 Alex 的 分享《Coordination Headwinds》<sup><font color='#49E844'>[34]</font></sup> （PPT）</p><h3 id="专注于-问题-VS-专注于-项目"><a href="#专注于-问题-VS-专注于-项目" class="headerlink" title="专注于 问题 VS 专注于 项目"></a>专注于 问题 VS 专注于 项目</h3><p>想象你的用户有一个未解决的需求（比如 一个问题），当你是具体负责一个项目的工程师的时候，思考你的项目会如何解决这个问题是很正常的（局部最大值）。在一个拥有几个类似项目的大型组织中，很可能会看到工程师们独自思考“我的项目如何解决这个问题”。如果你是一批项目的管理者，（这种解决问题的思考方式）就不是那么清晰了。如果你的用户表示希望用到你们好几个产品的时候呢？如果每个项目都独立地按几乎相同的思路，去解决问题，不会觉得很奇怪吗？相反，你真正想提的问题可能是 “<strong>什么是解决这个问题 端到端 的方案？</strong>”，并探索需要如何对多个项目进行修改/升级，才能够全面地解决用户需求。这种方式可能需要参与了多个相关项目的开发者，进行更深入的合作。（虽然人力成本会提升，然而）这种方式能最终给你的用户一个更清晰、更全面的解决方案（场景故事）</p><p>译者：作者的出发点主要是在有多个成熟方案的基础上，保留最优解。但在项目还处于探索阶段，需要跟紧开源社区、竞争对手的时候，产品之间出现重叠并不算大问题，甚至公司还会有意保留产品功能类似的团队，促进竞争</p><h2 id="作者总结"><a href="#作者总结" class="headerlink" title="作者总结"></a>作者总结</h2><p>Brian Staufenbiel（Opera Parallèle 的创意总监和设计师） - “多和专家在一起（共事），多和那些在特定领域有专长的同事一起工作”</p><p>（将时间）投资于 那些 能够让你学到东西的同事的关系和友谊上，对他们的指导、领导和成功保持开放态度。<strong>永远不要羞于提出问题或者咨询意见</strong>。在很多情况下，（你离正解）只是一个问题的差距。</p><p>不管在什么阶段，<strong>对技术、商业领域和 人脉资源 技能的掌控（能力）</strong> 都是需要持续培养的。一个企业不可能期待 从别的企业招来的 高级别人才，从第一天就能非常适应公司并高效工作。如果你是一个优秀的工程师，你将会对公司的成长也有所帮助。作为回报，你也会获得一些新的途径，它们将指引你 继续吸收新的技术，不断成长</p><p>最后，感谢 Leena Sohoni, Joshua Cruz, Kara Erickson, Jeff Posnick, Houssein Djirdeh and Sriram Krishnan 对本文积极的帮助和贡献</p><h2 id="资料"><a href="#资料" class="headerlink" title="资料"></a>资料</h2><p>[1] <a href="https://addyosmani.com/">Addy Osmani</a></p><p>[2] <a href="https://addyosmani.com/blog">作者博客首页</a></p><p>[3] <a href="https://www.glassdoor.com/blog/guide/soft-skills-vs-hard-skills">通用技巧</a></p><p>[4] <a href="https://en.wikipedia.org/wiki/First_principle">第一原则</a></p><p>[5] <a href="https://www.learningscientists.org/blog/2021/3/25-1">批判性思考是通用技能吗？</a></p><p>[6] <a href="https://skorks.com/2010/04/on-the-value-of-fundamentals-in-software-development">The value of fundamentals in Software Engineering</a></p><p>[7] <a href="https://medium.com/@felixthedev/why-learning-the-programming-fundamentals-matters-67e5dbbdee8f">Why learning the fundamentals matters</a></p><p>[8] <a href="https://www.freecodecamp.org/news/learn-the-fundamentals-of-a-good-developer-mindset-in-15-minutes-81321ab8a682">Learn the fundamentals of a good developer mindset</a></p><p>[9] <a href="https://en.wikipedia.org/wiki/Fear_of_missing_out">FOMO</a></p><p>[10] <a href="https://itrevolution.com/articles/why-the-full-stack-engineer-is-problematic">T型工程师</a></p><p>[11] <a href="https://www.csc.gov.sg/articles/how-to-build-good-software">Why Bad Software Happens to Good People</a></p><p>[12] <a href="https://en.m.wikipedia.org/wiki/You_aren%27t_gonna_need_it">YAGNI</a></p><p>[13] <a href="https://ronjeffries.com/xprog/articles/practices/pracsimplest">Do the simplest thing that could possibly work</a></p><p>[14] <a href="https://en.m.wikipedia.org/wiki/Overengineering">不要过度设计</a></p><p>[15] <a href="https://en.m.wikipedia.org/wiki/Abstraction_principle_(computer_programming)">抽象原则</a></p><p>[16] <a href="https://en.m.wikipedia.org/wiki/Don%27t_repeat_yourself#AHA">AHA</a></p><p>[17] <a href="https://medium.com/@nathan.fooo/4-notes-modules-should-be-deep-ba5671c4288c">Deep Module</a></p><p>[18] <a href="https://asbresources.com/pros-and-cons-of-failing-fast-with-agile">快速失败</a></p><p>[19] <a href="https://www.productplan.com/learn/agile-definition-of-done">The Definition of Done</a></p><p>[20] <a href="https://hbr.org/2017/06/help-your-team-stop-overcommitting-by-empowering-them-to-say-no">Help Your Team Stop Overcommitting by Empowering Them to Say No</a></p><p>[21] <a href="https://www.saffo.com/02008/07/26/strong-opinions-weakly-held">Strong opinions weakly held</a></p><p>[22] <a href="https://www.healthline.com/health/mental-health/imposter-syndrome">Imposter syndrome</a></p><p>[23] <a href="https://news.ycombinator.com/item?id=26177680">来源</a></p><p>[24] <a href="https://hbr.org/2016/01/collaborative-overload">collaboration overload</a></p><p>[25] <a href="https://www.amazon.co.jp/-/en/Cal-Newport/dp/1455586692">Deep Work: Rules for Focused Success in a Distracted World</a></p><p>[26] <a href="https://www.amazon.com/Doesnt-Have-Be-Crazy-Work/dp/0062874780">It doesn’t have to be crazy at work</a></p><p>[27] <a href="https://www.apa.org/topics/stress/body">压力对身体带来的影响</a></p><p>[28] <a href="https://killedbygoogle.com/">Killed by Google</a></p><p>[29] <a href="https://www.oreilly.com/pub/au/7953">Titus Winters</a></p><p>[30] <a href="https://zh.m.wikipedia.org/zh-hans/%E8%81%8C%E4%B8%9A%E5%80%A6%E6%80%A0">职业倦怠</a></p><p>[31] <a href="https://www.komoroske.com/">Alex Komoroske</a></p><p>[32] <a href="https://zh.wikipedia.org/wiki/%E9%BB%8F%E8%8F%8C">黏菌</a></p><p>[33] <a href="https://www.infoq.cn/article/8hlh2qewp1y00qumdmqj">解耦</a></p><p>[34] <a href="https://komoroske.com/slime-mold">Coordination Headwinds</a></p>]]></content>
      
      
      <categories>
          
          <category> 职业规划 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 翻译 </tag>
            
            <tag> 职业规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>通过 sealos 部署 k8s 集群</title>
      <link href="/2022/09/22/sealos/"/>
      <url>/2022/09/22/sealos/</url>
      
        <content type="html"><![CDATA[<p><a href="https://blog.csdn.net/xiaoliizi/article/details/126998976">本文csdn地址</a></p><h2 id="sealos"><a href="#sealos" class="headerlink" title="sealos"></a>sealos</h2><p><a href="https://docs.sealos.io/zh-Hans/docs/Intro">官方文档</a></p><p><a href="https://github.com/labring/sealos/releases">release</a></p><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>sealos 是用于一键部署 k8s 集群的<strong>工具</strong>。对于不想被太多操作系统细节配置困扰，又想快速装好一套测试k8s集群的同学，无疑是很方便的</p><p>网上教程很多，这边自己简单写下在公司机器上安装的过程，绕了一部分坑，帮助大家更快地使用</p><p>官方文档还说明 sealos 可用来安装其他分布式组件，mysql、redis、pgsql 等</p><h2 id="下载-sealos"><a href="#下载-sealos" class="headerlink" title="下载 sealos"></a>下载 sealos</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -LO https://github.com/labring/sealos/releases/download/v4.0.0/sealos_4.0.0_linux_amd64.tar.gz</span><br></pre></td></tr></table></figure><p>解压后的文件列表:</p><p>[root@host_name sealos]# ll<br>总用量 68568<br>-rw-r—– 1 root root Clusterfile<br>-rwxr-xr-x 1  501   20 image-cri-shim<br>-rw-r–r– 1  501   20 LICENSE<br>-rw-r–r– 1  501   20 README.md<br>-rwxr-xr-x 1  501   20 sealctl<br>-rwxr-xr-x 1  501   20 sealos</p><p>sealos: 安装 k8s 工具<br>sealctl: 管理员工具，如生成证书。自己暂时没用到过</p><h2 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h2><h3 id="免密登录"><a href="#免密登录" class="headerlink" title="免密登录"></a>免密登录</h3><p>对于没有给 机器登录密码（比如 root 密码） 的环境来说，可以登录节点后配置 ssh key ，用于在<strong>执行 sealos 指令的节点 免密登录 安装节点</strong>（包括 master 和 其他节点）</p><h2 id="安装-k8s"><a href="#安装-k8s" class="headerlink" title="安装 k8s"></a>安装 k8s</h2><p>常用的安装方式有两种: 直接安装 和 导出配置文件后再安装</p><h3 id="直接安装"><a href="#直接安装" class="headerlink" title="直接安装"></a>直接安装</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sealos run labring/kubernetes:k8s_version labring/calico:calico_version \</span><br><span class="line">     --masters master_ip:ssh_port \</span><br><span class="line">     --nodes node_1_ip:ssh_port,node_2_ip:ssh_port</span><br></pre></td></tr></table></figure><p>自己测试用的版本: k8s: v1.20.0, calico: v3.22.1</p><h3 id="导出配置后安装（推荐）"><a href="#导出配置后安装（推荐）" class="headerlink" title="导出配置后安装（推荐）"></a>导出配置后安装（推荐）</h3><p>导出配置文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">./sealos gen labring/kubernetes:k8s_version labring/calico:calico_version \</span><br><span class="line">     --masters master_ip:ssh_port \</span><br><span class="line">     --nodes node_1_ip:ssh_port,node_2_ip:ssh_port &gt; Clusterfile</span><br></pre></td></tr></table></figure><p>配置google镜像源</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># vim Clusterfile</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps.sealos.io/v1beta1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Cluster</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">creationTimestamp:</span> <span class="literal">null</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">default</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="comment"># ...</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="comment"># 设置 google container 阿里代理源，加速下载</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">kubeadm.k8s.io/v1beta1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ClusterConfiguration</span></span><br><span class="line"><span class="attr">imageRepository:</span> <span class="string">registry.aliyuncs.com/google_containers</span></span><br></pre></td></tr></table></figure><p>运行集群</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./sealos apply -f Clusterfile</span><br></pre></td></tr></table></figure><h3 id="安装后测试"><a href="#安装后测试" class="headerlink" title="安装后测试"></a>安装后测试</h3><p>查看 pod</p><p><img src="/2022/09/22/sealos/sealos03.png" alt="all pods"></p><p>查看镜像</p><p><img src="/2022/09/22/sealos/sealos02.png" alt="all images"></p>]]></content>
      
      
      <categories>
          
          <category> 开发工具 </category>
          
          <category> Kubernetes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Kubernetes </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>通过 Docker Compose 本地启动 hadoop 集群</title>
      <link href="/2022/08/13/dockerfile-compose-hdfs/"/>
      <url>/2022/08/13/dockerfile-compose-hdfs/</url>
      
        <content type="html"><![CDATA[<p><a href="https://blog.csdn.net/xiaoliizi/article/details/126474924">本文csdn地址</a></p><h2 id="项目地址"><a href="#项目地址" class="headerlink" title="项目地址"></a>项目地址</h2><p><a href="https://github.com/smiecj/docker-centos/releases/tag/v1.3.0">docker-centos</a></p><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>在完成几个开源中间件的容器化一键部署之后，和一个同事聊到了关于如何在本地部署 hadoop 集群，方便进行大数据任务相关的测试</p><p>后面我们一起搜了一些资料，在知乎<sup><font color='#49E844'>[1]</font></sup>上找到有人弄好了一套镜像<sup><font color='#49E844'>[2]</font></sup>, 功能应该是比较完善的，只是稍微有一点不足是没有支持 arm 版本</p><p>所以之后那位同事还是用虚拟机的方式，手动部署 Hadoop 搭建好了本地测试集群，省不了的是一些手动配置的操作，虽然也不会太复杂</p><p>而自己的想法是: 既然已经接触了除了 hdfs 之外的上层应用，比如 knox、ranger 等，是否可以按照之前部署 zk 集群的思路<sup><font color='#49E844'>[3]</font></sup>，把 hadoop 基础集群也写到 docker compose 里面呢？</p><p>于是，接近两个月的各种踩坑和实践开始了</p><h2 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h2><h3 id="服务部署"><a href="#服务部署" class="headerlink" title="服务部署"></a>服务部署</h3><p>两种部署方式: 从头开始搭建镜像 再启动服务 or 直接从 dockerhub 拉取镜像并启动服务，通过前者有助于你了解镜像结构，但是如果是想快速部署服务建议参考后者</p><p>【建议】直接拉取镜像:<br>为了方便使用，我已经将镜像提交到 dockerhub (mzsmieli/centos_hdfs_full)，直接拉取并启动即可</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 下载镜像</span></span><br><span class="line">docker pull mzsmieli/centos_hdfs_full:v1.0.0</span><br><span class="line">docker pull mzsmieli/centos_mysql:v1.0.0</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 运行hdfs集群</span></span><br><span class="line">REPO=mzsmieli make run_hdfs_cluster</span><br></pre></td></tr></table></figure><p>构建镜像:<br>下载工程 docker-centos 后，需要依次准备以下镜像:</p><ul><li>centos_base<ul><li>centos 基础环境镜像</li></ul></li><li>centos_java<ul><li>java 基础镜像</li></ul></li><li>centos_hdfs<ul><li>hdfs 基础镜像，包含 hadoop 服务，依赖 java 镜像</li></ul></li><li>centos_hive<ul><li>hive 基础镜像，包含 hadoop、hive 服务，依赖 hdfs 镜像</li></ul></li><li>centos_knox<ul><li>knox 镜像，依赖 java 镜像</li></ul></li><li>centos_hdfs_full<ul><li>完整 hadoop 镜像，在 hdfs+hive+knox 基础上提供 flink、spark</li></ul></li><li>centos_minimal<ul><li>centos 部署服务最小镜像</li></ul></li><li>centos_mysql<ul><li>mysql 镜像，依赖 minimal</li></ul></li></ul><p>镜像整体架构图:<br><img src="/2022/08/13/dockerfile-compose-hdfs/hdfs_image.png" alt="hdfs_image"></p><p>概括来说就是 <strong>centos 基础镜像 -&gt; 各语言开发镜像 -&gt; 服务镜像</strong></p><p>完整指令:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 构建镜像（首次构建所有镜像大约需要半个小时）</span></span><br><span class="line">make build_hdfs_cluster</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 运行hdfs集群</span></span><br><span class="line">make run_hdfs_cluster</span><br></pre></td></tr></table></figure><p>端口和地址说明:</p><ul><li><strong>8443</strong>: knox 网关地址<ul><li><a href="http://localhost:8443/gateway/sandbox/yarn">http://localhost:8443/gateway/sandbox/yarn</a></li><li><a href="http://localhost:8443/gateway/sandbox/hdfs">http://localhost:8443/gateway/sandbox/hdfs</a></li></ul></li><li><strong>8088</strong>: hdfs resourcemanager web 地址（yarn）<ul><li><a href="http://localhost:8088/">http://localhost:8088</a></li></ul></li><li><strong>50070</strong>: hdfs namenode web 地址（data）<ul><li><a href="http://localhost:50070/">http://localhost:50070</a></li></ul></li><li><strong>10000</strong>: hive server 地址</li><li><strong>33306</strong>: mysql 端口</li></ul><h3 id="hdfs"><a href="#hdfs" class="headerlink" title="hdfs"></a>hdfs</h3><p><img src="/2022/08/13/dockerfile-compose-hdfs/hdfs_hdfs_datanode.png" alt="hdfs_hdfs_datanode"></p><h3 id="yarn"><a href="#yarn" class="headerlink" title="yarn"></a>yarn</h3><p><img src="/2022/08/13/dockerfile-compose-hdfs/hdfs_yarn_total.png" alt="hdfs_yarn_total"></p><h3 id="flink、spark"><a href="#flink、spark" class="headerlink" title="flink、spark"></a>flink、spark</h3><p>提交任务这块做了简单的提交验证</p><p>提交 flink 任务:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd /opt/modules/flink-1.15.0</span><br><span class="line">./bin/flink run -m yarn-cluster ./examples/batch/WordCount.jar</span><br></pre></td></tr></table></figure><p><img src="/2022/08/13/dockerfile-compose-hdfs/hdfs_flink_web.png" alt="hdfs_flink_web"></p><p>提交 spark 任务:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/opt/modules/spark/bin/spark-submit --master yarn --deploy-mode cluster --class org.apache.spark.examples.SparkPi /opt/modules/spark/examples/jars/spark-examples_2.12-3.2.2.jar 100</span><br></pre></td></tr></table></figure><p><img src="/2022/08/13/dockerfile-compose-hdfs/hdfs_spark_yarn.png" alt="hdfs_spark_yarn"></p><h3 id="hive"><a href="#hive" class="headerlink" title="hive"></a>hive</h3><p>hive 可通过 开源数据库客户端工具，dbeaver<sup><font color='#49E844'>[4]</font></sup> 直接连接，注意需要填用户名，否则可能会因为权限问题无法执行 SQL</p><p><img src="/2022/08/13/dockerfile-compose-hdfs/hdfs_hive_connect.png" alt="hdfs_hive_connect"></p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h3 id="组件版本"><a href="#组件版本" class="headerlink" title="组件版本"></a>组件版本</h3><p>hdfs - 3.3.2<br>knox - 1.6.1<br>hive - 3.1.2<br>flink - 1.15<br>spark - 3.2</p><p>其中 <strong>knox</strong><sup><font color='#49E844'>[5]</font></sup> 是大数据组件通用的网关服务，可以用于配置统一代理、身份认证、单点登录等，一般是刚搭建大数据集群的时候需要装，后续就不需要怎么管了。其他服务比较核心</p><h3 id="hadoop"><a href="#hadoop" class="headerlink" title="hadoop"></a>hadoop</h3><p>基本的安装和配置，参考网上的教程<sup><font color='#49E844'>[6]</font></sup>做就行。为了能在一个镜像中同时支持单点和集群启动，dockerfile 中做了通过识别容器启动环境参数，进行不同的初始化和服务启动的功能：在容器的启动参数中指定 <strong>-e HDFS_START=hdfsstart / hdfsstartall</strong>，即可区分</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"># Dockerfiles/emr/hdfs/scripts/hdfs-start.sh</span><br><span class="line"># 单点启动 hdfs 服务脚本</span><br><span class="line"></span><br><span class="line">## 服务启动指令（本地启动 namenode、datanode、resourcemanager）</span><br><span class="line">./sbin/start-dfs.sh</span><br><span class="line">./sbin/start-yarn.sh</span><br><span class="line"></span><br><span class="line"># Dockerfiles/emr/hdfs/scripts/hdfs-start-all.sh</span><br><span class="line"># 启动 hdfs 集群脚本</span><br><span class="line"></span><br><span class="line">## 配置: /etc/hadoop/conf/workers</span><br><span class="line">hadoop2</span><br><span class="line">hadoop3</span><br><span class="line"></span><br><span class="line">## 服务启动指令（主节点启动 namenode、resourcemanager，worker 节点启动 datanode、nodemanager）</span><br><span class="line">./sbin/start-all.sh</span><br></pre></td></tr></table></figure><h3 id="knox"><a href="#knox" class="headerlink" title="knox"></a>knox</h3><p>knox 主要是配置需要留意，大体分为 knox 本身的服务配置、网关配置 和 代理的服务配置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"># knox配置</span><br><span class="line">## /opt/modules/knox/conf/gateway-site.xml</span><br><span class="line">### 禁用 ssl 和 身份认证，方便调试</span><br><span class="line">&lt;property&gt;</span><br><span class="line">    &lt;name&gt;ssl.enabled&lt;/name&gt;</span><br><span class="line">    &lt;value&gt;false&lt;/value&gt;</span><br><span class="line">&lt;/property&gt;</span><br><span class="line"></span><br><span class="line">&lt;provider&gt;</span><br><span class="line">    &lt;role&gt;identity-assertion&lt;/role&gt;</span><br><span class="line">    &lt;name&gt;Default&lt;/name&gt;</span><br><span class="line">    &lt;enabled&gt;disable&lt;/enabled&gt;</span><br><span class="line">&lt;/provider&gt;</span><br><span class="line"></span><br><span class="line"># 网关配置</span><br><span class="line">## /opt/modules/knox/conf/topologies/sandbox.xml</span><br><span class="line">### hdfs 和 yarn 地址，因为 namenode 和 knox 都部署在主节点，所以这里配的都是 localhost</span><br><span class="line">&lt;service&gt;</span><br><span class="line">    &lt;role&gt;HDFSUI&lt;/role&gt;</span><br><span class="line">    &lt;url&gt;http://localhost:50070&lt;/url&gt;</span><br><span class="line">    &lt;version&gt;2.7.0&lt;/version&gt;</span><br><span class="line">&lt;/service&gt;</span><br><span class="line"></span><br><span class="line">&lt;service&gt;</span><br><span class="line">    &lt;role&gt;YARNUI&lt;/role&gt;</span><br><span class="line">    &lt;url&gt;http://localhost:8088&lt;/url&gt;</span><br><span class="line">&lt;/service&gt;</span><br><span class="line"></span><br><span class="line"># 代理服务配置</span><br><span class="line">## /opt/modules/knox/data/services/hdfsui/2.7.0/rewrite.xml</span><br><span class="line">### 这里需要加个规则: 因为 hdfs 的 index.html 页面实际是一个 跳转页面（&lt;a&gt; 元素），而直接访问</span><br><span class="line">### 这个地址会被链接到容器环境内部域名（hadoop1），而不是外部域名（localhost:8443）导致在外部访问跳转失败</span><br><span class="line">### 因此一个最直接的解决方式就是将 index.html 直接链接到 dfshealth.html 让 knox 帮我们做这个跳转，保持外部域名（gateway.url）</span><br><span class="line"></span><br><span class="line">&lt;rule dir=&quot;OUT&quot; name=&quot;HDFSUI/redirect&quot; pattern=&quot;/index.html&quot;&gt;</span><br><span class="line">  &lt;rewrite template=&quot;&#123;gateway.url&#125;/hdfs/dfshealth.html&quot;/&gt;</span><br><span class="line">&lt;/rule&gt;</span><br></pre></td></tr></table></figure><h3 id="hive-1"><a href="#hive-1" class="headerlink" title="hive"></a>hive</h3><p>hive 服务启动前，需要做初始化 mysql 的操作，涉及到两个细节：hive 初始化脚本 init-hive.sh 中，需要执行 schematool 进行元数据初始化；compose 文件中也要定义 主节点，也是 hive 启动的节点，需要依赖 mysql 容器（depends_on）</p><h3 id="compose"><a href="#compose" class="headerlink" title="compose"></a>compose</h3><p>各个组件都准备完成后，对 compose 配置文件的编写主要就是设置容器启动的环境变量了</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&quot;3.9&quot;</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">hadoop1:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">$&#123;HDFS_FULL_IMAGE&#125;</span></span><br><span class="line">    <span class="attr">hostname:</span> <span class="string">hadoop1</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="comment"># hdfs 主节点配置</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">DEFAULTFS=hdfs://hadoop1:8020</span> <span class="comment"># 主节点地址: 即 hadoop1 地址</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">DFS_REPLICATION=2</span> <span class="comment"># 两个 worker 节点</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">RESOURCEMANAGER_HOSTNAME=hadoop1</span> <span class="comment"># rm 节点: 依然是 hadoop1</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">WORKERS=hadoop2,hadoop3</span> <span class="comment"># worker 节点具体域名，会在 init-hdfs.sh 脚本中解析</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">HDFS_START=hdfsstartall</span> <span class="comment"># hadoop 启动方式: 集群模式</span></span><br><span class="line">      <span class="comment"># knox 配置</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">KNOX_START=knoxstart</span> <span class="comment"># 是否启动</span></span><br><span class="line">      <span class="comment"># hive 配置</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">HIVE_START=hivestart</span> <span class="comment"># 是否启动</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">mysql_host=mysql</span> <span class="comment"># mysql 配置，用于存储元数据</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">mysql_port=3306</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">mysql_db=hive</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">mysql_user=root</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">mysql_pwd=root_HADOOP_123</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="comment"># 主节点需要开放各主要节点的端口</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;8443:8443&quot;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;8088:8088&quot;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;50070:50070&quot;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;10000:10000&quot;</span></span><br><span class="line">    <span class="attr">depends_on:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">hadoop2</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">hadoop3</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">mysql</span></span><br><span class="line">  <span class="attr">hadoop2:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">$&#123;HDFS_FULL_IMAGE&#125;</span></span><br><span class="line">    <span class="attr">hostname:</span> <span class="string">hadoop2</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="comment"># hdfs worker 节点配置</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">DEFAULTFS=hdfs://hadoop1:8020</span> <span class="comment"># 主节点地址</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">DFS_REPLICATION=2</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">RESOURCEMANAGER_HOSTNAME=hadoop1</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">WORKERS=hadoop2,hadoop3</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">HDFS_START=hdfsnotstart</span> <span class="comment"># worker 节点不主动启动 hdfs，由主节点触发</span></span><br><span class="line">  <span class="attr">hadoop3:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">$&#123;HDFS_FULL_IMAGE&#125;</span></span><br><span class="line">    <span class="attr">hostname:</span> <span class="string">hadoop3</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">DEFAULTFS=hdfs://hadoop1:8020</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">DFS_REPLICATION=2</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">RESOURCEMANAGER_HOSTNAME=hadoop1</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">WORKERS=hadoop2,hadoop3</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">HDFS_START=hdfsnotstart</span></span><br><span class="line">  <span class="attr">mysql:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">$&#123;MYSQL_IMAGE&#125;</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;33306:3306&quot;</span></span><br><span class="line">    <span class="comment"># mysql 节点配置</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">ROOT_PASSWORD=root_HADOOP_123</span> <span class="comment"># root 账号密码</span></span><br></pre></td></tr></table></figure><h3 id="提交镜像"><a href="#提交镜像" class="headerlink" title="提交镜像"></a>提交镜像</h3><p>在实践的过程中发现 基于 Dockerfile 在分享上也不是特别方便，比如新来的同学想使用 dev_full 完整开发镜像，他还需要在自己的电脑上先重新构建一次镜像。更好的方法还是通过镜像仓库直接分享镜像<br>因此后面把自己的镜像都提交到了 dockerhub 中，包括之前做的 easyconnect<sup><font color='#49E844'>[7]</font></sup> 代理镜像、dev_full<sup><font color='#49E844'>[8]</font></sup> 包含多种开发语言的开发镜像<br>构建方式: 通过 <strong>buildx</strong><sup><font color='#49E844'>[9]</font></sup> 工具构建</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 示例: 构建并提交 base 镜像，同时构建 arm 和 amd 版本</span></span><br><span class="line">docker buildx build --platform linux/arm64,linux/amd64 --no-cache -f ./Dockerfiles/system/centos_base.Dockerfile -t dockerhub账号名/centos_base:v1.0 ./Dockerfiles/system --push</span><br></pre></td></tr></table></figure><p>在 dockerhub 查看刚提交的镜像:<br><img src="/2022/08/13/dockerfile-compose-hdfs/hdfs_dockerhub.png" alt="hdfs_dockerhub"></p><p>扩展: 运行 easyconnect 镜像</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 使用 easyconnect 镜像</span></span><br><span class="line">REPO=mzsmieli make run_rc</span><br><span class="line"><span class="meta">#</span><span class="bash"> 将下载 mzsmieli/centos_easyconnect:v1.0.0</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 完整指令</span></span><br><span class="line">docker pull mzsmieli/centos_easyconnect:v1.0.0</span><br><span class="line">docker run -it -d --privileged=true --platform linux/amd64 --hostname test_ec --name dev_ec -p 3389:3389 -p 7881:7881 mzsmieli/centos_easyconnect:v1.0.0 /usr/sbin/init</span><br><span class="line"><span class="meta">#</span><span class="bash"> vnc 默认密码: root/root_123</span></span><br></pre></td></tr></table></figure><h2 id="后言"><a href="#后言" class="headerlink" title="后言"></a>后言</h2><p>坚信搞好属于自己的一套开发环境是学习任何新技术的基础，工欲善其事，必先利其器</p><p>这篇博客也仅仅是将个人习惯的开发环境 分享一下，每个人肯定都有自己的习惯，不存在谁比谁更好，只要能达到自己想要的学习效果，都是好方法。开发镜像也是，IDE 也是，开发语言也是。总是陷入对 世界上最好语言的争论，真的没必要</p><p>当然，在自己整完这些东西之后，再次感觉到 应该喘口气，思考自己想做的下个东西是什么了</p><h2 id="资料"><a href="#资料" class="headerlink" title="资料"></a>资料</h2><p>[1] <a href="https://zhuanlan.zhihu.com/p/421375012">使用 Docker 快速部署 Spark + Hadoop 大数据集群</a></p><p>[2] <a href="https://github.com/s1mplecc/spark-hadoop-docker">git-spark-hadoop-docker</a></p><p>[3] <a href="https://mp.weixin.qq.com/s/4wT_C4Qvywwmh1a9edktxA">通过 Docker Compose 本地启动 zk 集群</a></p><p>[4] <a href="https://github.com/dbeaver/dbeaver">dbeaver</a></p><p>[5] <a href="https://knox.apache.org/books/knox-1-6-0/user-guide.html">knox官方文档</a></p><p>[6] <a href="https://segmentfault.com/a/1190000038508026?utm_source=sf-similar-article">Hadoop集群的部署（二）</a></p><p>[7] <a href="https://smiecj.com/2022/06/10/easyconnect-centos/">EasyConnect 代理工具容器化运行</a></p><p>[8] <a href="https://hub.docker.com/r/mzsmieli/centos_dev_full">dev_full image</a></p><p>[9] <a href="https://github.com/docker/buildx">docker buildx</a></p>]]></content>
      
      
      <categories>
          
          <category> 开发工具 </category>
          
          <category> docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> docker </tag>
            
            <tag> 大数据 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>EasyConnect 代理工具容器化运行</title>
      <link href="/2022/06/10/easyconnect-centos/"/>
      <url>/2022/06/10/easyconnect-centos/</url>
      
        <content type="html"><![CDATA[<p><a href="https://mp.weixin.qq.com/s/r1pOM7CoSMx4-L2GVqNoxg">公众号</a><br><a href="https://blog.csdn.net/xiaoliizi/article/details/125231965">csdn</a></p><h2 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h2><p>目前代理镜像已提交到 dockerhub，可直接使用</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker pull mzsmieli/centos_easyconnect:v1.0.0</span><br><span class="line">docker run -it -d --privileged=true --platform linux/amd64 --hostname test_ec --name dev_ec -p 3389:3389 -p 7881:7881 mzsmieli/centos_easyconnect:v1.0.0 /usr/sbin/init</span><br><span class="line"><span class="meta">#</span><span class="bash"> vnc 默认密码: root/root_123</span></span><br></pre></td></tr></table></figure><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p><strong>EasyConnect</strong> 作为很多国内公司和学校用的代理软件，对上班族和学生党来说还是经常用到的。但是作为一个商用代理软件 ，EasyConnect 并没有开源，而且代理是系统级别的，主机的所有流量都会经过被 EC 进程代理。你也不知道它劫持了流量之后到底做了啥</p><p>偶然一天了解到有人已经通过 虚拟机方式 成功启动 easyConnect（git-hagb-docker-easyconnect[1]），相当于把 EasyConnect 运行在一个完全独立的环境，对流量安全来说确实是更好的。只是适配Arm 系统会有一些问题，比如内存占用太高，作者也提供了一些解决思路，不过需要使用者自行尝试<br>0906 更新: 似乎作者已经解决了内存泄漏的问题，有时间可以尝试下，<a href="https://github.com/Hagb/docker-easyconnect/commit/e13ece4db1fb672dd37e2d2d92a0a462d092aff1">commit记录</a></p><p>所以一不做二不休，自己动手尝试了使用 centos 系统封装 EasyConnect，并成功测试只让公司流量走 EC 代理。比较不足的点也就是手动配置有一定成本。不过从结果来看还是不错的，至少动手过程中也了解到了一些技术点，最后也写下了这篇博客让大家都可以参考快速配置一下</p><p>最后谈一下使用建议：如果你是学生党，那比较推荐通过开源项目 docker-easyconnect 来开启代理，主要是能够少折腾</p><p>但如果你是上班族，那就建议自己鼓捣一下。本文提供的思路应该是一个不错的选择，原理和开源项目也差不多</p><p>环境说明：<br>主机: Docker Desktop on Mac<br>基础镜像: centos 8（platform: amd64）<br>容器内安装的软件: EasyConnect 麒麟系统版本（兼容 centos）、firefox、clash、xrdp（提供远程桌面，用于打开 EasyConnect 并登录）</p><h2 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h2><h3 id="构建镜像"><a href="#构建镜像" class="headerlink" title="构建镜像"></a>构建镜像</h3><p>这边把用于代理的镜像构建过程提交到 (git-docker-centos-ec.Dockerfile[2]) 了，拉取代码后即可构建</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># 构建镜像</span></span></span><br><span class="line">make build_xrdp</span><br><span class="line"></span><br><span class="line">make build_ec</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># 运行</span></span></span><br><span class="line">make run_ec</span><br></pre></td></tr></table></figure><h3 id="启动容器和服务"><a href="#启动容器和服务" class="headerlink" title="启动容器和服务"></a>启动容器和服务</h3><p><img src="/2022/06/10/easyconnect-centos/ec05.png" alt="login ec"></p><p><img src="/2022/06/10/easyconnect-centos/ec06.png" alt="clash"></p><p><img src="/2022/06/10/easyconnect-centos/ec07.png" alt="内网服务"></p><p>下面具体说一下是怎么实现的</p><h2 id="centos-系统初始化"><a href="#centos-系统初始化" class="headerlink" title="centos 系统初始化"></a>centos 系统初始化</h2><h3 id="安装远程桌面"><a href="#安装远程桌面" class="headerlink" title="安装远程桌面"></a>安装远程桌面</h3><p>桌面的主要目的是登录 EC，EC 必须通过界面 输入公司域账号密码登录<br>Linux 常见的远程桌面软件有 <strong>xrdp</strong> 和 <strong>vnc</strong> ，这边使用 xrdp 进行安装和连接</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 安装 xrdp</span></span><br><span class="line">yum -y install xrdp</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 安装 xfce</span></span><br><span class="line">yum -y groupinstall Xfce</span><br><span class="line"></span><br><span class="line">echo &quot;xfce4-session&quot; &gt; ~/.Xclients</span><br><span class="line">chmod +x ~/.Xclients</span><br><span class="line"></span><br><span class="line">systemctl enable xrdp</span><br><span class="line">systemctl start xrdp</span><br></pre></td></tr></table></figure><p>Mac 和 Windows 系统都可以通过 <strong>Microsoft Remote Desktop</strong> 连接<br><img src="/2022/06/10/easyconnect-centos/ec02.png" alt="connect"></p><p><img src="/2022/06/10/easyconnect-centos/ec03.png" alt="desktop"></p><p>windows 系统有一点特殊: 通过 127.0.0.1 连接本地会提示 “原因是你正在运行一个控制台会话” ，需要连接 <strong>127.0.0.2</strong> ，本质上这两个 ip 都是本机地址</p><h3 id="可选-firefox"><a href="#可选-firefox" class="headerlink" title="可选-firefox"></a>可选-firefox</h3><p>这里装浏览器只是用来测试容器内代理是否生效。安装了 clash 之后也可以在主机测试代理，可以不装<br>chrome([3]) 和 firefox([4]) 这种主流的浏览器都支持在 centos 上安装。我一开始装的 chrome 但是重启过容器之后就发现打不开了。可能是 chrome 太吃内存导致起不来，后面换 firefox 就没遇到这个问题</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 下载 firefox，解压后直接打开 ./firefox/firefox 即可</span></span><br><span class="line">wget https://download-installer.cdn.mozilla.net/pub/firefox/releases/101.0/linux-x86_64/en-US/firefox-101.0.tar.bz2</span><br><span class="line">tar -jxvf firefox-101.0.tar.bz2</span><br></pre></td></tr></table></figure><h2 id="EasyConnect"><a href="#EasyConnect" class="headerlink" title="EasyConnect"></a>EasyConnect</h2><p>在容器内安装 EC 也不是特别复杂，选对和系统匹配的版本就行</p><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 下载 &amp; 安装</span></span><br><span class="line">wget http://download.sangfor.com.cn/download/product/sslvpn/pkg/linux_767/EasyConnect_x64_7_6_7_3.rpm</span><br><span class="line">rpm -ivh EasyConnect_x64_7_6_7_3.rpm</span><br></pre></td></tr></table></figure><p>安装后会自动配置成开机启动，你也能通过 ps 看到 <strong>ECAgent</strong> 和 <strong>EasyMonitor</strong> 进程，分别是流量代理 和 自监控服务</p><p><img src="/2022/06/10/easyconnect-centos/ec04.png" alt="ec process"></p><p>其中 <strong>qemu</strong> 可以理解为虚拟化的实现接口，适配 Mac Arm 系列。还有其他实现方式，对应不同的虚拟机软件，比如 vmware、hyper-v 等</p><h3 id="ECAgent-进程定期强制清理"><a href="#ECAgent-进程定期强制清理" class="headerlink" title="ECAgent 进程定期强制清理"></a>ECAgent 进程定期强制清理</h3><p>通过 qemu 启动的 EC 会有内存泄漏的问题：随着运行容器的内存占用越来越大。这个问题可以参考 Hagb 作者对部分 issue 的回复([5])。彻底解决可能需要修改系统调用，简单解决的话，写个 crontab 定期清理 ECAgent 就行，ECMonitor 会自动把它拉起来，这些都是 EasyConnect 自带的进程</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 每个小时重启一次 ECAgent 进程</span></span><br><span class="line">RUN echo &quot;0 * * * * nohup ps -ef | grep ECAgent | grep -v grep | awk &#x27;&#123;print $2&#125;&#x27; | xargs  kill -9&quot; &gt;&gt; /var/spool/cron/root</span><br></pre></td></tr></table></figure><h2 id="Clash"><a href="#Clash" class="headerlink" title="Clash"></a>Clash</h2><p>把 EC 通过 容器启动起来之后，我们就完成了大头了。接下来的关键就是要分别在容器和主机开启代理，将公司内网的流量指向容器内，非公司内网流量还是正常走。这样才能让主机正常的流量不被 EC 劫持<br>clash 的完整配置可参考官方wiki([6])</p><h3 id="容器内部-服务端"><a href="#容器内部-服务端" class="headerlink" title="容器内部-服务端"></a>容器内部-服务端</h3><p>安装 linux 版本的 <strong>clash</strong> 并设置 sock5 代理端口作为服务端即可，对应前面 启动容器 开放的 7881 端口</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 下载 clash linux 版</span></span><br><span class="line">wget https://github.com/Dreamacro/clash/releases/download/v1.10.6/clash-linux-amd64-v1.10.6.gz</span><br><span class="line">gzip -d clash-linux-amd64-v1.10.6.gz &amp;&amp; mv clash-linux-amd64-v1.10.6 clash &amp;&amp; chmod +x clash</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 启动方式</span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># 第一次启动需要下载国家名称和位置信息(https://cdn.jsdelivr.net/gh/Dreamacro/maxmind-geoip@release/Country.mmdb)，启动会比较慢</span></span></span><br><span class="line">./clash -d .</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> config.yaml, 需要和 clash 可执行文件放到同一个目录</span></span><br><span class="line">mixed-port: 7890</span><br><span class="line">external-controller: 127.0.0.1:9090</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># 这三个配置对应 sock5 代理地址</span></span></span><br><span class="line">allow-lan: true</span><br><span class="line">bind-address: 0.0.0.0</span><br><span class="line">socks-port: 7881</span><br></pre></td></tr></table></figure><h3 id="主机-客户端"><a href="#主机-客户端" class="headerlink" title="主机-客户端"></a>主机-客户端</h3><p>以域名作为规则，配置转发规则 + 转发目标端口即可</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">proxies:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">socks5_ec</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">socks5</span></span><br><span class="line">    <span class="attr">server:</span> <span class="string">localhost</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">7881</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># proxy 分组，只用于展示</span></span><br><span class="line"><span class="attr">proxy-groups:</span></span><br><span class="line">  <span class="string">......</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 规则配置，特定域名转发到对应 proxy</span></span><br><span class="line"><span class="attr">rules:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,内网域名,socks5_ec</span></span><br><span class="line">  <span class="string">......</span></span><br></pre></td></tr></table></figure><p>另外 git 、ssh 的协议还需要单独在 ~/.ssh/config 中 配置转发规则</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> vim ~/.ssh/config</span></span><br><span class="line">Host *内网域名</span><br><span class="line">  ProxyCommand nc -x localhost:主机的sock代理端口 %h %p</span><br></pre></td></tr></table></figure><h3 id="其他配置-容器内部-etc-hosts"><a href="#其他配置-容器内部-etc-hosts" class="headerlink" title="其他配置-容器内部-/etc/hosts"></a>其他配置-容器内部-/etc/hosts</h3><p>后面调试的时候发现部分内网域名无法正常代理，大概率是 <strong>DNS</strong> 的问题: EC 装在主机的时候，<strong>主机的 DNS 被注入了内网解析的策略</strong>，诸如 gitlab.公司内网域名 这种地址，才能被正常解析。但是通过 主机 -&gt; 容器 -&gt; clash -&gt; EC 的方式，DNS 似乎就没有被注入策略，需要手动配置 /etc/hosts，将域名和 ip 的关系硬写进去才行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># /etc/hosts</span><br><span class="line"># git</span><br><span class="line">内网ip gitlab.内网域名.com</span><br><span class="line">......</span><br></pre></td></tr></table></figure><h2 id="主机-EC-卸载"><a href="#主机-EC-卸载" class="headerlink" title="主机 EC 卸载"></a>主机 EC 卸载</h2><p>网上有不少人说EC很难卸载干净，实际尝试确实如此，需要好几步，好在已经有人整理了([7])，参考着来做就行</p><p>卸载前: 即便主机没有开代理，都有三个进程在后台运行<br>– ECAgentProxy 在 Linux 版本的 EC 上没有这个进程，不确定是做啥的</p><p><img src="/2022/06/10/easyconnect-centos/ec08.png" alt="ec process on mac"></p><p>卸载步骤:</p><ul><li><p>sudo su 进入管理员模式</p></li><li><p>删除 /Library/LaunchDaemons/com.sangfor.EasyMonitor.plist</p></li></ul><p>其中 <strong>plist</strong>([8]) 是 Mac 系统用来设置启动项的工具，相当于 linux 的 systemd<br>这里相当于删除了 EC 的开机启动项</p><p><img src="/2022/06/10/easyconnect-centos/ec09.png" alt="ECMonitor"><br>– ECMonitor 启动项，声明了启动程序位置</p><ul><li><p>删除 /Library/LaunchAgents/com.sangfor.ECAgentProxy.plist</p></li><li><p>打开钥匙串，找到深信服添加的根证书(搜索 sang)，删除</p></li></ul><p><img src="/2022/06/10/easyconnect-centos/ec10.png" alt="删除钥匙串"></p><ul><li>删除应用<br>直接删除 /Applications/EasyConnect.app 整个目录即可</li></ul><p>Windows 系统的卸载方式可以参考 Hagb 作者写的知乎([9])</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>做完了这些东西，还是很有成就感的，有一种看上去非常朴素的乐高，但稍加想象力和努力，就能够拼成各种建筑，而且过程中也能学到很多东西</p><p>还要特别感谢一个同事，平时他总能有各种意想不到的点子，经常关注新软件和新技术。这个需求的灵感也是来自于他</p><p>总之，对一些软件对系统不合理的侵入，确实应该想办法解决。现在已经不是资源吃紧的时代了，电脑卡往往有一部分原因是使用者没有注意一些细节。从一开始就杜绝软件对系统权限、流量、文件不合理的申请或使用，会比后面回过头再清理方便太多</p><p>希望后面还能发现更多软件的问题，多解决多总结~</p><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><p>[1] <a href="https://github.com/Hagb/docker-easyconnect">开源方案</a></p><p>[2] <a href="https://github.com/smiecj/docker-centos/blob/main/Dockerfiles/net/ec/easyconnect.Dockerfile">docker-centos easyconnect.Dockerfile</a></p><p>[3] <a href="https://segmentfault.com/a/1190000022425145">CentOS 7安装谷歌浏览器</a></p><p>[4] <a href="https://linuxconfig.org/how-to-install-firefox-on-redhat-8">How to install latest Firefox browser on RHEL 8 / CentOS 8 Workstation</a></p><p>[5] <a href="https://github.com/Hagb/docker-easyconnect/issues/120#issue-1148054348">issue-MAC M1 pro是否有合适的版本 #120</a></p><p>[6] <a href="https://github.com/Dreamacro/clash/wiki/configuration">clash官方配置教程</a></p><p>[7] <a href="https://www.v2ex.com/t/762221">Mac 删除深信服 EasyConnect 的 EasyMoniter、ECAgent 的开机启动和根证书的方法</a></p><p>[8] <a href="https://www.fythonfang.com/blog/2021/4/19/mac-launchd-daemons-and-agents-tutorial">Mac Launchd 介绍和使用</a></p><p>[9] <a href="https://zhuanlan.zhihu.com/p/389894063">用docker封印EasyConnect并连接远程桌面和数据库</a></p><p>[10] <a href="https://superuser.com/a/1500416">RDP to computer from same computer fails. Why?</a></p>]]></content>
      
      
      <categories>
          
          <category> 开发工具 </category>
          
          <category> 代理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> docker </tag>
            
            <tag> 开发工具 </tag>
            
            <tag> 代理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vscode 使用技巧闲谈</title>
      <link href="/2022/05/31/vscode-tools/"/>
      <url>/2022/05/31/vscode-tools/</url>
      
        <content type="html"><![CDATA[<h2 id="关于-vscode"><a href="#关于-vscode" class="headerlink" title="关于 vscode"></a>关于 vscode</h2><p>如果我们对一个开发者问你平时 <strong>首选 IDE</strong> 是什么，不同语言的开发者估计回答都会不太一样。对于后台来说，近几年比较热门的无疑就是 <strong>Jetbrains</strong> 全家桶系列了，java 用 Idea，go 用 goland，Python 用 PyCharm，体验本身无疑是很棒的。前端开发选择 vscode 就比较多了，主要原因可能是插件支持更完善，而且 vscode 本身就是用 TypeScript 写的。当然还有一些在几年前辉煌过的 Eclipse、Visual Studio Code 等，在一些特定的开发场景还是有一席之地的</p><p>那么自己作为后台开发，为什么自己要“反其道而行之” 选择 vscode 呢，主要有两个原因:</p><ul><li>自己的开发环境并不在本地宿主机，而是在容器内（参考: 仓库 docker-centos），要用容器环境一个最直接的方式就是类似连接远程机器那样，用 ssh remote，而目前来说 vscode 对这种模式支持比较好（也和 vscode 的插件机制相关，插件相当于开发环境，可以安装到远程机器，天生就对这种开发模式适配较好）</li><li>工作和个人习惯相关，需要经常<strong>在不同的开发环境之间切换</strong>，比如这会需要跑一个 golang 后台服务，过了几分钟突然一个 java 相关的需求来了。如果用 JetBrain 全家桶，就必须在不同软件（虽然操作逻辑类似）之间切换。而用 vscode 就不需要来回切换操作逻辑，很顺手</li></ul><p>讲到这里，也要提提 vscode + ssh remote 这种模式的缺点</p><ul><li>性能不如主机模式<br>如果是本机开发，其实直接用 <strong>JetBrains</strong> 就够了， 相当于直接用本地环境，比用容器开发肯定性能会好很多。像我现在开发的时候，电脑主机内存占用60-70算是家常便饭</li><li>熟练门槛高<br>对于我现在的开发模式来说除了本身的开发语言之外，还需要了解一些Docker相关的基本操作，还有 vscode 的快捷键（这个非常重要，说他是 vscode 的灵魂也不为过，快捷键用的少开发效率直接减半）、各个开发语言的插件和配置等</li><li>特定编程语言下功能不如 Jetbrains 系列<br>比如 Idea 可以直接下载和查看源码，vscode 只能查看编译后的 class 文件（虽然也是代码格式，但是少了注释，读开源项目的时候还是比较费劲）</li></ul><p>因此这篇文章依然算是<strong>安利</strong>的，比较实用的干货的地方，就是结合自己的经验推荐一下好用的 vscode 插件了。至于其他的技巧，就得看个人的使用习惯，我的方法也不一定适用于其他人</p><p>如果你觉得上面使用 vscode 的好处，比较契合自己的习惯，而且不太在乎其带来的影响，那么就可以动手尝试一下了。当然有使用上的感想也欢迎和我私信交流</p><p><img src="/2022/05/31/vscode-tools/vscode15.png" alt="show"></p><h2 id="常用快捷键"><a href="#常用快捷键" class="headerlink" title="常用快捷键"></a>常用快捷键</h2><p>注意: 一些键位我是改过的，因此还是要看个人习惯</p><table><thead><tr><th>快捷键</th><th>功能</th></tr></thead><tbody><tr><td>Command + Control + &lt;-</td><td>跳转到上一个位置</td></tr><tr><td>Command + Control + -&gt;</td><td>跳转到上一个位置</td></tr><tr><td>Control + `</td><td>打开终端</td></tr><tr><td>Command + Shift + P</td><td>插件功能列表</td></tr><tr><td>Command + Shift + F</td><td>全局搜索</td></tr><tr><td>Command + Shift + O</td><td>当前文件/类的所有方法</td></tr><tr><td>Command + P</td><td>打开当前项目的指定文件</td></tr><tr><td>Command + R</td><td>打开最近项目</td></tr><tr><td>Control + G</td><td>跳到指定行</td></tr><tr><td>F5</td><td>开始 debug</td></tr><tr><td>Shift + F5</td><td>结束 debug</td></tr></tbody></table><h2 id="ssh-remote"><a href="#ssh-remote" class="headerlink" title="ssh remote"></a>ssh remote</h2><h3 id="插件安装"><a href="#插件安装" class="headerlink" title="插件安装"></a>插件安装</h3><p><img src="/2022/05/31/vscode-tools/vscode01.png" alt="ssh remote plugin"></p><h3 id="开发环境准备"><a href="#开发环境准备" class="headerlink" title="开发环境准备"></a>开发环境准备</h3><p>开发环境可以是一个远程宿主机，也可以是你本地的 container 环境<br>这里还是以 容器环境为例</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 启动容器</span><br><span class="line">docker run -d --hostname dev --name dev -p 2000:22 centos_dev_full</span><br></pre></td></tr></table></figure><p>连接开发机</p><p><img src="/2022/05/31/vscode-tools/vscode02.png" alt="ssh remote connect"></p><p>输入账号密码之后，就可以顺利进行 vscode + ssh remote 模式开发了。不过体验上我们还可以继续优化一下</p><h3 id="ssh-key"><a href="#ssh-key" class="headerlink" title="ssh key"></a>ssh key</h3><p>如果不配置免密登录，每次打开一个新项目（新的代码地址），都需要输入一次，下次打开也还要，非常麻烦<br>所以这里我们把主机的公钥配置到开发机的 ~/.ssh/authorized_keys 中，后续不再输入密码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># linux 生成公钥</span><br><span class="line">ssh-keygen</span><br><span class="line"></span><br><span class="line"># 查看公钥</span><br><span class="line">cat ~/.ssh/id_rsa.pub</span><br><span class="line"></span><br><span class="line"># 将公钥写入服务端受信公钥列表上</span><br><span class="line">echo &quot;公钥&quot; &gt;&gt; ~/.ssh/authorized_keys</span><br></pre></td></tr></table></figure><h3 id="git-key"><a href="#git-key" class="headerlink" title="git key"></a>git key</h3><p>还有一个需要频繁输入密码的场景，就是使用git，为了方便我们按照配置ssh 免密类似的方式配一下，把主机生成的 ssh 公钥配置到 git 上</p><p>github: **settings -&gt; ssh and GPG keys **</p><p><img src="/2022/05/31/vscode-tools/vscode03.png" alt="ssh key github"></p><p>gitee: <strong>设置 -&gt; ssh 公钥</strong></p><p><img src="/2022/05/31/vscode-tools/vscode04.png" alt="ssh key gitee"></p><h2 id="各开发环境常用插件"><a href="#各开发环境常用插件" class="headerlink" title="各开发环境常用插件"></a>各开发环境常用插件</h2><h3 id="java"><a href="#java" class="headerlink" title="java"></a>java</h3><h4 id="Extension-Pack-for-Java"><a href="#Extension-Pack-for-Java" class="headerlink" title="Extension Pack for Java"></a>Extension Pack for Java</h4><p><img src="/2022/05/31/vscode-tools/vscode16.png" alt="java extension"></p><p>注意新版本的插件要求运行环境是 JDK11, 所以如果你的主力项目用的是 JDK8 ，还需要给开发机额外装 JDK11，另外环境变量也要配对</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># /etc/profile</span><br><span class="line">export JAVA_HOME=/usr/java/jdk8路径</span><br><span class="line">export JRE_HOME=$JAVA_HOME/jre</span><br><span class="line">export CLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar:$JRE_HOME/lib</span><br><span class="line">export JDK_HOME=/usr/java/jdk-11.0.14.1+1</span><br><span class="line">export PATH=$PATH:$JAVA_HOME/bin:$JRE_HOME/bin:$MAVEN_HOME/bin:$GRADLE_HOME/bin</span><br></pre></td></tr></table></figure><p>这些配置之前还提过 issue 专门问过开发者，最后解决的，亲自试验没问题</p><p>另外项目也要显式说明使用的 JDK 版本，maven 和 gradle 配置如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># pom.xml</span><br><span class="line">## 注意: 不同的 module 对应的 pom.xml, 都需要加上这个配置</span><br><span class="line">    &lt;properties&gt;</span><br><span class="line">        &lt;maven.compiler.source&gt;1.8&lt;/maven.compiler.source&gt;</span><br><span class="line">        &lt;maven.compiler.target&gt;1.8&lt;/maven.compiler.target&gt;</span><br><span class="line">    &lt;/properties&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># build.gradle</span><br><span class="line">  plugins.withType(JavaPlugin) &#123;</span><br><span class="line">    sourceCompatibility = 1.8</span><br><span class="line">    targetCompatibility = 1.8</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>最后打开 <strong>Java: Configure Java Runtime</strong>, 确认项目所使用的 JDK 版本是准确的</p><p><img src="/2022/05/31/vscode-tools/vscode17.png" alt="java runtime"></p><h4 id="maven"><a href="#maven" class="headerlink" title="maven"></a>maven</h4><p>maven 插件在上面装的插件包中自带了，但是有个很奇怪的问题: 插件无法按照 maven 安装路径 /conf/settings.xml 来读取配置，因此诸如本地依赖路径、配置文件路径都会按默认方式从 ~/.m2 路径读取。建议在初始化开发环境的时候配置一个软链指向实际路径，防止通过 maven 下载的依赖包存放在不同路径，造成空间浪费</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 创建配置和依赖路径软链</span><br><span class="line">mkdir -p ~/.m2 &amp;&amp; ln -s /本地maven 仓库地址 ~/.m2/repository &amp;&amp; ln -s /maven安装路径/conf/settings.xml ~/.m2/settings.xml</span><br></pre></td></tr></table></figure><p>或者手动修改插件 <a href="https://github.com/microsoft/vscode-maven#settings">maven.settingsFile</a> 配置，不过有点麻烦，不建议这么做</p><h4 id="gradle"><a href="#gradle" class="headerlink" title="gradle"></a>gradle</h4><p>gradle 插件需要另外下载: Gradle Extension Pack</p><p><img src="/2022/05/31/vscode-tools/vscode06.png" alt="gradle extension"></p><h4 id="formatter"><a href="#formatter" class="headerlink" title="formatter"></a>formatter</h4><p>设置 formatter 工具: 打开插件功能列表(command + shift + P), 选择 <strong>Open Java Format Settings With Preview</strong><br>第一次会提示还未设置，可以直接用默认的，也可以直接修改 .vscode/settings.json 设置用谷歌的formatter</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># .vscode/settings.json</span><br><span class="line">&quot;java.format.settings.url&quot;: &quot;https://raw.githubusercontent.com/google/styleguide/gh-pages/eclipse-java-google-style.xml&quot;,</span><br><span class="line">&quot;java.format.settings.profile&quot;: &quot;GoogleStyle&quot;</span><br></pre></td></tr></table></figure><h4 id="lombok"><a href="#lombok" class="headerlink" title="lombok"></a>lombok</h4><p>和 Idea 类似，lombok 要想在编写过程中让注解直接生效，也需要额外的机制: 插件: <strong>Lombok Annotations Support for VS Code</strong></p><p><img src="/2022/05/31/vscode-tools/vscode07.png" alt="lombok"></p><h3 id="golang"><a href="#golang" class="headerlink" title="golang"></a>golang</h3><h4 id="go"><a href="#go" class="headerlink" title="go"></a>go</h4><p>Golang 官方的插件装完之后，在代码编辑这块功能都已经很完备了，装好之后包括测试执行、formatter 等功能都有</p><p><img src="/2022/05/31/vscode-tools/vscode08.png" alt="go"></p><p><img src="/2022/05/31/vscode-tools/vscode09.png" alt="安装过程"></p><p>不过关于测试的参数这里，默认的配置往往不符合我们要求。需要额外设置超时时间，打印日志，取消测试缓存等<br><img src="/2022/05/31/vscode-tools/vscode10.png" alt="vscode-go-setting"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># .vscode/settings.json</span><br><span class="line">&quot;go.testFlags&quot;: [</span><br><span class="line">    &quot;-v&quot;,</span><br><span class="line">    &quot;-count=1&quot;,</span><br><span class="line">    &quot;-timeout=300s&quot;</span><br><span class="line">],</span><br></pre></td></tr></table></figure><h4 id="查看go源码"><a href="#查看go源码" class="headerlink" title="查看go源码"></a>查看go源码</h4><p><a href="https://github.com/golang/vscode-go/blob/master/docs/advanced.md#working-on-the-go-standard-library-and-the-go-tools">Working on the Go standard library and the Go tools</a></p><p>直接打开 go 仓库根路径，代码会一片飘红</p><p><img src="/2022/05/31/vscode-tools/vscode-go.png" alt="直接打开后，关键字都会报错"></p><p>因为这并不是正确的打开 go 源码的方式，我们需要打开 src 目录，并在 src/.vscode/settings.json 中添加如下配置:</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;go.alternateTools&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;go&quot;</span>: <span class="string">&quot;/opt/modules/golang/bin/go&quot;</span> <span class="comment">// 本地 go 可执行文件路径</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">&quot;go.toolsGopath&quot;</span>: <span class="string">&quot;~/.vscode/godev&quot;</span>, <span class="comment">// vscode 打开 golang 项目安装的插件路径，可以和 GOPATH 共用也可以指定单独的路径</span></span><br><span class="line">    <span class="attr">&quot;html.format.enable&quot;</span>: <span class="literal">false</span> <span class="comment">// 不要自动格式化 html 文件，因为 go 源码中的 html 是带有模板的特殊格式</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>配置后刷新页面，能正常打开源码了</p><p><img src="/2022/05/31/vscode-tools/vscode-go-src.png" alt="正常打开源码"></p><h3 id="python"><a href="#python" class="headerlink" title="python"></a>python</h3><h4 id="python-1"><a href="#python-1" class="headerlink" title="python"></a>python</h4><p><img src="/2022/05/31/vscode-tools/vscode11.png" alt="python"></p><p>如果你的开发机上安装了多套 python，可通过 <strong>Python: Select Interpreter</strong> 进行切换</p><p><img src="/2022/05/31/vscode-tools/vscode13.png" alt="python interpreter"></p><h4 id="formatter-1"><a href="#formatter-1" class="headerlink" title="formatter"></a>formatter</h4><p>推荐 flake8，默认的 pylint 要求有点过于严格</p><p>打开插件功能列表，搜索 <strong>Python: Select Linter</strong> 并选择 flake8，第一次选择后提示安装即可</p><p>自动 format: black</p><p>在插件配置中搜索: <strong>python formatting provider</strong></p><p><img src="/2022/05/31/vscode-tools/vscode12.png" alt="black"></p><h3 id="markdown"><a href="#markdown" class="headerlink" title="markdown"></a>markdown</h3><p>插件名: <strong>Markdown All in One</strong><br>在写 readme 的时候还是非常好用的，可以直接看到效果: 打开 Markdown: open preview, 并把 preview 并把窗口拖到右边即可</p><p><img src="/2022/05/31/vscode-tools/vscode05.png" alt="markdown"></p><p><img src="/2022/05/31/vscode-tools/vscode14.png" alt="markdown preview"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>使用 vscode 很长一段时间回头看，插件功能确实很强大，自己现在用到的也只是万众插件中的冰山一角，希望后面有什么新的感受可以再补充一下</p><p>最后就希望自己每天都能像今天过节一样吧～</p><h2 id="引用资料"><a href="#引用资料" class="headerlink" title="引用资料"></a>引用资料</h2><p><a href="https://www.zhihu.com/question/322952427">如何评价 VS Code Remote Development？</a></p><p><a href="https://www.zhihu.com/question/304808444">讨论-买Jetbrains全家桶的都是什么人？</a></p><p><a href="https://www.v2ex.com/t/565476">讨论-IDEA 和 vscode 比较介绍，推荐那个？</a></p><p><a href="https://code.visualstudio.com/docs/java/java-linting">vscode官方-Java formatting and linting</a></p><p><a href="https://v2ex.com/t/587696">v2ex-大家在自己的 Python 项目中倾向使用哪个 Linter？</a></p>]]></content>
      
      
      <categories>
          
          <category> 开发工具 </category>
          
          <category> vscode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 开发工具 </tag>
            
            <tag> vscode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>通过 Docker Compose 本地启动 zk 集群</title>
      <link href="/2022/05/18/dockerfile-compose/"/>
      <url>/2022/05/18/dockerfile-compose/</url>
      
        <content type="html"><![CDATA[<h2 id="项目"><a href="#项目" class="headerlink" title="项目"></a>项目</h2><p>如果你想直接看代码，可以直接看我的 <a href="https://github.com/smiecj/docker-centos">git-docker-centos</a> 项目地址，最近发布了 <a href="https://github.com/smiecj/docker-centos/releases/tag/v1.2.0">v1.2.0</a> 版本，readme 已经非常详细了，包括项目的使用方式 和 需求规划</p><p>本机环境基本只依赖 Docker 的安装，Docker Desktop 的安装教程可参考我之前的<a href="https://mp.weixin.qq.com/s/zmkzhIdL7Da_sfNauhAGRQ">博客-Docker Desktop 安装方式和开发镜像分享</a>，当然，更详细的教程网上一搜有一堆</p><p><a href="https://blog.csdn.net/xiaoliizi/article/details/124838563">csdn 博客地址</a><br><a href="https://mp.weixin.qq.com/s/4wT_C4Qvywwmh1a9edktxA">公众号博客地址</a></p><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>之前已经大致将自己平时开发用到的服务和环境，都打包到了 Dockerfile 中，可在本机进行开发环境和基础组件的一键部署。后续自己也进行一些改进，减少了仓库中的shell 脚本文件，整体安装逻辑会更加直观</p><p><a href="https://mp.weixin.qq.com/s/BrtGVdtIhv1SoM-KZ1hZCQ">关于我为什么要封装自己的 Dockerfile</a></p><p>这个项目当时做到这里就感觉算是完成了一个不小的目标，但随着自己用这个项目的深入，总感觉还差点意思，比如 zk 只能部署一个节点，集群的话需要写三个（对应三个节点）很长的 docker run 指令，加一堆参数（主要是注入 zk 本身的配置），根本没法记，只能放到电脑笔记中，每次拷贝粘贴，非常不方便</p><p>给人的感觉，有点像微信的公众号，本来机制是很好的，实时的新闻也有，沉淀下来的技术博客也很多，但是用着用着就感觉没那么好用了，自己不想看的东西越来越多，想要的文章自己又看不到。<strong>好的工具却不能提升学习的效率，类似这种感觉</strong></p><p>另外还有一个小小的痛点: nacos 作为阿里开源的配置管理服务，官方仓库确实已经很完善了，代码在 <a href="https://github.com/alibaba/nacos">nacos 仓库</a>，容器化部署相关的配置文件放到 <a href="https://github.com/nacos-group/nacos-docker">nacos-docker</a>，分得很细。但是官方提供的 <a href="https://github.com/nacos-group/nacos-docker/blob/master/example/standalone-mysql-5.7.yaml">standalone-mysql-5.7.yaml</a> <strong>单机部署配置文件中使用的 nacos 和 mysql 镜像不兼容 Mac M1 系统</strong>。官方也有对应的 issue，但是到发这篇博客的时候，官方还未解决</p><p>直到有一天通过 k8s 接触到了 其他管理容器集群的工具，其中 <strong>swarm</strong> 就是通过 compose 管理集群的，突然意识到 <strong>docker-compose</strong> 这个工具应该是比较切合我的需求</p><p>主要的原因，就是 对比 <strong>Kubernetes</strong> 来说：k8s 自成一套体系，也牵扯到很多其他技术栈，对初学者来说需要花很多时间去掌握。但是 Compose 其实还是基于 Docker 的基本指令，它对应的配置文件，其实就对应了 Docker 的指令或者参数，对熟悉 Docker 指令的同学来说肯定非常好上手</p><p>那还多说什么呢？直接参考官方文档，实践起来</p><h2 id="最终效果"><a href="#最终效果" class="headerlink" title="最终效果"></a>最终效果</h2><p>Compose 这块实现了 zk 集群 和 nacos 服务（依赖 mysql），直接看效果</p><h3 id="启动-zk-集群"><a href="#启动-zk-集群" class="headerlink" title="启动 zk 集群"></a>启动 zk 集群</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 构建操作系统基础镜像</span></span><br><span class="line">make build_base</span><br><span class="line"></span><br><span class="line"><span class="comment"># 构建 java 开发镜像</span></span><br><span class="line">make build_dev_java</span><br><span class="line"></span><br><span class="line"><span class="comment"># 构建 zookeeper 镜像</span></span><br><span class="line">make build_zookeeper</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动 zk 集群</span></span><br><span class="line"><span class="comment">## 前面构建镜像都是一次性的，后面启动 zk 集群、启动 nacos 都不需要再重复构建</span></span><br><span class="line">make run_zookeeper_cluster</span><br></pre></td></tr></table></figure><p><img src="/2022/05/18/dockerfile-compose/compose01.png" alt="zk cluster"></p><h3 id="启动-nacos-服务"><a href="#启动-nacos-服务" class="headerlink" title="启动 nacos 服务"></a>启动 nacos 服务</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 构建 mysql 镜像</span></span><br><span class="line">make build_mysql</span><br><span class="line"></span><br><span class="line"><span class="comment"># 构建 nacos 镜像</span></span><br><span class="line">make build_nacos</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动 nacos 服务</span></span><br><span class="line">make run_nacos_mysql</span><br></pre></td></tr></table></figure><p><img src="/2022/05/18/dockerfile-compose/compose02.png" alt="nacos start"></p><p><img src="/2022/05/18/dockerfile-compose/compose03.png" alt="nacos web"></p><p>其中，nacos 服务启动 需要先构建 centos_base、centos_java、centos_nacos 和 centos_mysql 镜像，zk 集群启动需要先构建 centos_java、centos_zookeeper 镜像</p><p>第一次构建镜像的话，确实需要总的大概十几分钟的时间，比如 java 的基础镜像，需要先下载几百M 的 JDK，zookeeper 镜像的构建需要编译 zk，但是之后的开发过程就非常顺滑了，<strong>启动服务只需要几秒钟</strong>。这在之前直接使用 Docker 指令启动 zk 集群 还需要粘贴一堆指令，是无法想象的</p><h2 id="如何实现"><a href="#如何实现" class="headerlink" title="如何实现"></a>如何实现</h2><h3 id="技术栈"><a href="#技术栈" class="headerlink" title="技术栈"></a>技术栈</h3><p>容器技术：<strong>Docker、Docker Compose</strong></p><ul><li>熟悉 Docker 指令</li><li>了解和Docker 相关的术语，比如容器、镜像、Dockerfile 他们的用法</li><li>了解 Compose 基本用法</li></ul><p>后台开发：<strong>Java 语言，Zookeeper、Nacos、MySQL 等中间件</strong></p><ul><li>OpenJDK 安装</li><li>中间件安装</li></ul><p>脚本</p><ul><li>shell 基本语法</li></ul><h3 id="构建基础镜像"><a href="#构建基础镜像" class="headerlink" title="构建基础镜像"></a>构建基础镜像</h3><p>在通过 Compose 启动服务之前，我们需要把基础镜像先构建好<br>这里基础镜像可以分为三部分: </p><ul><li>操作系统基础镜像（centos_base）</li><li>开发环境基础镜像（如 Java 开发镜像）</li><li>组件镜像（centos_zookeeper）</li></ul><p>你可以理解为这是一个金字塔三角的结构，就好像你在电脑上安装各种软件，他们是最上层的服务（对应组件），然后软件需要运行在一些系统提供的基础环境中（比如红警在 win10 上跑就需要设置兼容性），最下面一层是操作系统</p><p>关于每个镜像里面安装的组件，我在项目的 <a href="https://github.com/smiecj/docker-centos/blob/main/README_zh.md">Readme</a> 文档中有具体说明</p><p><img src="/2022/05/18/dockerfile-compose/compose04.png" alt="一部分镜像"></p><h3 id="Compose-配置"><a href="#Compose-配置" class="headerlink" title="Compose 配置"></a>Compose 配置</h3><p>这里需要对 Compose 的使用方式有基本了解，对于熟悉 docker 的同学来说不会太难</p><p>举个例子：nacos+mysql 的 Compose 配置</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&quot;3.9&quot;</span></span><br><span class="line"><span class="comment"># 定义需要启动的服务，nacos 依赖 mysql, 因此需要定义nacos和mysql 两个服务</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">nacos:</span></span><br><span class="line">    <span class="comment"># 镜像名</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">centos_nacos</span></span><br><span class="line">    <span class="comment"># 启动容器的环境变量，对 nacos 来说，主要需要注入 mysql 的配置</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">MYSQL_HOST=mysql</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">MYSQL_PORT=3306</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">MYSQL_DB=d_nacos</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">MYSQL_USER=root</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">MYSQL_PASSWORD=root_NACOS_123</span></span><br><span class="line">    <span class="comment"># 暴露到主机的端口</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;8848:8848&quot;</span></span><br><span class="line">    <span class="comment"># 先启动 mysql 服务，再启动 nacos</span></span><br><span class="line">    <span class="attr">depends_on:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">mysql</span></span><br><span class="line">  <span class="attr">mysql:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">centos_mysql</span></span><br><span class="line">    <span class="comment"># 设置 mysql 登录密码，以及创建一个非默认DB</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">ROOT_PASSWORD=root_NACOS_123</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">USER_DB=d_nacos</span></span><br><span class="line">    <span class="comment"># 将当前路径挂载到 mysql 容器里面的特定目录(init_sql)</span></span><br><span class="line">    <span class="comment"># 这里有一个小功能实现: 让 mysql 在初始化的时候查找 init_sql 目录下所有 sql 文件 并 执行，为什么要这么实现在后面实现细节中会讲到</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;./:/home/modules/mysql/init_sql&quot;</span></span><br><span class="line"><span class="comment"># 创建一个 nacos 和 mysql 服务共用的网络环境</span></span><br><span class="line"><span class="attr">networks:</span></span><br><span class="line">  <span class="attr">my-nacos:</span></span><br></pre></td></tr></table></figure><h2 id="实现细节"><a href="#实现细节" class="headerlink" title="实现细节"></a>实现细节</h2><h3 id="s6"><a href="#s6" class="headerlink" title="s6"></a>s6</h3><p><a href="https://github.com/just-containers/s6-overlay">s6</a> 是为了适配容器化场景，针对各个芯片指令集平台都做了适配的 <strong>服务管理器</strong>，类似 systemctl</p><p>为什么要引入 s6，主要原因还是 systemctl 在 Mac M1 上不兼容，这个在git 上很多项目都有<a href="https://github.com/docker/for-mac/issues/6073">讨论</a>，其中使用 s6 就是一种解决方案，只是需要稍微做点适配</p><p>比如 mysql，不能使用 service mysql start 指令启动的情况下，就需要把服务启动指令以 s6 支持的方式，写好启动脚本，并在 Dockerfile 中增加注入 启动脚本 的逻辑了</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># centos_base.Dockerfile</span></span><br><span class="line"><span class="comment">## 设置系统启动后执行 /init 以启动 s6 进程</span></span><br><span class="line">ENTRYPOINT [<span class="string">&quot;/init&quot;</span>]</span><br></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># mysql.Dockerfile</span></span><br><span class="line">COPY s6/ /etc/</span><br></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># s6/services.d/mysql/run</span></span><br><span class="line"><span class="comment">#!/bin/bash</span></span><br><span class="line">/usr/sbin/mysqld --user=root</span><br></pre></td></tr></table></figure><h3 id="mysql-初始化时执行-sql"><a href="#mysql-初始化时执行-sql" class="headerlink" title="mysql 初始化时执行 sql"></a>mysql 初始化时执行 sql</h3><p>场景: 一开始我对 mysql Dockerfile 实现的功能只是一键启动，但是后面发现对 nacos 一键部署的场景，还需要支持 初始化时导入 nacos sql ，否则 nacos 无法正常启动</p><p>这其实也是 nacos 官方的 compose 配置所使用的 mysql 镜像是 nacos 官方仓库中的镜像的原因。<a href="https://hub.docker.com/r/mysql/mysql-server/dockerfile">mysql 官方 Dockerfile</a> 并不支持在初始化时执行 sql</p><p>所以这里对 mysql Dockerfile 实现了一个 加载并执行 指定目录下的 sql 文件的功能</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># init-mysql.sh</span></span><br><span class="line">......</span><br><span class="line"><span class="comment">## execute init sql</span></span><br><span class="line">sql_files=`ls -l &#123;mysql_init_sql_home&#125; | grep -E <span class="string">&quot;\.sql$&quot;</span> | sed <span class="string">&quot;s/.* //g&quot;</span> | tr <span class="string">&#x27;\n&#x27;</span> <span class="string">&#x27; &#x27;</span>`</span><br><span class="line"><span class="keyword">for</span> current_sql_file <span class="keyword">in</span> <span class="variable">$&#123;sql_files[@]&#125;</span></span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    mysql -uroot -p<span class="string">&quot;<span class="variable">$&#123;ROOT_PASSWORD&#125;</span>&quot;</span> -f -D<span class="variable">$&#123;USER_DB&#125;</span> &lt; &#123;mysql_init_sql_home&#125;/<span class="variable">$&#123;current_sql_file&#125;</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line">......</span><br></pre></td></tr></table></figure><h3 id="源替换"><a href="#源替换" class="headerlink" title="源替换"></a>源替换</h3><p>在国内网络条件下进行开发你需要解决的一个很基础的问题，就是代理服务器的问题，否则从外网下载开源组件安装包的速度，常常会让你抓狂<br>这里需要对两种场景分别解决:<br>对 yum 源、OpenJDK 下载等可以找到国内源 替换 国外地址 的话，直接替换下载地址就可以了</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># env_java.sh</span></span><br><span class="line"><span class="comment">## 使用清华源 mirrors.tuna.tsinghua.edu.cn，还是挺全的</span></span><br><span class="line">jdk_11_repo=<span class="string">&quot;https://mirrors.tuna.tsinghua.edu.cn/AdoptOpenJDK/11/jdk/x64/linux&quot;</span></span><br><span class="line">......</span><br><span class="line"></span><br><span class="line">jdk_8_repo=<span class="string">&quot;https://mirrors.tuna.tsinghua.edu.cn/AdoptOpenJDK/8/jdk/x64/linux&quot;</span></span><br><span class="line">......</span><br></pre></td></tr></table></figure><p>对不能找到国内源替换的情况，那就只能加快下载速度了，这里我本地有个代理，需要在镜像构建的时候配置到 环境变量 http_proxy 中去<br>默认 Docker 启动容器的网络模式（driver）下，内部识别到主机的代理地址一般是 host.docker.internal（Mac）或 172.26.16.1（Win10），对应容器内部网络的网关地址<br>所以做了一个循环逻辑，依次检测指定几个代理端口是否能通，通的话直接配置proxy的逻辑</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># init-system-proxy.sh, 构建 centos_base 镜像时会调用</span></span><br><span class="line"><span class="keyword">for</span> proxy_host <span class="keyword">in</span> <span class="variable">$&#123;proxy_host_array[@]&#125;</span></span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    <span class="keyword">for</span> proxy_port <span class="keyword">in</span> <span class="variable">$&#123;proxy_port_array[@]&#125;</span></span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">        <span class="comment">## telnet 一个通的地址很快，这里设置超时 1s</span></span><br><span class="line">        telnet_output=`timeout 1 telnet <span class="variable">$proxy_host</span> <span class="variable">$proxy_port</span> 2&gt;&amp;1` || <span class="literal">true</span></span><br><span class="line">        telnet_refused_msg=`<span class="built_in">echo</span> <span class="variable">$telnet_output</span> | grep <span class="string">&quot;Connection refused&quot;</span> || <span class="literal">true</span>`</span><br><span class="line">        telnet_host_unknown_msg=`<span class="built_in">echo</span> <span class="variable">$telnet_output</span> | grep <span class="string">&quot;Unknown host&quot;</span> || <span class="literal">true</span>`</span><br><span class="line">        <span class="keyword">if</span> [ -n <span class="string">&quot;<span class="variable">$telnet_output</span>&quot;</span> ] &amp;&amp; [ -z <span class="string">&quot;<span class="variable">$telnet_refused_msg</span>&quot;</span> ] &amp;&amp; [ -z <span class="string">&quot;<span class="variable">$telnet_host_unknown_msg</span>&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">            <span class="built_in">echo</span> <span class="string">&quot;export http_proxy=http://<span class="variable">$proxy_host</span>:<span class="variable">$proxy_port</span>&quot;</span> &gt;&gt; /etc/profile</span><br><span class="line">            <span class="built_in">echo</span> <span class="string">&quot;export https_proxy=http://<span class="variable">$proxy_host</span>:<span class="variable">$proxy_port</span>&quot;</span> &gt;&gt; /etc/profile</span><br><span class="line">            <span class="built_in">break</span></span><br><span class="line">        <span class="keyword">fi</span></span><br><span class="line">    <span class="keyword">done</span></span><br><span class="line">    current_proxy=`cat /etc/profile | grep http_proxy || <span class="literal">true</span>`</span><br><span class="line">    <span class="keyword">if</span> [ -n <span class="string">&quot;<span class="variable">$current_proxy</span>&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">        <span class="built_in">break</span></span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><h2 id="扩展-后面还可以做什么"><a href="#扩展-后面还可以做什么" class="headerlink" title="扩展: 后面还可以做什么"></a>扩展: 后面还可以做什么</h2><p>1、横向扩展<br><strong>支持更多服务的本地化集群</strong></p><p>大部分后台中间件，我们在公司里面实践的时候都会遇到部署集群和维护的场景。如果想在自己电脑上研究，当然是能够快速部署集群方便一点。</p><p>不过，要能够通过我上面所说的思路去搭集群，并不是容易事，你需要先设想 镜像如何构建，需要把哪些配置作为容器启动参数提供出来，这两步可能会花费大部分时间。不过如果能把这两步搞定，后面 compose 配置的编写就是顺理成章的事了</p><p>2、纵向扩展<br><strong>学习 K8S</strong></p><p>Compose 毕竟只是通过启动多个容器节点来实现集群 部署的效果，还不涉及到容器编排技术，资源调度这些。想要了解更多技术上的细节，还是最好通过 <strong>swarm、k8s</strong> 这类工具来实践</p><p>当然，想精通这两个工具，就没这么简单了，确实需要做好长期啃一门技术，却不一定有很快成效的心理准备</p><h2 id="资料"><a href="#资料" class="headerlink" title="资料"></a>资料</h2><p><a href="https://docs.docker.com/compose/gettingstarted/">Compose 官方文档</a></p><p><a href="https://github.com/eryajf/Thanks-Mirror">国内源替换仓库</a></p><p><a href="https://blog.chobon.top/posts/694278be/">s6 使用教程（基本是 git 官方 readme 的翻译版，不过作为入门教程还是不错）</a></p><p><a href="https://github.com/alibaba/nacos/issues/6340">nacos issue-Apple Mac M1 docker环境下nacos无法启动</a></p>]]></content>
      
      
      <categories>
          
          <category> 开发工具 </category>
          
          <category> docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>树莓派通过 SSD 部署 和 配置内网穿透</title>
      <link href="/2022/03/12/rasp-ssd-frp/"/>
      <url>/2022/03/12/rasp-ssd-frp/</url>
      
        <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>之前一直有在家部署一个可以长期运行的 Linux 服务器的想法，但首先是自己没有一台 Linux 服务器，不是特别想一直开着台式机主机，其次是就算家里开着台式机，外网也访问不到，只能借助类似向日葵的软件远程操作桌面，所以一直没有实践<br>但最近把 树莓派 搞好之后发现其实搞起来也不是那么难，再加上有个大佬买了个云服务器，还一下买了几年，于是硬件条件都有满足了。终于找了个时间，先把树莓派通过 SSD 重新安装系统，再结合 内网穿透，后面可以在外网直接操作树莓派，算是有个可以经常跑，也能经常操作和维护的Linux服务器了</p><h2 id="树莓派和SSD"><a href="#树莓派和SSD" class="headerlink" title="树莓派和SSD"></a>树莓派和SSD</h2><p>一开始树莓派是需要通过 SD 卡初始化的，但是 显然 SD卡 无法承担更高的数据读写要求。于是把自己的一张不常用的 SSD 从台式机拿了出来，接到树莓派上并进行了下系统迁移</p><p><a href="https://www.tomshardware.com/how-to/boot-raspberry-pi-4-usb">How to Boot Raspberry Pi 4 / 400 From a USB SSD or Flash Drive</a></p><h3 id="系统写入SSD"><a href="#系统写入SSD" class="headerlink" title="系统写入SSD"></a>系统写入SSD</h3><p>这里我们通过 imager 将树莓派系统写入 SSD<br><a href="https://www.raspberrypi.com/software/">imager官方下载</a></p><p>选择一个官方镜像，32位和64位都可以<br><img src="/2022/03/12/rasp-ssd-frp/rasp03.png" alt="jupyter lab"></p><p>等待写入<br><img src="/2022/03/12/rasp-ssd-frp/rasp02.png" alt="jupyter lab"></p><h3 id="修改启动选项"><a href="#修改启动选项" class="headerlink" title="修改启动选项"></a>修改启动选项</h3><p>登录树莓派（这里还是用 SD卡 启动），安装 bootloader</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sudo apt update</span><br><span class="line">sudo apt full-upgrade</span><br><span class="line">sudo rpi-update</span><br><span class="line"></span><br><span class="line">sudo rpi-eeprom-update -d -a</span><br></pre></td></tr></table></figure><p>将启动选项修改成用 SSD 卡启动</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo raspi-config</span><br></pre></td></tr></table></figure><p>选择 <strong>6 Advanced Options -&gt; A6 Boot Order -&gt; B2 USB Boot</strong></p><h3 id="重启树莓派"><a href="#重启树莓派" class="headerlink" title="重启树莓派"></a>重启树莓派</h3><p>成功～</p><p><img src="/2022/03/12/rasp-ssd-frp/rasp04.png" alt="部署效果"></p><p>后面再安装了 docker，把一些后台服务部署到了树莓派上。除了受限于树莓派本身 CPU 和内存（4核4G），只能部署一些简单的服务，不过对自己的个人开发需求来说已经够用了</p><h2 id="内网穿透"><a href="#内网穿透" class="headerlink" title="内网穿透"></a>内网穿透</h2><h3 id="原理介绍"><a href="#原理介绍" class="headerlink" title="原理介绍"></a>原理介绍</h3><p>本质上就是在保证安全的前提下，建立从公网到内网的连接通道，使得内网机器能够通过一个可靠的公网地址访问<br>对应现实的例子，类似找香港的代购，代购相当于就是代理，能够按照我们的需求到香港购买一些面免关税的商品（公网发送请求到代理），再帮我们带回来（代理发送请求到内网服务，再将请求结果返回）<br>因此内网穿透的需求从架构上来看，主要包括三个元素：资源提供商、资源使用者 和 代理服务，如下:</p><p>frpc: fast forward proxy client, 内网代理服务<br>frps: fast forward proxy server, 外网代理服务</p><p><img src="/2022/03/12/rasp-ssd-frp/rasp05.png" alt="frp架构"></p><p><a href="https://github.com/fatedier/frp">git-frp</a></p><p>应用场景：</p><ul><li><p>​个人随时操作内网服务器<br>比如接下来要说的部署 frp 代理服务，就是实现这个需求</p></li><li><p>企业开启远程办公<br>国内的互联网公司基本都是通过 代理软件（如: easyConnect）+ 专用隧道 实现在外网对内网资源的访问，本质上就是内网穿透</p></li><li><p>将内网其他服务开启到外网（如个人博客站点）<br>比较大型的个人站点，一般会包含很多数据，需要一定的存储，也需要保证足够的并发访问能力。但是买一个高性能、高存储的云服务器对个人来说肯定成本也不少，这时就可以采用 站点依然部署在内网，只购买一台 主提供流量的 云服务器，通过内网穿透对外开启 HTTP 端口 提供服务的方式。相当于资源提供的压力还是主要在内网机器，外网云服务器只承担流量压力</p></li></ul><h3 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h3><ul><li>内网机器（Linux）</li><li>一台云服务器（Centos）</li></ul><h3 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h3><h4 id="frps（公网）"><a href="#frps（公网）" class="headerlink" title="frps（公网）"></a>frps（公网）</h4><p>下载</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https://github.com/fatedier/frp/releases/download/v0.40.0/frp_0.40.0_linux_amd64.tar.gz</span><br></pre></td></tr></table></figure><p>配置</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[common]</span></span><br><span class="line"><span class="comment"># frps 服务提供的端口</span></span><br><span class="line"><span class="attr">bind_port</span> = <span class="number">7001</span></span><br><span class="line"><span class="comment"># 是否每次网络连接的时候 都进行认证（访问速度 和 安全 方面的选择，并发不大的访问量来说影响不大）</span></span><br><span class="line"><span class="attr">authenticate_new_work_conns</span> = <span class="literal">true</span></span><br><span class="line"><span class="comment"># 是否对 frpc 和 frps 之间的心跳检查请求 都进行认证（默认心跳 30s 一次，所以开启认证影响不大）</span></span><br><span class="line"><span class="attr">authenticate_heartbeats</span> = <span class="literal">true</span></span><br><span class="line"><span class="comment"># 请求认证方式，可选 token/oidc</span></span><br><span class="line"><span class="attr">authentication_method</span> = token</span><br><span class="line"><span class="comment"># 用于请求信息 加密的 key</span></span><br><span class="line"><span class="comment">## 扩展：加密算法 主要用到了 MD5 和 AES，前者用于 Ping 包的校验，后者用于 TCP 请求的校验，具体实现可以参考 frp 作者的 golib 仓库 - git-golib-crypto</span></span><br><span class="line"><span class="attr">token</span> = <span class="number">123</span></span><br></pre></td></tr></table></figure><p>启动</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./frps -c ./frps.ini</span><br></pre></td></tr></table></figure><h4 id="frpc（内网）"><a href="#frpc（内网）" class="headerlink" title="frpc（内网）"></a>frpc（内网）</h4><p>下载</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https://github.com/fatedier/frp/releases/download/v0.40.0/frp_0.40.0_linux_arm64.tar.gz</span><br></pre></td></tr></table></figure><p>配置</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[common]</span></span><br><span class="line"><span class="comment"># 公网 ip 地址</span></span><br><span class="line"><span class="attr">server_addr</span> = x.x.x.x</span><br><span class="line"><span class="comment"># 公网 frps 服务端口，对应 frps.ini 的 bind_ip</span></span><br><span class="line"><span class="attr">server_port</span> = <span class="number">7001</span></span><br><span class="line"><span class="comment"># 校验相关的配置 和 frps 保持一致</span></span><br><span class="line"><span class="attr">authenticate_new_work_conns</span> = <span class="literal">true</span></span><br><span class="line"><span class="attr">authenticate_heartbeats</span> = <span class="literal">true</span></span><br><span class="line"><span class="attr">authentication_method</span> = token</span><br><span class="line"><span class="attr">token</span> = <span class="number">123</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 代理名称（可自行命名）</span></span><br><span class="line"><span class="section">[ssh]</span></span><br><span class="line"><span class="comment"># 代理协议</span></span><br><span class="line"><span class="attr">type</span> = tcp</span><br><span class="line"><span class="comment"># 内网 ssh 端口</span></span><br><span class="line"><span class="attr">local_port</span> = <span class="number">22</span></span><br><span class="line"><span class="comment"># 在公网开放的端口地址</span></span><br><span class="line"><span class="attr">remote_port</span> = <span class="number">6001</span></span><br></pre></td></tr></table></figure><p>启动</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./frpc -c ./frpc.ini</span><br></pre></td></tr></table></figure><h4 id="添加端口访问权限"><a href="#添加端口访问权限" class="headerlink" title="添加端口访问权限"></a>添加端口访问权限</h4><p>阿里云：管理控制台 -&gt; 云服务器 -&gt; ECS安全组 -&gt; 手动添加访问规则<br>分别将 frps 服务的端口 和 内网机器通过 frps 暴露的外网端口 设置访问权限</p><p><img src="/2022/03/12/rasp-ssd-frp/rasp06.png" alt="阿里云安全策略配置"></p><h4 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h4><p>直接通过ssh云服务器 连接内网服务器:<br>ssh pi@外网服务器ip -p6001</p><p><img src="/2022/03/12/rasp-ssd-frp/rasp07.png" alt="ssh"></p>]]></content>
      
      
      <categories>
          
          <category> 生活 </category>
          
          <category> 树莓派 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> 树莓派 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2月份随便记记</title>
      <link href="/2022/02/28/life-202202/"/>
      <url>/2022/02/28/life-202202/</url>
      
        <content type="html"><![CDATA[<h2 id="充实的2月份"><a href="#充实的2月份" class="headerlink" title="充实的2月份"></a>充实的2月份</h2><p>2月份发生了各种事，从线下蔓延到了线上，一定程度让自己有一些关注新闻欲过高。月初看了看冬奥会盛况，感叹也许只有中国人办的奥运才会能这么美。月中关注国内一些“历史遗留”问题，也算是非常有中国特色了。最后月底就是大国之间的博弈，在哪个社交app几乎都能看到关于这件事的新闻<br>然而回头一看，自己忘记的事情也有很多，不仅仅是思考这些事背后到底代表着什么，还有记录点自己内心的想法。也许是时候，带着轻松点的态度，给自己写点总结了～</p><h2 id="开发相关的东西"><a href="#开发相关的东西" class="headerlink" title="开发相关的东西"></a>开发相关的东西</h2><p>首先就是继续把自己的 DockerFile 仓库更完善了下，虽然过程还是有些痛苦的，Centos7 在 Arm 上不能运行 dbus 服务，Centos8 官方 yum 源又不再支持，另外还有python 在两种架构下表现不太一致的问题。各种适配之后，终于把 开发镜像 做到了 x86 和 arm 架构都能够兼容了。总算是松了口气</p><p>除了开发镜像，还整理了最近了解的大数据相关服务：Jupyter，把它们的安装过程也整理到了 DockerFile 中。这两个组件都是数据开发过程必备的 IDE，或许有了这第一步，终于能够开始好好学习下 机器学习了？</p><p>Jupyter 效果:</p><p><img src="/2022/02/28/life-202202/02.png" alt="jupyter lab"></p><p><img src="/2022/02/28/life-202202/03.png" alt="mysql connector demo"></p><p><a href="https://github.com/smiecj/docker-centos">DockerFile 仓库</a></p><h2 id="新的想法"><a href="#新的想法" class="headerlink" title="新的想法"></a>新的想法</h2><p>除了日常做“正事”，也没忘记偶尔“胡思乱想”</p><h3 id="树莓派"><a href="#树莓派" class="headerlink" title="树莓派"></a>树莓派</h3><p>这个从买来就一直在吃灰的东西，在一次和同事的闲聊中，又有了搞起来的想法<br>也许确实没有很多时间去研究适合它的配件，不过至少在家一直开机，当一个服务器还是可以的吧？对于没有买云主机来说，有一个能长期运行的主机可太关键了，毕竟要台式机一直开着还是有点麻烦<br>但是在此之前，还需要稍微做一些准备工作，默认树莓派刚买到是需要先用 SD 卡刷好操作系统的，但是这显然不适合做需要更高写的服务了，甚至还有很高的把 SD 卡写坏的风险。需要换成 SSD<br>这里先记录一下之前搜的教程，等搞好之后“也许”自己会再发个踩坑记录吧，就是几时能写好就不一定了</p><p><a href="https://zhuanlan.zhihu.com/p/336932291">树莓派4 SSD 启动</a></p><h3 id="新闻过滤算法"><a href="#新闻过滤算法" class="headerlink" title="新闻过滤算法"></a>新闻过滤算法</h3><p>在国内外都在打各种信息战的时候，怎么才能过滤出对自己最有用的新闻呢？<br>毕竟人一天的精力终归有限，怎么样更高效的过滤自己想看的新闻，显然是可以借助一些算法实现的<br>但是现实情况往往很复杂，对每个人，每个时间段的需求可能也不一样，有人就更喜欢那种深入剖析，比较长篇的新闻，但是也可能会有想休息，想吸收点快餐类新闻放松的时候。这就意味着这个算法模型可能会有多种，而且还会因人而异<br>如何才能训练出这种更高效的算法，又是一个需要长时间检验的过程，哎，想了想，技术确实能改变人的生活，但是想和现实完美结合，还是很难啊。不知道猴年马月自己才能先做出一个适合自己的模型。。</p>]]></content>
      
      
      <categories>
          
          <category> 生活 </category>
          
          <category> 记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 生活 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mac 预装软件整理</title>
      <link href="/2022/01/10/mac-init-software/"/>
      <url>/2022/01/10/mac-init-software/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近发现在 mac 上装的软件是越来越多了，索性就整理一下自己装过的 mac 必备软件，方便后面用新机的时候直接参考教程无缝切换</p><h2 id="参考网站"><a href="#参考网站" class="headerlink" title="参考网站"></a>参考网站</h2><p><a href="https://www.v1tx.com/post/best-mac-apps/">博客-15款好用的Mac软件推荐</a></p><h2 id="效率工具"><a href="#效率工具" class="headerlink" title="效率工具"></a>效率工具</h2><h3 id="brew"><a href="#brew" class="headerlink" title="brew"></a>brew</h3><p>功能: 软件安装工具，一键安装指定软件，无需关注繁琐的安装配置，对于一些工具类软件，比如下面提到的性能测试软件，还是比较实用的<br><a href="https://docs.brew.sh/">官方文档</a></p><p><a href="https://github.com/Homebrew/brew">git-Homebrew/brew</a></p><p>安装方式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/bin/bash -c &quot;$(curl -fsSL https://cdn.jsdelivr.net/gh/ineo6/homebrew-install/install.sh)&quot;</span><br></pre></td></tr></table></figure><p>替换国内源</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># 替换 brew.git</span><br><span class="line">cd &quot;$(brew --repo)&quot;</span><br><span class="line">git remote set-url origin https://mirrors.tuna.tsinghua.edu.cn/git/homebrew/brew.git</span><br><span class="line"></span><br><span class="line"># 替换 homebrew-core.git</span><br><span class="line">cd &quot;$(brew --repo)/Library/Taps/homebrew/homebrew-core&quot;</span><br><span class="line">git remote set-url origin https://mirrors.tuna.tsinghua.edu.cn/git/homebrew/homebrew-core.git</span><br><span class="line"></span><br><span class="line"># 更新配置</span><br><span class="line">brew update</span><br></pre></td></tr></table></figure><p>扩展: 给其他软件自定义安装脚本<br><a href="https://www.jianshu.com/p/df351f34c160">博客-将软件发布到 Homebrew</a><br><a href="https://docs.brew.sh/Formula-Cookbook">博客-Formula Cookbook</a></p><h3 id="alfred"><a href="#alfred" class="headerlink" title="alfred"></a>alfred</h3><p>自带非常多快捷键工具，我用得比较多的就是粘贴板，可以帮我记住最近一段时间复制过的内容。主要功能有：</p><ul><li>Web Search 文件搜索</li><li>Clipboard History 剪贴板历史</li><li>Snippets 文本片段</li><li>System 系统（系统操作快捷键，如清空回收站）</li></ul><p>alfred 本身的快捷键配置<br><img src="/2022/01/10/mac-init-software/alfred01.png" alt="shortcut"></p><p>剪贴板历史配置<br><img src="/2022/01/10/mac-init-software/alfred02.png" alt="clipboard history"><br>（截图只是表示个人使用习惯）</p><p><a href="https://macwk.com/soft/alfred-4">下载地址</a></p><p><a href="https://michael728.github.io/2020/09/23/tools-dev-mac-alfred/">参考-Mac 效率工具必备神器 —— Alfred</a></p><h3 id="bartender"><a href="#bartender" class="headerlink" title="bartender"></a>bartender</h3><p>mac 的状态栏在右上角，但是不像 windows 那样有默认的隐藏功能，不方便管理<br>bartender 就是不错的状态栏管理工具</p><p><a href="https://macwk.com/soft/bartender-4">下载地址</a></p><p><img src="/2022/01/10/mac-init-software/bartender.png" alt="bartender"></p><h2 id="开发常用"><a href="#开发常用" class="headerlink" title="开发常用"></a>开发常用</h2><h3 id="zsh"><a href="#zsh" class="headerlink" title="zsh"></a>zsh</h3><p>zsh 本身不是 shell，它只是在终端基础上套了个壳，相当于穿了件外套，你可以换不同样式的外套，也可以给衣服加口袋</p><p>而其中 oh-my-zsh 又是扩展功能实现相对比较多的版本。虽然 mac 本身使用的是 zsh，但是版本可能比较旧，还是建议更新 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># 安装 zsh</span><br><span class="line">brew install zsh</span><br><span class="line"></span><br><span class="line"># 安装 oh-my-zsh</span><br><span class="line">sh -c &quot;$(curl -fsSL https://raw.githubusercontent.com/robbyrussell/oh-my-zsh/master/tools/install.sh)&quot;</span><br><span class="line"></span><br><span class="line"># 查看当前终端使用的shell</span><br><span class="line">echo $SHELL</span><br><span class="line"></span><br><span class="line"># 如果不是 zsh，修改成 zsh</span><br><span class="line">sudo echo &quot;$(which zsh)&quot; &gt;&gt; /etc/shells</span><br><span class="line">chsh -s $(which zsh)</span><br></pre></td></tr></table></figure><p>配置插件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># vim ~/.zshrc</span><br><span class="line">plugins=(git osx zsh-autosuggestions zsh-syntax-highlighting)</span><br><span class="line"></span><br><span class="line"># 自动提示插件</span><br><span class="line">git clone https://github.com/zsh-users/zsh-autosuggestions $ZSH_CUSTOM/plugins/zsh-autosuggestions</span><br><span class="line"># 语法高亮插件</span><br><span class="line">git clone https://github.com/zsh-users/zsh-syntax-highlighting $ZSH_CUSTOM/plugins/zsh-syntax-highlighting</span><br></pre></td></tr></table></figure><p>配置主题（根据需要配置，也可以设置其他主题）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 下载</span><br><span class="line">git clone --depth=1 https://gitee.com/romkatv/powerlevel10k.git $&#123;ZSH_CUSTOM:-$HOME/.oh-my-zsh/custom&#125;/themes/powerlevel10k</span><br><span class="line"></span><br><span class="line"># 配置: vim ~/.zshrc</span><br><span class="line">ZSH_THEME=&quot;powerlevel10k/powerlevel10k&quot;</span><br></pre></td></tr></table></figure><p><a href="https://a1049145827.github.io/2019/05/15/Mac-%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85%E5%B9%B6%E9%85%8D%E7%BD%AE%E7%BB%88%E7%AB%AF%E7%A5%9E%E5%99%A8-oh-my-zsh/">参考-Mac 环境安装并配置终端神器 oh-my-zsh</a></p><h3 id="iterm"><a href="#iterm" class="headerlink" title="iterm"></a>iterm</h3><p>一款比较好用的终端工具，支持多窗口<br><a href="https://iterm2.com/downloads.html">下载地址</a></p><h4 id="使用技巧-快速登录指定节点"><a href="#使用技巧-快速登录指定节点" class="headerlink" title="使用技巧 - 快速登录指定节点"></a>使用技巧 - 快速登录指定节点</h4><p>iterm 本身没有记录节点列表的功能，如果需要随时连接指定节点（在公司一般都会用到），我们可以通过shell 脚本 + host 配置文件的方式，来实现快速登录指定节点</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"># vim /etc/my_hosts</span><br><span class="line">## 我的配置方式是 节点名 + 环境名 + 实际 ssh 连接的地址 + 端口</span><br><span class="line">docker local root@localhost 22</span><br><span class="line">docker db root@localhost 23</span><br><span class="line">cloud dev root@云主机ip 22</span><br><span class="line">compile dev root@内网编译专用机ip 22</span><br><span class="line"></span><br><span class="line"># vim /usr/local/bin/goto</span><br><span class="line">#!/bin/sh</span><br><span class="line">set -euxo pipefail</span><br><span class="line"></span><br><span class="line">echo &quot;hello go!&quot;</span><br><span class="line"></span><br><span class="line">if [ $# -lt 2 ]; then</span><br><span class="line">        echo &quot;Invalid input!&quot;</span><br><span class="line">        exit</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">node_name=$1</span><br><span class="line">env_name=$2</span><br><span class="line"></span><br><span class="line">login_node_full_info=`cat /etc/my_hosts | grep &quot;$node_name $env_name&quot;`</span><br><span class="line">if [ -z &quot;$login_node_full_info&quot; ]; then</span><br><span class="line">        echo &quot;Node not found!&quot;</span><br><span class="line">        exit</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">IFS=&#x27; &#x27; read -r -a node_split_arr &lt;&lt;&lt; &quot;$login_node_full_info&quot;</span><br><span class="line">#ssh -p$&#123;node_split_arr[3]&#125; $&#123;node_split_arr[2]&#125;</span><br><span class="line">ssh -o &quot;IdentitiesOnly=yes&quot; -i ~/.ssh/自己生成的免密密钥，可将公钥加到想登录的节点上，不需要每次都输密码  -p$&#123;node_split_arr[3]&#125; $&#123;node_split_arr[2]&#125;</span><br></pre></td></tr></table></figure><p>这样直接输入 goto 节点名 环境名 即可登录指定节点</p><h4 id="扩展-支持-lrzsz（文件上传和下载工具）"><a href="#扩展-支持-lrzsz（文件上传和下载工具）" class="headerlink" title="扩展: 支持 lrzsz（文件上传和下载工具）"></a>扩展: 支持 lrzsz（文件上传和下载工具）</h4><p>默认iterm 是不支持rz、sz 的，执行后会卡住，需要设置适配的脚本，比如执行 rz 的时候，打开文件列表</p><p>下载适配脚本</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cd /usr/local/bin</span><br><span class="line">sudo wget https://raw.githubusercontent.com/RobberPhex/iterm2-zmodem/master/iterm2-recv-zmodem.sh</span><br><span class="line">sudo wget https://raw.githubusercontent.com/RobberPhex/iterm2-zmodem/master/iterm2-send-zmodem.sh</span><br><span class="line"></span><br><span class="line">sudo chmod 777 /usr/local/bin/iterm2-*</span><br></pre></td></tr></table></figure><p>修改配置<br><img src="/2022/01/10/mac-init-software/iterm01.png" alt="iterm config"></p><p><img src="/2022/01/10/mac-init-software/iterm02.png" alt="iterm config"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Regular expression      Action  Parameters</span><br><span class="line">\*\*B0100       Run Silent Coprocess    /usr/local/bin/iterm2-send-zmodem.sh</span><br><span class="line">\*\*B00000000000000     Run Silent Coprocess    /usr/local/bin/iterm2-recv-zmodem.sh</span><br></pre></td></tr></table></figure><h3 id="lrzsz"><a href="#lrzsz" class="headerlink" title="lrzsz"></a>lrzsz</h3><p>文件上传、下载工具<br>当然多文件上传/下载 不支持确实比较麻烦，单文件的操作还是比较方便的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install lrzsz</span><br></pre></td></tr></table></figure><h3 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h3><p>Docker 对于开发者的重要性我在前面<a href="https://mp.weixin.qq.com/s/zmkzhIdL7Da_sfNauhAGRQ">公众号文章</a>有提过，主要就是开发环境的模拟和隔离，比如现在需要在 Arm 版本的 Mac 上开发 X86 的程序，就需要模拟一个 X86 的环境，直接通过 Docker 启动一个 X86 的镜像是比较方便的</p><p>建议在官网下载最新版，使用 brew 安装的版本可能会稍微旧一点</p><p><a href="https://www.docker.com/products/docker-desktop">官网下载</a></p><p>mac 电脑建议根据本身芯片架构选择匹配的版本，比如如果在 M1 版本上安装 X86 的 docker desktop，虽然镜像能跑，但是能耗可能会比较高<br>这边我还整理了开发镜像的制作方式，<a href="https://smiecj.github.io/2021/12/18/dockerfile-centos-dev/">参考博客</a>，可一键搭建包含 java、go 等语言的开发镜像</p><h3 id="Conda"><a href="#Conda" class="headerlink" title="Conda"></a>Conda</h3><p>安装 Python 的最佳工具，对不同环境之间可进行较好的隔离</p><p><a href="https://docs.conda.io/en/latest/miniconda.html">下载地址</a></p><p>建议下载脚本，下载完成后通过 sh 执行即可，然后会有一些设置安装路径的操作，建议放在 <strong>/Users/用户名/miniconda</strong> 目录下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sh /Users/username/Downloads/Miniconda3-latest-MacOSX-arm64.sh</span><br></pre></td></tr></table></figure><p>安装完成后在环境变量中配置 conda 路径</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># vim ~/.zshrc</span><br><span class="line">export CONDA_HOME=/Users/username/miniconda</span><br><span class="line">export PATH=$PATH:$CONDA_HOME/bin</span><br></pre></td></tr></table></figure><h2 id="性能测试"><a href="#性能测试" class="headerlink" title="性能测试"></a>性能测试</h2><h3 id="glances"><a href="#glances" class="headerlink" title="glances"></a>glances</h3><p>支持各操作系统的性能指标查看工具，使用 python 编写</p><p><a href="https://nicolargo.github.io/glances/">官网</a><br><a href="https://github.com/nicolargo/glances">git-nicolargo/glances</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install glances</span><br></pre></td></tr></table></figure><p><img src="/2022/01/10/mac-init-software/glances.png" alt="glances"></p><h3 id="Speed-Test"><a href="#Speed-Test" class="headerlink" title="Speed Test"></a>Speed Test</h3><p>磁盘速度测试工具，在 app store 上直接搜索: blackmagic disk speed test 即可</p><p><img src="/2022/01/10/mac-init-software/speedtest.png" alt="speed test"></p>]]></content>
      
      
      <categories>
          
          <category> 开发工具 </category>
          
          <category> mac </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 开发工具 </tag>
            
            <tag> mac </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>通过 DockerFile 搭建开发镜像</title>
      <link href="/2021/12/19/dockerfile-centos-dev/"/>
      <url>/2021/12/19/dockerfile-centos-dev/</url>
      
        <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>之前搭建过一个开发镜像，包含了 java、go 语言等基本的开发环境，结合 vscode remote 模式，可在本地直接进行开发，免去了安装各种基础环境和配置环境变量的麻烦<br><a href="https://mp.weixin.qq.com/s?__biz=MzU2MDkxMjkwMw==&mid=2247483773&idx=1&sn=a82edd0c3a8063348a7c325fe7f9773d">参考-Docker Desktop 安装方式和开发镜像分享</a></p><p>但是对于使用者来说，依然有两个并不方便的地方：</p><ul><li><p>易用性：对于使用 X86 系统来说，之前的开发镜像确实可以直接用，因为我的镜像就是基于 X86 系统的。但是对于arm 架构系统用户来说，可能就有适配问题了</p></li><li><p>开放性和扩展性：整个镜像的制作过程是封闭的，使用方只能拿到具体的镜像，无法了解到具体的构建过程，也无法对镜像在构建过程进行扩展</p></li><li><ul><li>比如我还想装其他开发语言，依然只能手动装，而且换台电脑之后可能还得这么来操作一次</li></ul></li></ul><p>综上，为了改进我们的开发镜像的这两点，通过 DockerFile 我们再构建一次之前的开发镜像</p><h2 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h2><p><a href="https://github.com/smiecj/docker-centos">项目git地址：docker-centos</a></p><p>先直接来看如何用新的开发镜像：直接下载工程 docker-centos，并通过 centos_dev 这个 Dockerfile 构建镜像</p><p>构建方法：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build --no-cache -f Dockerfiles/centos_dev -t centos_dev_test .</span><br></pre></td></tr></table></figure><p><img src="/2021/12/19/dockerfile-centos-dev/centos-dev_01.png" alt="code"></p><p>等待构建大约10分钟，构建完成后启动容器：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker images</span><br><span class="line"></span><br><span class="line">docker run -d --hostname code --name centos_dev_test --privileged=true -p 2222:22 centos_dev_test /usr/sbin/init</span><br></pre></td></tr></table></figure><p><img src="/2021/12/19/dockerfile-centos-dev/centos-dev_02.png" alt="code"></p><p>容器启动后，通过 Docker Desktop 打开命令行，检查相关依赖是否安装成功：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">source /etc/profile</span><br><span class="line">source ~/.bashrc</span><br><span class="line">java -version</span><br><span class="line">go version</span><br></pre></td></tr></table></figure><p><img src="/2021/12/19/dockerfile-centos-dev/centos-dev_03.png" alt="code"></p><h2 id="开发过程"><a href="#开发过程" class="headerlink" title="开发过程"></a>开发过程</h2><h3 id="DockerFile"><a href="#DockerFile" class="headerlink" title="DockerFile"></a>DockerFile</h3><p>目录：Dockerfiles/centos_dev</p><p>这里不需要做太多操作，只需要从 git 下载包含初始化系统脚本的仓库即可</p><p><img src="/2021/12/19/dockerfile-centos-dev/centos-dev_04.png" alt="code"></p><h3 id="初始化脚本"><a href="#初始化脚本" class="headerlink" title="初始化脚本"></a>初始化脚本</h3><p>目录：scripts/init-dev-system.sh</p><p>即初始化整个操作系统的脚本，大概就是下载 + 安装 + 配置环境变量的过程。笔者这里根据自己的开发需要，搭建了 java、go、python 和 nodejs 开发环境，具体版本如下：</p><ul><li>Java: OpenJDK 1.8</li><li>Go: 1.17</li><li>Python: Python3（MiniConda）</li><li>Nodejs: 14.17.0</li></ul><p>其他细节说明</p><ul><li>语言的可执行安装包统一放在 /usr/语言名 目录下，如: /usr/java</li><li>语言的下载依赖路径统一放在 /home/repo/语言名下，如: /usr/golang</li><li>Java 安装11 和 8 版本：8 用于编译，11 用于 vscode 的 java 插件顺利启动</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>用好工具就是提升开发效率的第一步～</p>]]></content>
      
      
      <categories>
          
          <category> 开发工具 </category>
          
          <category> docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> docker </tag>
            
            <tag> 开发工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>通过 Ambari 启动 Nebula Gateway 一段时间后会自动退出的问题解决</title>
      <link href="/2021/11/20/nebula-gateway-sigpipe/"/>
      <url>/2021/11/20/nebula-gateway-sigpipe/</url>
      
        <content type="html"><![CDATA[<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="http://senlinzhan.github.io/2017/03/02/sigpipe/">网络编程中的 SIGPIPE 信号</a></p><p><a href="https://coderatwork.cn/posts/sigpipe-tragedy/">SIGPIPE 引发的悲剧</a></p><p><a href="https://www.cnblogs.com/lit10050528/p/5116566.html">SIGPIPE信号详解</a></p><h2 id="问题概述"><a href="#问题概述" class="headerlink" title="问题概述"></a>问题概述</h2><p>在 Ambari 中集成了 nebula studio 1.0 版本，启动的组件包括：</p><ul><li>Studio: 通过 node 启动的 前端服务</li><li>Importer: 数据导入工具，可以将本地的CSV 文件导入到 graph</li><li>Gateway: 连接 studio 和 graph 服务的网关服务</li></ul><p>然后gateway组件的启动脚本是这样的：<br><strong>nohup ./nebula-http-gateway &gt;&gt; /var/log/nebula/gateway.log &amp;</strong></p><p>启动过程集成到了 ambari 中，然后通过界面启动gateway 服务，一开始服务正常启动没问题，但是在 studio 上进行一些图搜索操作之后，就会自动退出，而且服务日志中没有任何报错信息</p><p>但是直接在命令行执行的时候，就不会有任何问题，一开始百思不得其解</p><h2 id="相关基础知识"><a href="#相关基础知识" class="headerlink" title="相关基础知识"></a>相关基础知识</h2><h3 id="操作系统-stdout、stderr"><a href="#操作系统-stdout、stderr" class="headerlink" title="操作系统: stdout、stderr"></a>操作系统: stdout、stderr</h3><p>标准输出和错误输出</p><p>在命令行通过 nohup 打印，默认输出位置:<br>stdout: nohup.out<br>stderr: 直接忽略</p><h3 id="nebula-gateway-查询图数据逻辑"><a href="#nebula-gateway-查询图数据逻辑" class="headerlink" title="nebula gateway: 查询图数据逻辑"></a>nebula gateway: 查询图数据逻辑</h3><p>这里我们看 执行 nebula查询语句的关键方法: Execute<br>（gateway 版本：1.0）</p><blockquote><p>service/dao/dao.go</p></blockquote><p><img src="/2021/11/20/nebula-gateway-sigpipe/nebula01.png" alt="code"></p><p><img src="/2021/11/20/nebula-gateway-sigpipe/nebula02.png" alt="code"></p><p>Request 发给了一个 channel，然后 等待 response channel 接收到回复，最后处理 response ，返回成功 或者是打印 错误信息</p><h3 id="golang-打印日志的目标"><a href="#golang-打印日志的目标" class="headerlink" title="golang 打印日志的目标"></a>golang 打印日志的目标</h3><h4 id="println-stderr"><a href="#println-stderr" class="headerlink" title="println: stderr"></a>println: stderr</h4><p><img src="/2021/11/20/nebula-gateway-sigpipe/nebula03.png" alt="code"></p><h4 id="fmt-Println-stdout"><a href="#fmt-Println-stdout" class="headerlink" title="fmt.Println: stdout"></a>fmt.Println: stdout</h4><p><img src="/2021/11/20/nebula-gateway-sigpipe/nebula04.png" alt="code"></p><h4 id="log-Printf-log-Println-stderr"><a href="#log-Printf-log-Println-stderr" class="headerlink" title="log.Printf / log.Println: stderr"></a>log.Printf / log.Println: stderr</h4><p><img src="/2021/11/20/nebula-gateway-sigpipe/nebula05.png" alt="code"></p><blockquote><p>func (l *Logger) Output(calldepth int, s string) error {</p></blockquote><p><img src="/2021/11/20/nebula-gateway-sigpipe/nebula06.png" alt="code"></p><p><img src="/2021/11/20/nebula-gateway-sigpipe/nebula07.png" alt="code"></p><h3 id="SIGPIPE"><a href="#SIGPIPE" class="headerlink" title="SIGPIPE"></a>SIGPIPE</h3><p><a href="https://man7.org/linux/man-pages/man7/signal.7.html">linux-signal</a></p><p>SIGPIPE 和 强制终止 kill -9 类似，都是一种发送程序终止的信号。它表示向一个已经终止的socket 通道中写数据</p><p>这种情况也是比较常见的，因为可能因为网络的不稳定，服务端向客户端成功发送 FIN 之后，一直没有收到客户端回复的RSP，客户端如果又自行退出，就会导致服务端再次向客户端发送请求时，收到一个 SIGPIPE 信号<br>对于C 程序，默认情况下是不会忽略这个信号的，收到这个信号就会直接退出。可通过执行 <strong>signal(SIGPIPE, SIG_IGN);</strong> 方法忽略之</p><h2 id="定位过程"><a href="#定位过程" class="headerlink" title="定位过程"></a>定位过程</h2><h3 id="打印进程详细日志"><a href="#打印进程详细日志" class="headerlink" title="打印进程详细日志"></a>打印进程详细日志</h3><p>strace：可打印进程的内核操作详细信息的工具<br>strace -p pid: 打印指定进程的详细信息</p><p><img src="/2021/11/20/nebula-gateway-sigpipe/nebula08.png" alt="strace"></p><p>这里很明显进程退出的原因 就是接收到了 SIGPIPE 信号</p><h3 id="原因分析"><a href="#原因分析" class="headerlink" title="原因分析"></a>原因分析</h3><p>结合前面的基本知识，可大致判断就是 <strong>Ambari 通过一个sub process 执行 gateway 的启动脚本，在执行完成之后，子进程退出了，但是 gateway 依然往子进程的标准输出中打印日志（写日志也是socket操作），就会导致 gateway 接收到 SIGPIPE 信号，并最后退出</strong></p><p>为了最终确定，我们再看一下 ambari 的Execute 方法实现，可看到它会把错误输出定位到标准输出，标准输出默认是和 进程 强绑定的，进程退出了，就无法再打印日志了</p><blockquote><p>ambari-common/src/main/python/resource_management/core/resources/system.py</p></blockquote><p>class Execute(Resource):</p><p>而 gateway 通过 log.Printf 打印 response 的错误信息，会将日志打印到stderr，印证了这个退出的原因</p><h2 id="问题解决"><a href="#问题解决" class="headerlink" title="问题解决"></a>问题解决</h2><p>修改gateway 启动脚本，将 stdout 和 stderr 都重定向到日志文件即可</p><p>nohup ./nebula-http-gateway <strong>&gt; /var/log/nebula/gateway.log 2&gt;&amp;1</strong> &amp;</p><p>再次操作 nebula studio，看到 gateway 打印的日志能正常在 nohup.out 中打印了</p><p><img src="/2021/11/20/nebula-gateway-sigpipe/nebula10.png" alt="log"></p><h2 id="小总结"><a href="#小总结" class="headerlink" title="小总结"></a>小总结</h2><p>虽然最后解决 也就是一行代码的事情，但是发现这个问题根因的过程还是挺有意思的</p>]]></content>
      
      
      <categories>
          
          <category> 大数据 </category>
          
          <category> 问题解决 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 大数据 </tag>
            
            <tag> nebula </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo 博客搭建教程</title>
      <link href="/2021/08/13/hexo-blog/"/>
      <url>/2021/08/13/hexo-blog/</url>
      
        <content type="html"><![CDATA[<h2 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h2><p><a href="https://smiecj.github.io/">博客首页</a><br><img src="/2021/08/13/hexo-blog/hexo_blog_01.png" alt="blog front page"></p><p><img src="/2021/08/13/hexo-blog/hexo_blog_12.png" alt="blog front page"></p><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>之前自己的博客都是放在csdn上，分类管理起来不是很方便，而且分类在左下角，不是特别显眼的地方<br><img src="/2021/08/13/hexo-blog/hexo_blog_03.png" alt="csdn page"></p><p>公众号的标签功能还可以，不过自己还是希望有个个人站点能专门管理写过的博客，主题最好是能一目了然，不仅仅是别人看着方便，以后自己整理资料的时候找得也方便</p><p>既然有这个需求，那就试试呗，看看个人站点怎么搭建，据说不难的</p><h2 id="踩坑记-hugo工具短暂的体验"><a href="#踩坑记-hugo工具短暂的体验" class="headerlink" title="踩坑记 - hugo工具短暂的体验"></a>踩坑记 - hugo工具短暂的体验</h2><p>hugo 是一个用golang 写的博客搭建工具，主要功能是可一键生成博客，我们自己只需要写markdown 格式的文章就行了，前端静态文件都是通过hugo 进行渲染生成的。方便是方便，但是一直没有找到特别满意的主题。<br>其实自己对主题的要求也没有说特别高，主要是要简洁、重点明了就好了，那种特别花哨、或者是基本功能欠缺的主题都是不考虑的<br>所以最后放弃了hugo。一次偶然的机会，和一个前端同学聊，知道了有hexo 这样一个工具，同样是生成博客的，那就试试呗</p><p><a href="https://jeshs.github.io/2019/01/hugo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E4%B8%80%E6%90%AD%E5%BB%BAhugo%E5%8D%9A%E5%AE%A2/">参考-hugo搭建教程</a></p><blockquote><p>hugo基本指令:</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">创建一篇博客:</span><br><span class="line">hugo new site myblog</span><br><span class="line">启动服务:</span><br><span class="line">hugo server -D --bind=&quot;0.0.0.0&quot;</span><br></pre></td></tr></table></figure><h2 id="hexo-主题介绍"><a href="#hexo-主题介绍" class="headerlink" title="hexo 主题介绍"></a>hexo 主题介绍</h2><p>hexo 和 hugo 最大的优势我觉得就是主题库了，这里介绍几个个人感觉还不错的：</p><table><thead><tr><th>主题</th><th>风格</th><th>demo</th></tr></thead><tbody><tr><td><a href="https://github.com/yscoder/hexo-theme-indigo">Indigo</a></td><td>蓝色主题、简洁</td><td><a href="https://wuyang910217.github.io/">wuyang的个人博客</a></td></tr><tr><td><a href="https://github.com/jerryc127/hexo-theme-butterfly">butterfly</a></td><td>首页展示大幅背景图，表现力强</td><td><a href="https://yunist.cn/">云玩家</a></td></tr><tr><td><a href="https://github.com/Molunerfinn/hexo-theme-melody">melody</a></td><td>白色主题、简洁</td><td><a href="https://molunerfinn.com/">MARKSZのBlog</a></td></tr></tbody></table><p>其实自己也是后面看了这些主题的样式，才发现原来好多大神的个人站点都是通过 hexo 搭建的，有些前端技术比较厉害的，还会尝试自己去魔改，希望自己也有一天可以尝试一下</p><h2 id="本地搭建方式"><a href="#本地搭建方式" class="headerlink" title="本地搭建方式"></a>本地搭建方式</h2><h3 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h3><p><a href="https://github.com/hexojs/hexo">hexo</a> 是 node 开发的框架，所以需要通过 npm 来安装</p><blockquote><p>安装hexo 框架</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g hexo-cli</span><br></pre></td></tr></table></figure><blockquote><p>创建博客工程</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo init myblog</span><br></pre></td></tr></table></figure><blockquote><p>工程结构简述</p></blockquote><p><img src="/2021/08/13/hexo-blog/hexo_blog_04.png" alt="hexo structure"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">_config.yml: 主配置文件，后续修改主题之类的就是改这里</span><br><span class="line">themes: 主题目录</span><br><span class="line">scaffolds: 博客模板，通过 hexo new page 生成的页面都以这里的md 文件为模板</span><br><span class="line">source: 存放用户资源</span><br><span class="line">package.json: 本质上 hexo 博客还是一个前端项目，所以在这里管理依赖</span><br></pre></td></tr></table></figure><h3 id="设置主题"><a href="#设置主题" class="headerlink" title="设置主题"></a>设置主题</h3><p>这一步主要是在 <strong>themes</strong> 目录下，存放主题代码目录，这样 hexo 启动博客主页的时候，就是以你放的主题来生成了<br>有两种下载主题的方式：你可以直接将主题git 代码下载下来，放到themes 目录，或者是fork 一份主题仓库，通过 git submodule clone 一份代码。如果有兴趣自己做主题魔改，更建议后者</p><p>通过 git submodule 下载：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git submodule add git@github.com:主题仓库.git themes/主题名称</span><br></pre></td></tr></table></figure><p>下载完成之后，将_config.yml 中的主题名称修改一下<br><img src="/2021/08/13/hexo-blog/hexo_blog_05.png" alt="hexo structure"></p><p>安装渲染工具</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-renderer-pug hexo-renderer-stylus --save</span><br><span class="line">npm install --save hexo-renderer-pug hexo-renderer-jade hexo-generator-feed hexo-generator-sitemap hexo-browsersync hexo-generator-archive hexo-renderer-stylus</span><br></pre></td></tr></table></figure><h3 id="启动博客"><a href="#启动博客" class="headerlink" title="启动博客"></a>启动博客</h3><blockquote><p>清理静态文件</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo clean</span><br></pre></td></tr></table></figure><blockquote><p>生成静态文件</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo g</span><br></pre></td></tr></table></figure><blockquote><p>启动服务</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">hexo server -w -p 3000</span><br><span class="line"></span><br><span class="line"># 启动服务</span><br><span class="line"># -w: watch，监听文件变化</span><br><span class="line"># -p: port，启动端口</span><br></pre></td></tr></table></figure><p>到这一步完成，博客基本框架就算搭建成功了~</p><h2 id="基本配置的介绍"><a href="#基本配置的介绍" class="headerlink" title="基本配置的介绍"></a>基本配置的介绍</h2><p>这里我们对一些博客配置做简单的了解，方便后续进行主题设置。当然博客部署完成之后，也可以直接部署到github 上，先不管这些配置。你也可以直接跳到下一节内容进行参考。<br>如果想了解大部分的配置，建议参考下面的官方教程<br><a href="https://butterfly.js.org/posts/4aa8abbe">参考-官方教程</a></p><h3 id="网站信息"><a href="#网站信息" class="headerlink" title="网站信息"></a>网站信息</h3><p>站点基本配置</p><p><img src="/2021/08/13/hexo-blog/hexo_blog_06.png" alt="blog config"></p><p>头像和首页背景图</p><p><img src="/2021/08/13/hexo-blog/hexo_blog_07.png" alt="head config"></p><h3 id="文章"><a href="#文章" class="headerlink" title="文章"></a>文章</h3><p>文章封面: 设置cover属性<br><img src="/2021/08/13/hexo-blog/hexo_blog_08.png" alt="blog top img config"></p><p>效果:<br><img src="/2021/08/13/hexo-blog/hexo_blog_09.png" alt="blog top img show"></p><h3 id="顶部栏"><a href="#顶部栏" class="headerlink" title="顶部栏"></a>顶部栏</h3><p><img src="/2021/08/13/hexo-blog/hexo_blog_10.png" alt="blog top config"></p><p>其中，标签、分类页面可通过下面的指令新建:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo new page tags</span><br><span class="line">hexo new page categories</span><br></pre></td></tr></table></figure><h2 id="部署到github站点"><a href="#部署到github站点" class="headerlink" title="部署到github站点"></a>部署到github站点</h2><h3 id="github-创建仓库"><a href="#github-创建仓库" class="headerlink" title="github 创建仓库"></a>github 创建仓库</h3><p>github 能够识别 用户名.github.io 的仓库名，并部署这个仓库的静态文件生成站点，站点地址就是 用户名.github.io<br><img src="/2021/08/13/hexo-blog/hexo_blog_11.png" alt="blog deploy config"></p><h3 id="配置准备"><a href="#配置准备" class="headerlink" title="配置准备"></a>配置准备</h3><p>修改博客根目录的 config.yml 文件:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repo: &lt;repository url&gt; #https://bitbucket.org/JohnSmith/johnsmith.bitbucket.io</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure><p>这样先执行 <strong>hexo g</strong> 生成静态文件之后，再执行 <strong>hexo d</strong> 就可以将静态文件 提交到站点仓库上了<br>如果是在本地开发，建议 repo 配置成 ssh 的地址，部署更方便</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>天下无难事 – 其实很早就看到过，这次尝试自己搭建，其实不麻烦<br>当然，要真正做成一个内容丰富的个人博客站点，还是要慢慢积累丰富的内容才行。有的大神就纯做技术博客（比如<a href="https://www.liaoxuefeng.com/">廖雪峰</a>），有的大神则搞一些炫酷的效果（如<a href="https://www.yunyoujun.cn/about/">云游君的小站</a>），最后都能做得很有知名度。当然，最重要的还是要有核心的技术，博客积累关键还是在于个人的技术积累。<br>所以，慢慢来吧，共勉</p>]]></content>
      
      
      <categories>
          
          <category> 开发工具 </category>
          
          <category> hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 个人博客 </tag>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Golang 常见的10种错误</title>
      <link href="/2021/07/18/golang-mistakes/"/>
      <url>/2021/07/18/golang-mistakes/</url>
      
        <content type="html"><![CDATA[<p><a href="https://itnext.io/the-top-10-most-common-mistakes-ive-seen-in-go-projects-4b79d4f6cd65#e9ba">原文链接</a></p><p>前言：这里提到的错误，并不是那种“致命错误”，而是业务中的使用习惯的问题。如果不够了解语言的设计方式，导致使用习惯不当，可能就会引入一些设计不够好的代码。因此学习这些前人对使用方式的总结是很有帮助的。<br>话不多说，一起来看看都有哪些常见易犯的错误：</p><h3 id="一、枚举默认值和json反序列化"><a href="#一、枚举默认值和json反序列化" class="headerlink" title="一、枚举默认值和json反序列化"></a>一、枚举默认值和json反序列化</h3><p>先来看一段枚举的定义：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">type Status uint32</span><br><span class="line"></span><br><span class="line">const (</span><br><span class="line">  StatusOpen Status = iota</span><br><span class="line">  StatusClosed</span><br><span class="line">  StatusUnknown</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>然后业务结构体 Request 引用了这个枚举</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">type Request struct &#123;</span><br><span class="line">  ID        int    `json:&quot;Id&quot;`</span><br><span class="line">  Timestamp int    `json:&quot;Timestamp&quot;`</span><br><span class="line">  Status    Status `json:&quot;Status&quot;`</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后就是常见的接口之后的反序列化过程了，如果是正常的接口返回，如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;Id&quot;: 1234,</span><br><span class="line">  &quot;Timestamp&quot;: 1563362390,</span><br><span class="line">  &quot;Status&quot;: 0</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么反序列化之后应该也是很正常的，调用方拿到了下游返回的状态信息，状态也都对得上。<br>但是如果下游有问题，没有返回这个状态：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;Id&quot;: 1235,</span><br><span class="line">  &quot;Timestamp&quot;: 1563362390</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个时候后台拿到的状态是什么？又应该是什么？可以直接写段代码测试一下。</p><p>最终：一个更健壮的枚举定义：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">type Status uint32</span><br><span class="line"></span><br><span class="line">const (</span><br><span class="line">  StatusUnknown Status = iota</span><br><span class="line">  StatusOpen</span><br><span class="line">  StatusClosed</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>别看是一个小问题，影响可不小，如果结构体设计阶段没有考虑到这个问题，需要发版之后再修复，可能要改的还有下游的结构体定义，而如果结构体是放在公共的pb 文件中，要改pb ，那么要影响到的服务可能就更多了。<br>所以元数据的定义永远是基础，牵一发而动全身。设计的时候还是要更考虑周全一些。需要从 业务逻辑转换成编程思维，考虑到更多的细节。<br><a href="https://github.com/smiecj/go_common_mistake/blob/master/error_test.go">参考测试代码-enum_test.go</a></p><h3 id="二、BenchMarking和内联"><a href="#二、BenchMarking和内联" class="headerlink" title="二、BenchMarking和内联"></a>二、BenchMarking和内联</h3><p><a href="https://segmentfault.com/a/1190000039146279">参考博客-详解Go内联优化</a></p><p>性能测试相关的代码，往往需要重复执行，如果写法不当，就很容易导致内联的问题：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">func clear(n uint64, i, j uint8) uint64 &#123;</span><br><span class="line">return (math.MaxUint64&lt;&lt;j | ((1 &lt;&lt; i) - 1)) &amp; n</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func BenchmarkCleanBit(b *testing.B) &#123;</span><br><span class="line">for i := 0; i &lt; b.N; i++ &#123;</span><br><span class="line">clear(1221892080809121, 10, 63)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里先说明一下 testing.B 这个类的功能：它表示基准测试，在测试结束之后将会输出一段性能测试的结果<br>测试方法必须是 BenchMark 开头，另外执行测试需要带上 bench 参数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go test -bench=. benchmark_test.go</span><br></pre></td></tr></table></figure><p>测试结果：</p><p>goos: windows<br>goarch: amd64<br>pkg: github.com/smiecj/go_common_mistake<br>BenchmarkCleanBit<br>BenchmarkCleanBit-8     1000000000           <strong>0.339 ns/op</strong><br>PASS</p><p>但是接下来要说到问题了：由于 clear 方法没有执行其他方法的调用，没有边际效应，所以会被内联，再加上其返回值也没有被外层接收，所以又会被进一步优化掉，直接不会执行。所以其实测试结果是不准的。<br>怎么确认 clear 方法被内联了呢？可以通过编译参数确认：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go test -gcflags=&quot;-m&quot; -bench=. benchmark_test.go</span><br></pre></td></tr></table></figure><blockquote><p>-gcflags=”-m”: 打印编译过程中 golang 解析产生内联的详细过程</p></blockquote><p>所以验证的方式也很简单，只要避免内联就可以了。结合这个性能测试的示例，大概有两种方式：<br>① 在 BenchMark 中设置一个局部变量去接收返回值</p><p>② clear 方法最上面设置取消内联</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//go:noinline</span><br><span class="line">func clear(n uint64, i, j uint8) uint64 &#123;</span><br><span class="line">  return (math.MaxUint64&lt;&lt;j | ((1 &lt;&lt; i) - 1)) &amp; n</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>新的测试结果：<br>goos: windows<br>goarch: amd64<br>pkg: github.com/smiecj/go_common_mistake<br>BenchmarkCleanBit<br>BenchmarkCleanBit-8     426727659          <strong>2.96 ns/op</strong><br>PASS</p><p>③ 设置编译参数 -l 禁止内联</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go test -gcflags=&quot;-N -l -m&quot; -bench=. benchmark_test.go</span><br></pre></td></tr></table></figure><blockquote><p>-N：禁止编译优化<br>-l：禁止内联</p></blockquote><p>测试结果：<br>goos: windows<br>goarch: amd64<br>BenchmarkCleanBit-8     376172835                <strong>3.13 ns/op</strong><br>PASS<br>ok      command-line-arguments  2.361s</p><p>扩展阅读：<br><a href="https://dave.cheney.net/high-performance-go-workshop/dotgo-paris.html">High Performance Go Workshop</a></p><h3 id="三、每次传参都应该用指针吗？"><a href="#三、每次传参都应该用指针吗？" class="headerlink" title="三、每次传参都应该用指针吗？"></a>三、每次传参都应该用指针吗？</h3><p>首先，就传递数据量来说，指针毫无疑问，在大多数时候还是更省空间的。（64位系统中是8个字节）</p><p>看起来似乎指针总比传值更好，对吧？其实不是的，我们可能只关注了参数本身的空间开销，却忽略了指针和值分别在栈和堆上的存储开销。<br>先从方法的返回值去理解返回参数和返回指针的区别，来看个例子: </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">func getFooValue() foo &#123;</span><br><span class="line">  var result foo</span><br><span class="line">  // Do something</span><br><span class="line">  return result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法内部新建了result对象，这个对象只可能被方法内部访问，所以这个对象分配的空间就在栈上，不会在堆上。<br>然后，方法直接返回了值本身，这个动作会生成一份result的拷贝，存储在调用方的栈上，原result因为不会再被访问，将等待被GC回收。</p><p>再来看返回指针的情况:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">func main()  &#123;</span><br><span class="line">  p := &amp;foo&#123;&#125;</span><br><span class="line">  f(p)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Go只有传值，所以对于指针p来说，它的空间申请和传递，都是和上一个例子一样的。但是对于foo对象本身，申请的时候必然不会在栈上申请，而会在堆上申请。这样才能让作用域扩大到调用方。</p><p>栈比堆更快的两个原因:</p><ul><li>栈上对象不需要GC，从上面的例子可以看到，除非返回指针，否则栈内的一切对象都跟调用方没有任何关系，都是拷贝后返回，因此可以在方法结束后直接被标记。</li><li>栈上对象只会在当前routine被使用，不需要和其他协程同步，也就不会在堆上记录任何状态信息</li></ul><p>总结来说，就是不管是传参还是返回，只要非共享的场景（当然，复合数据结构如map一般都是需要共享的），都建议传value，只有一定要传指针的时候才去传指针。</p><p>扩展阅读<br><a href="https://www.ardanlabs.com/blog/2017/05/language-mechanics-on-stacks-and-pointers.html">Language Mechanics On Stacks And Pointers</a></p><h3 id="四、break和条件控制语句"><a href="#四、break和条件控制语句" class="headerlink" title="四、break和条件控制语句"></a>四、break和条件控制语句</h3><p>如下面这段代码，break 真的能够跳出循环吗？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">for &#123;</span><br><span class="line">  switch f() &#123;</span><br><span class="line">  case true:</span><br><span class="line">    break</span><br><span class="line">  case false:</span><br><span class="line">    // Do something</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>答案：break 其实是跳出 switch 的循环。但是golang 的switch 执行完成一个分支之后其他分支也不会执行的，所以 switch 的 break 其实没有什么意义</p><p>但是select 的break 就有意义了。所以下面这种情况也是要特别注意的，break 跳出的也不是循环<br>for {<br>  select {<br>  case &lt;-ch:<br>  // Do something<br>  case &lt;-ctx.Done():<br>    break<br>  }<br>}</p><p>常见的退出循环+switch的方式：break + 代码块名称</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">OuterLoop:</span><br><span class="line">  for i = 0; i &lt; n; i++ &#123;</span><br><span class="line">    for j = 0; j &lt; m; j++ &#123;</span><br><span class="line">      switch a[i][j] &#123;</span><br><span class="line">      case nil:</span><br><span class="line">        state = Error</span><br><span class="line">        break OuterLoop</span><br><span class="line">      case item:</span><br><span class="line">        state = Found</span><br><span class="line">        break OuterLoop</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3 id="五、错误管理"><a href="#五、错误管理" class="headerlink" title="五、错误管理"></a>五、错误管理</h3><p>error的处理一般满足两个原则：处理了就不要再向上继续抛出，必须给上层返回不一样的信息；没处理就一定要继续向上抛出</p><p>而go1.13之前提供的error 管理方法其实很少，所以这里我们使用 pkg/errors 这个工具来帮我们更好地管理自定义错误：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">import &quot;github.com/pkg/errors&quot;</span><br><span class="line">......</span><br><span class="line">func postHandler(customer Customer) Status &#123;</span><br><span class="line">  err := insert(customer.Contract)</span><br><span class="line">  if err != nil &#123;</span><br><span class="line">    switch errors.Cause(err).(type) &#123;</span><br><span class="line">    default:</span><br><span class="line">      log.WithError(err).Errorf(&quot;unable to serve HTTP POST request for customer %s&quot;, customer.ID)</span><br><span class="line">      return Status&#123;ok: false&#125;</span><br><span class="line">    case *db.DBError:</span><br><span class="line">      return retry(customer)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">  return Status&#123;ok: true&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func insert(contract Contract) error &#123;</span><br><span class="line">  err := db.dbQuery(contract)</span><br><span class="line">  if err != nil &#123;</span><br><span class="line">    return errors.Wrapf(err, &quot;unable to insert customer contract %s&quot;, contract.ID)</span><br><span class="line">  &#125;</span><br><span class="line">  return nil</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意到判断错误类型使用对象的type判断就可以了，<strong>Cause</strong>和<strong>Wrapf</strong>需要配套使用</p><h3 id="六、数组初始化"><a href="#六、数组初始化" class="headerlink" title="六、数组初始化"></a>六、数组初始化</h3><h4 id="6-1-len-和-cap"><a href="#6-1-len-和-cap" class="headerlink" title="6.1 len 和 cap"></a>6.1 len 和 cap</h4><p>我们知道数组有两个初始化参数，分别表示len和cap，分别表示长度和初始化长度。<br>比如初始化一个空数组：<br>var bars []Bar<br>bars := make([]Bar, 0, 0)</p><p>和Java不同的是，go把 cap 设置也半交给用户了（当不配置cap 的时候，len 就是 cap）。但是这也<br>比如当我们把 cap 设置成负数，或者小于 len 的时候，会发生什么呢？<br>直接测试一下：<br><img src="https://img-blog.csdnimg.cn/20210718103648191.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3hpYW9saWl6aQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>可以看到编译期 就已经直接报错了，不会让你能够执行这样的代码。我们可以从types/expr.go 中找到具体报错信息打印的地方。</p><h4 id="6-2-设置len-还是-cap-的效率高"><a href="#6-2-设置len-还是-cap-的效率高" class="headerlink" title="6.2 设置len 还是 cap 的效率高"></a>6.2 设置len 还是 cap 的效率高</h4><p>来看一种比较常见的场景：需要把数据库的对象转换成对外接口传递的对象。对象数量是确定的，需要怎么做呢？<br>有两种实现方式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">func convert(foos []Foo) []Bar &#123;</span><br><span class="line">  bars := make([]Bar, len(foos))</span><br><span class="line">  for i, foo := range foos &#123;</span><br><span class="line">    bars[i] = fooToBar(foo)</span><br><span class="line">  &#125;</span><br><span class="line">  return bars</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">func convert(foos []Foo) []Bar &#123;</span><br><span class="line">  bars := make([]Bar, 0, len(foos))</span><br><span class="line">  for _, foo := range foos &#123;</span><br><span class="line">    bars = append(bars, fooToBar(foo))</span><br><span class="line">  &#125;</span><br><span class="line">  return bars</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实两种实现方式都可以，但是前者效率显然高一些，因为空间是已经分配好的，而后者虽然cap 设定了，但是随着 不断append 元素，底层也是要不断地进行数组的拷贝的。</p><blockquote><p>译者：文章这里基本没有从源码说明效率高的原因，后续考虑新开一篇，从makeslice 方法去分析两种方式真正的差异</p></blockquote><h3 id="七、context-管理"><a href="#七、context-管理" class="headerlink" title="七、context 管理"></a>七、context 管理</h3><h4 id="7-1-什么是context"><a href="#7-1-什么是context" class="headerlink" title="7.1 什么是context"></a>7.1 什么是context</h4><p>官方概念：<br>A Context carries a deadline, a cancelation signal, and other values across API boundaries.</p><p>这里说明了context可以带的三类信息：deadline（超时配置）、cancelation（终止动作）和values（键值对）</p><h4 id="7-2-什么时候应该用context"><a href="#7-2-什么时候应该用context" class="headerlink" title="7.2 什么时候应该用context"></a>7.2 什么时候应该用context</h4><p>前两个信息是context最常用的信息和功能，最常用的场景就是rpc调用，来看看一个grpc使用示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ctx, cancel := context.WithTimeout(parent, 100 * time.Millisecond)</span><br><span class="line">response, err := grpcClient.Send(ctx, request)</span><br></pre></td></tr></table></figure><p>WithTimeout 方法内部就是设置了 deadline，context 将会在超时时间到来的时候触发 Done 对应的channel close。这样我们可以通过 &lt;- context.Done) 来做一些提前结束的操作，比如释放资源，避免超时请求一直阻塞其他正常请求。</p><p>总结一下，凡是涉及到上下游关系的都应该用context来处理调用关系，下游不应该忽略上游传下来的context。</p><p>扩展阅读：<br><a href="http://p.agnihotry.com/post/understanding_the_context_package_in_golang/">Understanding the context package in golang</a></p><h3 id="八、从来不用-race-参数"><a href="#八、从来不用-race-参数" class="headerlink" title="八、从来不用 -race 参数"></a>八、从来不用 -race 参数</h3><p>根据 报告-Understanding real-world concurrency bugs in Go ，尽管go 的设计初衷是“更少错误的高并发”，但是现实中我们依然会遇到并发带来的问题<br>尽管 race 检测器不一定可以检测出每一种并发错误，但是它依然是有价值的，在测试程序的过程中我们应该始终打开它。</p><p>相对其余9个错误来说，竞态条件是能直接导致程序崩溃的，所以这一节应该是最重要的一部分，建议gopher 在平时开发中都尽量留意这一点，测试和调试工作要做好。<br>但是 开启race 也不代表 冲突能够马上检查出来，也是要有冲突的时候，才会有Warning信息。所以建议采用线上环境留一个节点用来开启竞态检查的方式。</p><p>扩展阅读：<br><a href="https://blog.acolyer.org/2019/05/17/understanding-real-world-concurrency-bugs-in-go/">Understanding real-world concurrency bugs in Go</a><br><a href="https://medium.com/@val_deleplace/does-the-race-detector-catch-all-data-races-1afed51d57fb">Does the Go race detector catch all data race bugs?</a><br><a href="https://github.com/smiecj/go_common_mistake/blob/master/race_test.go">自己写的示例-git-race_test.go</a></p><h3 id="九、使用文件名作为输入（方法设计不满足SOLID原则）"><a href="#九、使用文件名作为输入（方法设计不满足SOLID原则）" class="headerlink" title="九、使用文件名作为输入（方法设计不满足SOLID原则）"></a>九、使用文件名作为输入（方法设计不满足SOLID原则）</h3><h4 id="9-1-从问题出发"><a href="#9-1-从问题出发" class="headerlink" title="9.1 从问题出发"></a>9.1 从问题出发</h4><p>来看一个常见的go 工具类开发需求：需要开发一个通用的读取文件行数的方法。项目中肯定会把这个方法封装到公共包的。<br>一种比较直接的思路，就是设置文件名作为传参，如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">func count(filename string) (int, error) &#123;</span><br><span class="line">  file, err := os.Open(filename)</span><br><span class="line">  if err != nil &#123;</span><br><span class="line">    return 0, errors.Wrapf(err, &quot;unable to open %s&quot;, filename)</span><br><span class="line">  &#125;</span><br><span class="line">  defer file.Close()</span><br><span class="line"></span><br><span class="line">  scanner := bufio.NewScanner(file)</span><br><span class="line">  count := 0</span><br><span class="line">  for scanner.Scan() &#123;</span><br><span class="line">    if scanner.Text() == &quot;&quot; &#123;</span><br><span class="line">      count++</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return count, nil</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种方式看上去功能没有任何问题，但是忽略了具体使用场景。如：</p><ul><li>文件编码：当然你可以让方法增加一个传参，但是不符合接下来说到的开闭原则</li><li>单元测试：测试读取一个空文件场景。那么单测可能还需要先在本地创建一个空文件</li></ul><p>这些细节，都会导致这个方法看上去完美，实际使用起来限制却很多。</p><h4 id="9-2-SOLID-原则"><a href="#9-2-SOLID-原则" class="headerlink" title="9.2 SOLID 原则"></a>9.2 SOLID 原则</h4><p>SOLID 是面向对象编程中很重要的原则，由 总结而来。</p><ul><li>S 表示  Single Responsibility （单一原则）：一个方法只做一件事</li><li>O 表示 open-close principle （开闭原则）：方法对扩展开放，对修改封闭</li></ul><p>从这个例子就是很好的说明：S 和 O 它实际都不满足，方法做了读取文件和扫描文件行数两件事、方法可能还需要因为文件编码做格式 做适配修改</p><h4 id="9-3-优化版本"><a href="#9-3-优化版本" class="headerlink" title="9.3 优化版本"></a>9.3 优化版本</h4><p>借鉴 go 对 io.Reader 和 io.Writer 的实现思路，我们可以将传参改成这样：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">func count(reader *bufio.Reader) (int, error) &#123;</span><br><span class="line">  count := 0</span><br><span class="line">  for &#123;</span><br><span class="line">    line, _, err := reader.ReadLine()</span><br><span class="line">    if err != nil &#123;</span><br><span class="line">      switch err &#123;</span><br><span class="line">      default:</span><br><span class="line">        return 0, errors.Wrapf(err, &quot;unable to read&quot;)</span><br><span class="line">      case io.EOF:</span><br><span class="line">        return count, nil</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if len(line) == 0 &#123;</span><br><span class="line">      count++</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样不仅满足和 S 和 O，方法的扩展性其实也加强了：可以读取文件流或者 http 流等的输入</p><p>调用端：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">file, err := os.Open(filename)</span><br><span class="line">if err != nil &#123;</span><br><span class="line">  return errors.Wrapf(err, &quot;unable to open %s&quot;, filename)</span><br><span class="line">&#125;</span><br><span class="line">defer file.Close()</span><br><span class="line">count, err := count(bufio.NewReader(file))</span><br></pre></td></tr></table></figure><p>单测：读取一行字符串流</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">count, err := count(bufio.NewReader(strings.NewReader(&quot;input&quot;)))</span><br></pre></td></tr></table></figure><p>因此，设计思想也非常重要，尽管代码规范之类的问题并不会直接导致程序运行问题，但是显然它的影响更为深远。</p><h3 id="十、协程和循环中的局部变量"><a href="#十、协程和循环中的局部变量" class="headerlink" title="十、协程和循环中的局部变量"></a>十、协程和循环中的局部变量</h3><h4 id="10-1-协程共用循环的局部变量"><a href="#10-1-协程共用循环的局部变量" class="headerlink" title="10.1 协程共用循环的局部变量"></a>10.1 协程共用循环的局部变量</h4><p>下面这段示例，会输出什么？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">func TestRoutineRace(t *testing.T) &#123;</span><br><span class="line">ints := []int&#123;1, 2, 3&#125;</span><br><span class="line">waitGroup := sync.WaitGroup&#123;&#125;</span><br><span class="line">waitGroup.Add(len(ints))</span><br><span class="line"></span><br><span class="line">for _, i := range ints &#123;</span><br><span class="line">go func() &#123;</span><br><span class="line">fmt.Printf(&quot;%v\n&quot;, i)</span><br><span class="line">waitGroup.Done()</span><br><span class="line">&#125;()</span><br><span class="line">&#125;</span><br><span class="line">waitGroup.Wait()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>显然目的是想打印 1、2、3的，但是结果却都是3<br>这是因为 子协程中，打印用的都是同一个局部变量i，这个i 在循环结束之后会变成3，所以最终打印的结果就都是3 了（大部分时候）</p><p>利用刚才学的race，这种使用协程的错误方式也可以通过 -race 参数 提前检测出来。<br>go test -v <strong>-race</strong> routine_test.go<br>检测结果：<br>……<br>WARNING: DATA RACE<br><strong>Read at 0x00c000116140 by goroutine 8:</strong><br>  command-line-arguments.TestRoutine.func1()<br>      D:/coding/golang/go_common_mistake/routine_test.go:16 +0x44</p><p><strong>Previous write at 0x00c000116140 by goroutine 7:</strong><br>  command-line-arguments.TestRoutine()<br>      D:/coding/golang/go_common_mistake/routine_test.go:14 +0x104<br>  testing.tRunner()<br>      G:/Program Files/Go/src/testing/testing.go:1127 +0x202<br>……</p><p>从错误信息可以看到，省略的部分还有其他协程，同样的警告信息。仔细分析下来就可以得到协程用的都是同一个局部变量的结论了。<br>怎么样，马上就体验到 -race 参数的作用了，是不是很妙</p><h4 id="10-2-避免直接使用循环中的局部变量"><a href="#10-2-避免直接使用循环中的局部变量" class="headerlink" title="10.2 避免直接使用循环中的局部变量"></a>10.2 避免直接使用循环中的局部变量</h4><p>对于这种情况有两种解决方法：<br>1）go func 加上入参</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">for _, i := range ints &#123;</span><br><span class="line">go func(i int) &#123;</span><br><span class="line">fmt.Printf(&quot;%v\n&quot;, i)</span><br><span class="line">waitGroup.Done()</span><br><span class="line">&#125;(i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2）循环内使用单独的局部变量<br><img src="/img/20210718105358253.png" alt="在这里插入图片描述"></p><p>注意虽然这里的I 依然是局部变量，但是对每个开启的协程来说已经不是同一个了，每次进入循环的I 都是不一样的。<br>但是这里我更推荐第一种写法，逻辑更加清楚</p>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
          <category> golang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> golang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker Desktop 安装教程，以及推荐Docker作为学习工具的理由</title>
      <link href="/2021/07/03/docker-desktop/"/>
      <url>/2021/07/03/docker-desktop/</url>
      
        <content type="html"><![CDATA[<p><a href="https://blog.csdn.net/xiaoliizi/article/details/118438413">本文csdn地址</a></p><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><a href="https://mp.weixin.qq.com/s/bmvELL89wtOqJuZjyv6bJw">博客-Docker-搭建可用SSH访问的centos镜像</a></p><p>2年前我写了一篇 关于如何在本地安装Docker 的教程），但是当时安装 Docker Desktop 还需要开启 hyper-v 或者是安装 toolbox 才能开启虚拟化。这两种情况下配置各有不同，而且也都需要配置环境变量，安装过程还是比较麻烦的。</p><p>但是现在有了 wsl2，在 windows 上使用 Docker 开发 更加方便了。本质上，wsl2 还是依赖hyper-v 技术，启动速度不慢，也不需要单独安装其他虚拟机，配置起来也更加方便。</p><p>不过wsl2 的方便性可以说是锦上添花，docker 最大的好处，我认为还是在相比虚拟机来说，它拥有和git 类似的<strong>仓库管理、版本</strong>等属性，有了这些基础，才有了作为开发工具的高效性。这才是我真正推荐它的原因。</p><p><strong>这篇博客主要就是帮大家避坑，把docker desktop 安装之后需要预设的配置尽量说明清楚，让大家可以安心地 在win10 系统上安装 Docker Desktop，以及提供一个基础开发镜像，帮助大家以后学习新技术能够更加方便。</strong></p><p><a href="https://docs.microsoft.com/zh-cn/windows/wsl/">wsl官网</a></p><h1 id="安装-docker-desktop"><a href="#安装-docker-desktop" class="headerlink" title="安装 docker desktop"></a>安装 docker desktop</h1><h2 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h2><h3 id="配置wsl"><a href="#配置wsl" class="headerlink" title="配置wsl"></a>配置wsl</h3><p>前提：本机已经安装了 wsl （参考<a href="https://learn.microsoft.com/en-us/windows/wsl/install-manual">官方教程</a>，使用docker 到第五步 Set WSL 2 as your default version完成就可以了。最新版本的win10 应该是自带的）<br>检查wsl 是否有安装：<br>到windows 功能中查找选项：适用于linux 的 windows 子系统</p><p>然后是限制 wsl 使用的资源：默认情况下，一旦你开启的镜像需要比较多资源，系统资源就会被直接吃满。<br>所以一定要记得设置wsl 占用资源配置，配置方式如下：<br>Win+R 然后输入 %UserProfile%  进入用户文件夹<br>然后编辑 .wslconfig 输入以下内容：(具体数值根据实际情况调整)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[wsl2]</span><br><span class="line">memory=4GB</span><br><span class="line">swap=5GB</span><br><span class="line">processors=5</span><br><span class="line">localhostForwarding=true</span><br></pre></td></tr></table></figure><p>memory: 内存<br>swap: 虚拟内存<br>processors: 处理器数量，当前电脑的processor 数量可以通过 wmic 指令获取<br>LocalhostForwarding: 允许本地通过 localhost 访问 wsl，默认就是开启<br><a href="https://docs.microsoft.com/en-us/windows/wsl/release-notes#build-18945">更多参数的说明</a></p><p>然后重启 lxss manager (即wsl服务)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">net stop LxssManager</span><br><span class="line">net start LxssManager</span><br></pre></td></tr></table></figure><p>最后是设置wsl 的数据存储路径，这个在安装 Docker Desktop 完成之后可以添加上去，参考下面的说明。</p><h3 id="注册一个-dockerhub-账号-和-国内云厂商-容器服务"><a href="#注册一个-dockerhub-账号-和-国内云厂商-容器服务" class="headerlink" title="注册一个 dockerhub 账号 和 国内云厂商 容器服务"></a>注册一个 dockerhub 账号 和 国内云厂商 容器服务</h3><p>账号本身 不影响 Docker Desktop  启动 ，但是还是建议体验一下容器镜像服务。容器镜像管理的方式类似git 代码，可以把自己后续学习其他技术的过程中 ，搭建好的镜像提交到云端，做备份用。也方便共享。<br>下面几个镜像服务提供商，个人版本都是免费的。不过主推还是国内的镜像服务，传输速度快一点。<br><a href="https://www.aliyun.com/product/acr">阿里云镜像服务</a>（前言中引的博客中有说明注册方式）<br><a href="https://cloud.tencent.com/document/product/1141">腾讯云镜像服务</a><br><a href="https://hub.docker.com/">dockerhub</a>（建议开启代理访问）</p><h2 id="安装-Desktop"><a href="#安装-Desktop" class="headerlink" title="安装 Desktop"></a>安装 Desktop</h2><p>首先从官网下载 最新版本，直接安装即可<br>安装完成之后，可以先测试是否能正常启动，其他配置可以慢慢来改，kubernetes 也不急着安装。</p><h2 id="2-3-Docker-Desktop-的配置"><a href="#2-3-Docker-Desktop-的配置" class="headerlink" title="2.3 Docker Desktop 的配置"></a>2.3 Docker Desktop 的配置</h2><h3 id="wsl-数据存储路径"><a href="#wsl-数据存储路径" class="headerlink" title="wsl 数据存储路径"></a>wsl 数据存储路径</h3><p>第一次成功启动 docker desktop 之后，你可以在 C:\Users\用户名\AppData\Local\Docker\wsl\data 这个目录下，找到ext4 文件，它就是 wsl 使用的虚拟机文件，我们使用docker 的所有操作和下载的所有文件，都会在这个目录中执行。<br>因此如果默认系统分了系统盘和数据盘，或者是我们有其他空间更大的硬盘可选，那么有必要将 这个ext4盘文件 进行迁移<br>注: 考虑到不管是在开发过程中，是轻量还是大量使用 docker desktop，最后 docker 都会占不小空间，建议第一次启动 docker desktop 之后就进行迁移，至少不要放在系统盘</p><p><img src="/2021/07/03/docker-desktop/desktop01.png" alt="wsl"></p><p>更新：20221008 发现一个工具可以帮我们快速迁移，比之前使用 wsl 指令，还需要先导出，再导入的操作稍微简单一些</p><p><a href="https://blog.csdn.net/qq_41601836/article/details/106610576">参考 - 如何修改WSL的安装路径</a></p><p><a href="https://github.com/DDoSolitary/LxRunOffline/releases/tag/v3.5.0">工具下载地址</a></p><p>迁移方式：先确认需要迁移的 wsl 名称：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./LxRunOffline.exe list</span><br></pre></td></tr></table></figure><p><img src="/2021/07/03/docker-desktop/desktop02.png" alt="wsl list"></p><p>然后执行迁移：（需要先关闭 docker desktop, 迁移需要一定时间）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./LxRunOffline.exe move -n docker-desktop-data -d &#x27;D:\wsl&#x27;</span><br></pre></td></tr></table></figure><p>== 以下是旧的迁移方式 ==</p><p>迁移步骤：首先退出 docker desktop ，并检查docker desktop 对应的虚拟机的状态，应该都要是关闭状态</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wsl --list -v</span><br></pre></td></tr></table></figure><p><img src="/2021/07/03/docker-desktop/desktop03.png" alt="查看wsl 状态"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wsl --export docker-desktop-data &quot;C:\Users\用户名\AppData\Local\Docker\wsl\data\docker-desktop-data.tar&quot;</span><br></pre></td></tr></table></figure><p>将目前的wsl 磁盘文件导出到指定压缩文件中</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wsl --unregister docker-desktop-data</span><br></pre></td></tr></table></figure><p>卸载docker-desktop-data服务</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wsl --import docker-desktop-data &quot;D:\docker\wsl\data&quot; &quot;D:\docker\wsl\docker-desktop-data.tar&quot; --version 2</span><br></pre></td></tr></table></figure><p>导入刚才导出的 wsl 磁盘文件<br>最后，重启 docker desktop，正常来说：<br>① docker 可以正常启动<br>② 原目录的 ext4 文件没有了（Distro 下面也有一个 ext4 文件，这个没关系）</p><h3 id="配置代理"><a href="#配置代理" class="headerlink" title="配置代理"></a>配置代理</h3><p>代理基本是开发过程中必备的，但是如果你使用的镜像服务是国内的，那么提交、下载镜像的时候又不应该走代理，所以需要在代理上额外配置一下：<br><img src="https://img-blog.csdnimg.cn/20210703230104617.png" alt="proxy"></p><p>如：使用阿里云镜像的代理配置<br>localhost,127.0.0.1,*.aliyuncs.com</p><h3 id="测试拉取并运行镜像"><a href="#测试拉取并运行镜像" class="headerlink" title="测试拉取并运行镜像"></a>测试拉取并运行镜像</h3><p>这里我们测试一个可直接通过 ssh 连接的镜像：jdeathe/centos-ssh<br><a href="https://github.com/jdeathe/centos-ssh">Git地址</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker pull jdeathe/centos-ssh</span><br><span class="line"></span><br><span class="line">docker run -d --env &quot;SSH_PASSWORD_AUTHENTICATION=true&quot; --env &quot;SSH_USER=centos&quot; --env &quot;SSH_USER_PASSWORD=test123&quot; --name ssh.1 -p 30022:22 jdeathe/centos-ssh</span><br></pre></td></tr></table></figure><p>除了启动命令的学习，这个仓库提供的Dockefile 非常标准化，是直接基于centos 原生镜像 在其基础上改的，从Dockerfile中也能看到非常多标准化的操作，想要学习 centos 原生镜像初始化细节的可以从这个项目的Dockerfile中了解更多细节。</p><h1 id="搭建自己的开发服务器"><a href="#搭建自己的开发服务器" class="headerlink" title="搭建自己的开发服务器"></a>搭建自己的开发服务器</h1><p>这里提供一个自己平时开发用的镜像，里面安装了一些开发语言的基本环境<br>其中，语言下载的依赖（比如 maven、gopath）都统一放在 /opt/path 目录下，安装的组件都放在 /opt/modules 下。</p><p><a href="https://github.com/smiecj/docker-centos">项目git地址（smiecj/docker-centos）</a><br>镜像下载和启动方式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 构建一个包含 golang、python、java 和 npm 的开发镜像</span><br><span class="line">REPO=mzsmieli nohup make build_dev_full</span><br><span class="line"></span><br><span class="line"># 运行镜像 （也可以直接运行 将从 docker hub 下载镜像）</span><br><span class="line">docker run -it -d -p 2222:22 mzsmieli/centos:base8_dev_full_1.0</span><br></pre></td></tr></table></figure><p>启动成功后，就可以进行自由的开发了。如果需要在容器内部编写代码，这里再推荐 vscode + ssh + 本地免密登录配置的开发模式。修改之后，在容器内部代码变更可以立刻生效，也可以在 vscode 中直接通过 命令行 执行操作<br><img src="https://img-blog.csdnimg.cn/20210703234447634.png" alt="ssh remote"></p><p><a href="https://smiecj.com/2022/05/31/vscode-tools">扩展: vscode 使用技巧</a></p><h1 id="后言：Docker-在现在开发的重要性"><a href="#后言：Docker-在现在开发的重要性" class="headerlink" title="后言：Docker 在现在开发的重要性"></a>后言：Docker 在现在开发的重要性</h1><p>现在不仅是信息爆炸的时代，更是技术爆炸的时代。底层技术虽然没有太大的变化，但是上层应用技术基本是2-3年一更新。<br>伴随而来的，不仅仅是我们自己知识库的更新，还有日益膨胀的操作系统。是的，有的时候我们需要在电脑上跑后台前端服务，有的时候也要学习其他基础组件，可能还要顺应潮流学一点机器学习。各种技术都需要安装一些依赖。不管是 mac 还是  windows，一旦你换一台电脑，迁移这些环境都是很费成本的。</p><p>因此 现在项目都推崇 协同开发的模式，所有代码、文档 都在云端统一管理。但是对个人来说，这种模式也慢慢变得必要起来。</p><p>所以我推荐 Docker 的原因就这么简单，只是镜像管理和环境管理的方便性，对于程序员来说就足够爱上它了。而且它也远不止这些内容，它的原理，以及 k8s 的实现，也是值得我们去学习的。共勉。</p>]]></content>
      
      
      <categories>
          
          <category> 开发工具 </category>
          
          <category> docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> docker </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
